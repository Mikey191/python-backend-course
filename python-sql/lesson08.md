# Модуль 2. Урок 8. Связи таблиц и основы нормализации. Соединения таблиц (JOIN)

## **Цель урока:**

- узнать, **что такое** связи между таблицами
- разобраться **почему** нужны связи между таблицами
- познакомится глубже с понятиями **первичный** и **внешний ключ**
- научится **нормализовать данные**, разделяя их на связанные таблицы
- практиковать запросы из нескольких таблиц сразу с помощью **JOIN**

# 1. Введение: зачем нужны связи между таблицами?

Представьте простую ситуацию: у вас есть интернет-магазин, и вы храните в одной таблице всю информацию о **товарах**, их **поставщиках**, **категориях** и **складских операциях**. На первый взгляд — удобно: один запрос → всё на месте. Но на практике такая **«толстая»** (или «монолитная») таблица быстро оборачивается рядом серьёзных проблем.

## Проблема «толстой» таблицы (денормализованная структура)

1. **Дублирование данных.**
   Если про каждого поставщика вы храните имя, адрес и контакты прямо в строках товаров, то данные о поставщике повторяются для каждого товара. При тысяче товаров одного поставщика — имя и контакт повторятся тысячу раз.

2. **Аномалии обновления (update anomaly).**
   Когда нужно поменять одно поле поставщика (например, телефон), придётся обновить множество строк. Если какую-то строку забыли — данные станут **неконсистентными** (телефон будет разным в разных местах).

3. **Аномалии вставки (insert anomaly).**
   Невозможно добавить поставщика, пока нет товара, если схема построена так, что поставщик — просто текстовое поле товаров и нет отдельной таблицы поставщиков с уникальными записями (иногда это мешает логике приложения).

4. **Аномалии удаления (delete anomaly).**
   Если удалить последний товар поставщика, то вместе с ним «исчезнут» и данные о поставщике (если они только в таблице товаров). То есть потеряется информация, которую желательно хранить независимо.

5. **Избыточное потребление места и ухудшение производительности.**
   Повторяющиеся строки увеличивают объём хранения и приводят к лишним операциям при поиске/сортировке.

6. **Трудности поддержания целостности данных.**
   Без единого места для поставщика трудно гарантировать уникальность, валидацию, историю изменений и т. п.

## Решение: разделение информации и связывание таблиц

Чтобы устранить все описанные проблемы, данные логически делят на отдельные сущности (таблицы). Например:

* `suppliers` — данные о поставщиках (id, name, phone, address…),
* `products` — данные о товарах (id, title, price, supplier\_id…),
* `categories` — категории товаров (id, name…),
* `stock` или `inventory` — операции прихода/расхода.

После этого таблицы **связывают между собой** — обычно связывают строку в таблице A с соответствующей записью в таблице B через специальное поле (идентификатор). 

Это позволяет:

* хранить уникальную запись о поставщике только в `suppliers` (без дублирования),
* в `products` ссылаться на поставщика через `supplier_id`,
* без проблем обновлять информацию о поставщике в одном месте,
* выполнять проверки ссылочной целостности (нет «висящих» ссылок на несуществующих поставщиков),
* легче добавлять метаданные (например историю изменений, адреса, контакты) и расширять модель.

---

# 2. Первичный и внешний ключ

Для связи таблиц используются две фундаментальные концепции: **первичный ключ (PRIMARY KEY)** и **внешний ключ (FOREIGN KEY)**. Разберём подробно — что это такое, как обычно называют поля, как задаются ограничения и что происходит с зависимыми данными при обновлении или удалении.

## Первичный ключ (PRIMARY KEY)

**Определение:** первичный ключ — это **столбец (или набор столбцов), однозначно идентифицирующий строку в таблице**.

**Свойства PK:**

* **уникальность**: значения не повторяются;
* **ненулевое значение** (NOT NULL);
* **обеспечивает быстрый поиск** (обычно по PK создаётся индекс);
* служит **точкой ссылки для других таблиц** (в них будут внешние ключи на этот PK).

**Варианты ключей:**

* **Суррогатный ключ** — искусственный идентификатор, чаще всего `id INTEGER PRIMARY KEY AUTOINCREMENT`. Удобен, прост и не зависит от реальных данных.
* **Натуральный ключ** — реальное поле(я), которые уже уникальны по смыслу (например, `email` для пользователей или `isbn` для книг). Использовать натуральные ключи можно, но есть риск, что «естественные» значения изменятся со временем (и это сложнее поддерживать).

**Примеры [DDL](lesson01.md#4-что-такое-sql-и-как-он-устроен):**

```sql
-- суррогатный ключ
CREATE TABLE suppliers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  phone TEXT
);

-- составной (композитный) первичный ключ
CREATE TABLE course_schedule (
  course_id INTEGER,
  weekday INTEGER,
  PRIMARY KEY (course_id, weekday)
);
```

**Практическая рекомендация:** чаще всего используют `id` как `PRIMARY KEY` (единообразие упрощает JOIN’ы и код).

## Внешний ключ (FOREIGN KEY)

**Определение:** внешний ключ — это **столбец (или набор столбцов) в одной таблице, значение которого ссылается на первичный (или уникальный) ключ другой таблицы**. Он реализует связь «сущность A ссылается на сущность B».

**Типичный пример:** в таблице `products` есть колонка `supplier_id`, которая хранит `id` из таблицы `suppliers`. Тогда `supplier_id` — внешний ключ, ссылающийся на `suppliers(id)`.

**Как обычно называют поля:**

* `id` — PK в таблице (например, `suppliers.id`),
* `<entity>_id` — FK в зависимой таблице (например, `supplier_id` в `products`). Такое именование (`snake_case`) стандартно и удобно.

**Пример DDL с FK (SQLite / SQL):**

```sql
CREATE TABLE suppliers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL
);

CREATE TABLE products (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT,
  supplier_id INTEGER,
  price REAL,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);
```

### Ограничения и действия (ON DELETE / ON UPDATE)

FK обычно сопровождается правилом, что делать при удалении или обновлении строки, на которую ссылаются:

* `ON DELETE CASCADE` — при удалении родителя (например, поставщика) автоматически удаляются все дочерние строки (товары). Удобно, но опасно: можно потерять много данных по одной операции.
* `ON DELETE SET NULL` — при удалении родителя значение FK в дочерних строках устанавливается в `NULL` (если FK допускает NULL). Позволяет сохранить записи, но «отсоединёнными».
* `ON DELETE RESTRICT` / `NO ACTION` — запретить удаление родителя, если существуют ссылки на него; классический способ защитить целостность.
* Аналогично `ON UPDATE CASCADE` — если поменялся ключ в родительской таблице (редко для автогенерируемых ID), то обновления применяются и в дочерних строках.

**Примеры:**

```sql
-- Удаление поставщика удалит все его товары
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  title TEXT,
  supplier_id INTEGER,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

**Важно (для SQLite):** по умолчанию в SQLite проверка внешних ключей выключена. Нужно включать явной командой:

```sql
PRAGMA foreign_keys = ON;
```

Или включать в соединении из приложения. Иначе `FOREIGN KEY` будет только декларацией, но не `enforced`.

## Что происходит со связанными данными (на практике)?

1. **При вставке:** если у дочерней записи указан `supplier_id`, которого нет в `suppliers`, СУБД с включённой проверкой FK не позволит вставить такую строку (ошибка referential integrity). Это предотвращает «висящие» ссылки.

2. **При обновлении родителя:**

   * Если `ON UPDATE CASCADE` — значения в дочерних строках обновятся автоматически.
   * Если нет — обновление родительского PK запрещено, либо дочерние строки остаются неконсистентными (в большинстве реализаций операция запрещена).

3. **При удалении родителя:** зависит от `ON DELETE`:

   * `CASCADE` — дочерние строки удаляются автоматически.
   * `SET NULL` — дочерние FK становятся `NULL`.
   * `RESTRICT/NO ACTION` — удаление запрещено при существующих ссылках.

4. **Проблемы и стратегии:**

   * **Опасность каскада:** `ON DELETE CASCADE` может «слить» большое дерево данных — используйте с осторожностью и только когда действительно нужно удалить всё вместе.
   * **Софт-удаление (soft delete):** вместо физического удаления ставить флаг `deleted = TRUE`. Это сохраняет историю и избегает потерь.
   * **Транзакции:** любые операции, затрагивающие несколько таблиц (например, удалить поставщика и логировать операцию), следует выполнять в транзакции, чтобы сохранить атомарность.

*Транзакция — это набор SQL-операций, которые выполняются как единое целое.*

## Какой `ON DELETE` чаще применяется на практике?

* **`ON DELETE RESTRICT`** или **`NO ACTION`** — чаще всего.
  Это защита: нельзя удалить родителя, пока на него ссылаются данные. Так сохраняется целостность.
* **`ON DELETE CASCADE`** используют реже, но удобно в ситуациях, где дочерние записи **не имеют смысла без родителя**. Например: если удалить заказ — должны исчезнуть и все его позиции (`order_items`).
* **`ON DELETE SET NULL`** — применяют, если допустимо, чтобы у строки временно не было связи (например, товар «осиротел» без поставщика).

**Практическое правило:**

* Для большинства справочников (категории, пользователи, предметы) — `RESTRICT`.
* Для зависимых данных (детали заказа, оценки студентов) — `CASCADE`.

---

## Составные (композитные) внешние ключи

Иногда таблица ссылается не на один столбец, а на комбинацию. Например, если первичный ключ — составной (`(order_id, product_id)`), то и внешний ключ должен ссылаться на оба поля одновременно.

```sql
CREATE TABLE order_items (
  order_id INTEGER,
  product_id INTEGER,
  qty INTEGER,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (product_id) REFERENCES products(id)
);
```

(Если parent PK композитный, то `FOREIGN KEY` должен перечислить все соответствующие столбцы.)

## Как правильно заполнять композитные внешние ключи?

Композитный (составной) внешний ключ ссылается сразу на **несколько столбцов**.
Пример: таблица «оценки» ссылается на `(student_id, subject_id)`.

```sql
CREATE TABLE grades (
    student_id INTEGER,
    subject_id INTEGER,
    grade INTEGER,
    FOREIGN KEY (student_id, subject_id) REFERENCES student_subjects(student_id, subject_id)
);
```

**Как заполнять:**

* в строке должны быть значения **обоих ключей**, которые уже есть в родительской таблице.
* если в родительской таблице нет пары `(student_id, subject_id)`, то вставка не пройдёт.

**Пример результата:**

```
student_subjects:
+------------+------------+
| student_id | subject_id |
+------------+------------+
| 1          | 10         |
| 2          | 20         |

grades:
+------------+------------+-------+
| student_id | subject_id | grade |
+------------+------------+-------+
| 1          | 10         |   5   |  ✅ допустимо
| 2          | 20         |   4   |  ✅ допустимо
| 1          | 20         |   3   |  ❌ ошибка (такой пары нет в student_subjects)
```

---

## Индексация внешних ключей

### Что такое индексы и индексация? (коротко)

**Индекс** в БД — это структура данных (обычно дерево), которая ускоряет поиск строк по определённому столбцу (или нескольким).
Он работает как «оглавление» или «алфавитный указатель в книге».

* Без индекса БД просматривает всю таблицу (full scan).
* С индексом поиск быстрее, но индексы занимают место и замедляют вставку/обновление (нужно поддерживать структуру).

### **Примеры, когда индекс нужен:**

* на `PRIMARY KEY` и `UNIQUE` поля индекс создаётся автоматически,
* на `FOREIGN KEY` обычно добавляют вручную,
* на часто используемые в фильтрах/сортировках поля (`WHERE`, `JOIN`, `ORDER BY`).

Пример создания индекса:

```sql
CREATE INDEX idx_products_supplier ON products(supplier_id);
```

---

#### Практика показывает: 
**Индексировать FK полезно**. Когда вы делаете JOIN или удаляете/обновляете родителя, СУБД быстро находит дочерние строки по FK, если по этому полю есть индекс. В SQLite при PK обычно индекс уже есть, но для FK в дочерних таблицах индекс следует создать вручную при больших объёмах данных.

## Имена и соглашения (рекомендации)

* Таблицы именовать во множественном числе (`products`, `suppliers`) или единственном — главное соблюдать единообразие.
* Поля PK: `id` (типично).
* Внешние ключи: `<entity>_id` → `supplier_id`, `student_id`, `subject_id`.
* Для FK-ограничений давать явные имена (в СУБД, где это возможно) — упрощает отладку:

  ```sql
  CONSTRAINT fk_products_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
  ```

## Краткие практические примеры (объединяем концепции)

**Пример: студенты и оценки**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL
);

CREATE TABLE grades (
  id INTEGER PRIMARY KEY,
  student_id INTEGER NOT NULL,
  subject_id INTEGER NOT NULL,
  grade INTEGER,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE RESTRICT
);
```

* `student_id` и `subject_id` — FK.
* При удалении студента его оценки удаляются автоматически (`CASCADE`).
* При попытке удалить предмет, если есть оценки, `ON DELETE RESTRICT` запретит удаление.

**Пример JOIN (наглядно, без визуала):**

```sql
SELECT s.name, sub.title, g.grade
FROM grades g
JOIN students s ON s.id = g.student_id
JOIN subjects sub ON sub.id = g.subject_id;
```

В результате вы получите табличный вывод, где каждая строка — студент + предмет + оценка. Так вы «соединяете» области данных, хранящиеся в разных таблицах.

---

# 3. Виды связей между таблицами

В реляционной модели данные хранятся в таблицах — но реальный мир устроен так, что одна сущность связана с другой. Существует три фундаментальных типа связей:

## 1) Один-к-одному (1:1)

**Описание:** каждой строке в таблице A соответствует не более одной строки в таблице B, и наоборот.
**Примеры:** человек ↔ паспорт (в реальности один человек может иметь один паспорт), пользователь ↔ профиль настроек.

**Как моделируют в БД:**

* Обычно одна из таблиц получает внешний ключ на другую с уникальным ограничением, либо обе таблицы используют один и тот же PK (shared PK).
* Часто `table_a.id` — PK; `table_b.a_id` — FK с `UNIQUE` (или `PRIMARY KEY`) — это гарантирует 1:1.

**DDL (вариант с UNIQUE FK):**

```sql
CREATE TABLE person (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE passport (
  id INTEGER PRIMARY KEY,
  person_id INTEGER UNIQUE,   -- уникальная связь
  passport_number TEXT,
  FOREIGN KEY (person_id) REFERENCES person(id)
);
```

**Пояснение:** `person_id` помечен `UNIQUE`, поэтому на одного `person.id` не может ссылаться более одной строки `passport`. При необходимости можно поставить `person_id` как `PRIMARY KEY` в `passport`.

## 2) Один-ко-многим (1\:M)

**Описание:** одной строке в таблице A соответствует много строк в таблице B. Это самый частый тип связей.
**Примеры:** категорию ↔ продукты (одна категория — много продуктов), преподаватель ↔ предметы, студент ↔ оценки.

**Моделирование:** у «многих» в таблице B есть поле-ссылка `a_id` (FK), указывающее на `A.id`.

**DDL:**

```sql
CREATE TABLE category (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE product (
  id INTEGER PRIMARY KEY,
  title TEXT,
  category_id INTEGER,
  FOREIGN KEY (category_id) REFERENCES category(id)
);
```

**Пояснение:** каждый `product` содержит `category_id`. Один `category` может иметь множество `product`.

## 3) Многие-ко-многим (M\:N)

**Описание:** строки таблицы A связаны с множеством строк таблицы B и наоборот.
**Примеры:** студенты ↔ предметы (студент учит много предметов, предмет изучают многие студенты), товары ↔ теги.

**Моделирование:** создаётся промежуточная (junction) таблица, которая хранит пары ссылок — это и есть связь M\:N. Часто эту таблицу называют `student_subject`, `product_tag` и т.п.

**DDL:**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT
);

CREATE TABLE student_subjects (   -- junction table
  student_id INTEGER,
  subject_id INTEGER,
  PRIMARY KEY (student_id, subject_id),  -- составный PK
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (subject_id) REFERENCES subjects(id)
);
```

**Пояснение:**

* `student_subjects` хранит пары `(student_id, subject_id)`.
* Для одного студента может быть несколько строк с разными `subject_id` (и наоборот).
* Составной PK `PRIMARY KEY (student_id, subject_id)` гарантирует, что одна и та же пара не повторится.

---

# 4. Основы нормализации — почему и как «разворачивать» данные

Нормализация — это набор правил и приёмов, цель которых — уменьшить избыточность и аномалии данных, повысить однозначность и удобство поддержания. Давайте разберёмся на конкретном примере: начнём с **одной «толстой» таблицы** и шаг за шагом нормализуем её до 3НФ.

## Изначальная (денормализованная) таблица — «всё в одном»

Предположим, у вас система учёта оценок и вы изначально храните всё в одной таблице `records`:

```sql
CREATE TABLE records (
  id INTEGER PRIMARY KEY,
  student_name TEXT,
  student_email TEXT,
  subject_title TEXT,
  teacher_name TEXT,
  teacher_email TEXT,
  semester TEXT,
  grade INTEGER,
  created_at TEXT
);
```

**Примеры строк:**

| id | student\_name | student\_email                        | subject\_title | teacher\_name | teacher\_email                            | semester | grade | created\_at |
| -- | ------------- | ------------------------------------- | -------------- | ------------- | ----------------------------------------- | -------- | ----- | ----------- |
| 1  | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Математика     | Петров        | [petrov@mail.com](mailto:petrov@mail.com) | 2023S1   | 5     | 2023-06-01  |
| 2  | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Физика         | Сидоров       | [sidor@mail.com](mailto:sidor@mail.com)   | 2023S1   | 4     | 2023-06-02  |
| 3  | Ольга Петрова | [olga@mail.com](mailto:olga@mail.com) | Математика     | Петров        | [petrov@mail.com](mailto:petrov@mail.com) | 2023S1   | 5     | 2023-06-01  |

**Проблемы такой таблицы:**

* **Дублирование данных:** `student_name` / `student_email` повторяются для каждой оценки студента; `teacher_*` повторяются для каждого предмета; `subject_title` тоже многократно повторяется.
* **Аномалии обновления:** если у `Петров` меняется email, нужно обновить множество строк.
* **Нарушение единичного источника правды:** нет центра, где хранится информация о студентах или предметах.
* **Сложности ссылочной целостности:** нельзя легко обеспечить FK и уникальность.

Теперь — нормализуем шаг за шагом.

---

## 1НФ (первая нормальная форма) — атомарность значений

**Правило 1НФ:** все значения в колонках — атомарны (не списки/массивы), таблица имеет четкую структуру строк и столбцов.

**Частые нарушения 1НФ:** в одной колонке хранится «список предметов через запятую» или «массив телефонов». Такое нужно разобрать — сохранить каждое значение в отдельной строке.

В нашем примере `records` уже в общем виде в 1НФ (каждое поле — атомарное). Но если бы была колонка `subjects` со значением `'Математика, Физика'`, нужно было бы вынести в отдельные строки/таблицы.

---

## 2НФ (вторая нормальная форма) — убрать частичные зависимости

**Правило 2НФ:** таблица должна быть в 1НФ и **все неключевые атрибуты должны полностью зависеть от всего первичного ключа**, а не от его части. Смысл: убрать частичные зависимости, которые возможны, если PK составной.

В нашем первоначальном `records` PK был `id` (суррогатный), поэтому формально 2НФ не нарушается из-за частичных зависимостей, но логически мы видим, что `student_*` и `teacher_*` не зависят от оценки: они зависят только от студента/преподавателя. Поэтому естественный шаг — выделить студентов, предметы и преподавателей в отдельные таблицы.

**Нормализация в 2 шага (выделяем сущности):**

1. Создаём таблицы `students`, `teachers`, `subjects`, `grades` (где `grades` хранит только связь и оценку).

**DDL после разделения:**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT UNIQUE
);

CREATE TABLE teachers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT UNIQUE
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  teacher_id INTEGER,
  FOREIGN KEY (teacher_id) REFERENCES teachers(id)
);

CREATE TABLE grades (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  student_id INTEGER NOT NULL,
  subject_id INTEGER NOT NULL,
  semester TEXT,
  grade INTEGER,
  created_at TEXT,
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (subject_id) REFERENCES subjects(id)
);
```

**Что поменялось (логика):**

* `students` содержит данные про студента один раз.
* `teachers` содержит данные про преподавателя один раз.
* `subjects` ссылается на `teacher` (если предмет ведёт конкретный преподаватель).
* `grades` хранит только «связь» студент→предмет и саму оценку.

Это устраняет большое количество дублирования.

---

## 3НФ (третья нормальная форма) — убрать транзитивные зависимости

**Правило 3НФ:** таблица в 2НФ и **никакой неключевой атрибут не должен зависеть транзитивно от ключа** (т.е. не должно быть A → B → C, где C зависит от B, а B — от ключа).

Применение в нашем примере: убедиться, что в таблице `grades` нет полей, которые зависят не от `student_id, subject_id` напрямую, а от связанных сущностей. Например, если в `grades` оставили `teacher_email`, то это транзитивная зависимость (`grade` → `subject_id` → `teacher_id` → `teacher_email`) — это нарушение 3НФ. Поэтому такие поля были вынесены в `teachers`.

**Итог:** структура из предыдущего шага удовлетворяет 3НФ, потому что:

* `grades` содержит только поля, непосредственно связанные со связью студент-предмет (оценка, семестр).
* сведения о преподавателях и студентах вынесены в отдельные таблицы.

---

## Пример переноса конкретных строк: «до» → «после»

**До (records):**

| id | student\_name | student\_email                        | subject\_title | teacher\_name | grade |
| -- | ------------- | ------------------------------------- | -------------- | ------------- | ----- |
| 1  | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Математика     | Петров        | 5     |
| 2  | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Физика         | Сидоров       | 4     |
| 3  | Ольга         | [olga@mail.com](mailto:olga@mail.com) | Математика     | Петров        | 5     |

**После нормализации:**

`students`:

| id | name        | email                                 |
| -- | ----------- | ------------------------------------- |
| 1  | Иван Иванов | [ivan@mail.com](mailto:ivan@mail.com) |
| 2  | Ольга       | [olga@mail.com](mailto:olga@mail.com) |

`teachers`:

| id | name    | email        |
| -- | ------- | ------------ |
| 1  | Петров  | petrov\@mail |
| 2  | Сидоров | sidor\@mail  |

`subjects`:

| id | title      | teacher\_id |
| -- | ---------- | ----------- |
| 1  | Математика | 1           |
| 2  | Физика     | 2           |

`grades`:

| id | student\_id | subject\_id | grade |
| -- | ----------- | ----------- | ----- |
| 1  | 1           | 1           | 5     |
| 2  | 1           | 2           | 4     |
| 3  | 2           | 1           | 5     |

Теперь:

* чтобы получить те же отчёты, мы делаем `JOIN` между `grades`, `students`, `subjects`, `teachers`.
* при изменении email преподавателя — меняем одну строку в `teachers`, не ходим по множеству записей.

---

## Немного про 3НФ — что такое «транзитивная зависимость» простыми словами

Если в таблице А есть столбец B, и столбец B определяет столбец C (т.е. B → C), то C транзитивно зависит от первичного ключа (PK → B → C). В 3НФ такого быть не должно — C нужно вынести в отдельную таблицу, где она принадлежит B.

Пример: в таблице `products` есть `category_id` и `category_name`. Здесь `category_name` транзитивно зависит от `category_id` — правильнее создать таблицу `categories(id, name)`.

---

## Когда нормализация — не лучшая идея? (кратко)

* **Производительность**: на очень больших объёмах частые `JOIN` могут быть дорогими; иногда ради скорости данные денормализуют (например, сохраняют `category_name` прямо в `products`) — это trade-off.
* **Аналитические хранилища (OLAP)**: часто используют денормализованные схемы (звёздные/снежинки) для быстрой агрегации.
* **Простота разработки**: для очень простых приложений иногда проще начинать с небольшой денормализованной структуры и нормализовать позже.

Но **в операционных системах (OLTP)** обычно стремятся к 3НФ или близким к ней формам, чтобы избегать аномалий и облегчить поддержку.

---

--------
--------
--------
--------
--------
--------
--------



