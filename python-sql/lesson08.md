# Модуль 2. Урок 8. Связи таблиц и основы нормализации. Соединения таблиц (JOIN)

## **Цель урока:**

- узнать, **что такое** связи между таблицами
- разобраться **почему** нужны связи между таблицами
- познакомится глубже с понятиями **первичный** и **внешний ключ**
- научится **нормализовать данные**, разделяя их на связанные таблицы
- практиковать запросы из нескольких таблиц сразу с помощью **JOIN**

# 1. Введение: зачем нужны связи между таблицами?

Представьте простую ситуацию: у вас есть интернет-магазин, и вы храните в одной таблице всю информацию о **товарах**, их **поставщиках**, **категориях** и **складских операциях**. На первый взгляд — удобно: один запрос → всё на месте. Но на практике такая **«толстая»** (или «монолитная») таблица быстро оборачивается рядом серьёзных проблем.

## Проблема «толстой» таблицы (денормализованная структура)

1. **Дублирование данных.**
   Если про каждого поставщика вы храните имя, адрес и контакты прямо в строках товаров, то данные о поставщике повторяются для каждого товара. При тысяче товаров одного поставщика — имя и контакт повторятся тысячу раз.

2. **Аномалии обновления (update anomaly).**
   Когда нужно поменять одно поле поставщика (например, телефон), придётся обновить множество строк. Если какую-то строку забыли — данные станут **неконсистентными** (телефон будет разным в разных местах).

3. **Аномалии вставки (insert anomaly).**
   Невозможно добавить поставщика, пока нет товара, если схема построена так, что поставщик — просто текстовое поле товаров и нет отдельной таблицы поставщиков с уникальными записями (иногда это мешает логике приложения).

4. **Аномалии удаления (delete anomaly).**
   Если удалить последний товар поставщика, то вместе с ним «исчезнут» и данные о поставщике (если они только в таблице товаров). То есть потеряется информация, которую желательно хранить независимо.

5. **Избыточное потребление места и ухудшение производительности.**
   Повторяющиеся строки увеличивают объём хранения и приводят к лишним операциям при поиске/сортировке.

6. **Трудности поддержания целостности данных.**
   Без единого места для поставщика трудно гарантировать уникальность, валидацию, историю изменений и т. п.

## Решение: разделение информации и связывание таблиц

Чтобы устранить все описанные проблемы, данные логически делят на отдельные сущности (таблицы). Например:

- `suppliers` — данные о поставщиках (id, name, phone, address…),
- `products` — данные о товарах (id, title, price, supplier_id…),
- `categories` — категории товаров (id, name…),
- `stock` или `inventory` — операции прихода/расхода.

После этого таблицы **связывают между собой** — обычно связывают строку в таблице A с соответствующей записью в таблице B через специальное поле (идентификатор).

Это позволяет:

- хранить уникальную запись о поставщике только в `suppliers` (без дублирования),
- в `products` ссылаться на поставщика через `supplier_id`,
- без проблем обновлять информацию о поставщике в одном месте,
- выполнять проверки ссылочной целостности (нет «висящих» ссылок на несуществующих поставщиков),
- легче добавлять метаданные (например историю изменений, адреса, контакты) и расширять модель.

---

# 2. Первичный и внешний ключ

Для связи таблиц используются две фундаментальные концепции: **первичный ключ (PRIMARY KEY)** и **внешний ключ (FOREIGN KEY)**. Разберём подробно — что это такое, как обычно называют поля, как задаются ограничения и что происходит с зависимыми данными при обновлении или удалении.

## Первичный ключ (PRIMARY KEY)

**Определение:** первичный ключ — это **столбец (или набор столбцов), однозначно идентифицирующий строку в таблице**.

**Свойства PK:**

- **уникальность**: значения не повторяются;
- **ненулевое значение** (NOT NULL);
- **обеспечивает быстрый поиск** (обычно по PK создаётся индекс);
- служит **точкой ссылки для других таблиц** (в них будут внешние ключи на этот PK).

**Варианты ключей:**

- **Суррогатный ключ** — искусственный идентификатор, чаще всего `id INTEGER PRIMARY KEY AUTOINCREMENT`. Удобен, прост и не зависит от реальных данных.
- **Натуральный ключ** — реальное поле(я), которые уже уникальны по смыслу (например, `email` для пользователей или `isbn` для книг). Использовать натуральные ключи можно, но есть риск, что «естественные» значения изменятся со временем (и это сложнее поддерживать).

**Примеры [DDL](lesson01.md#4-что-такое-sql-и-как-он-устроен):**

```sql
-- суррогатный ключ
CREATE TABLE suppliers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  phone TEXT
);

-- составной (композитный) первичный ключ
CREATE TABLE course_schedule (
  course_id INTEGER,
  weekday INTEGER,
  PRIMARY KEY (course_id, weekday)
);
```

**Практическая рекомендация:** чаще всего используют `id` как `PRIMARY KEY` (единообразие упрощает JOIN’ы и код).

## Внешний ключ (FOREIGN KEY)

**Определение:** внешний ключ — это **столбец (или набор столбцов) в одной таблице, значение которого ссылается на первичный (или уникальный) ключ другой таблицы**. Он реализует связь «сущность A ссылается на сущность B».

**Типичный пример:** в таблице `products` есть колонка `supplier_id`, которая хранит `id` из таблицы `suppliers`. Тогда `supplier_id` — внешний ключ, ссылающийся на `suppliers(id)`.

**Как обычно называют поля:**

- `id` — PK в таблице (например, `suppliers.id`),
- `<entity>_id` — FK в зависимой таблице (например, `supplier_id` в `products`). Такое именование (`snake_case`) стандартно и удобно.

**Пример DDL с FK (SQLite / SQL):**

```sql
CREATE TABLE suppliers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL
);

CREATE TABLE products (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT,
  supplier_id INTEGER,
  price REAL,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);
```

### Ограничения и действия (ON DELETE / ON UPDATE)

FK обычно сопровождается правилом, что делать при удалении или обновлении строки, на которую ссылаются:

- `ON DELETE CASCADE` — при удалении родителя (например, поставщика) автоматически удаляются все дочерние строки (товары). Удобно, но опасно: можно потерять много данных по одной операции.
- `ON DELETE SET NULL` — при удалении родителя значение FK в дочерних строках устанавливается в `NULL` (если FK допускает NULL). Позволяет сохранить записи, но «отсоединёнными».
- `ON DELETE RESTRICT` / `NO ACTION` — запретить удаление родителя, если существуют ссылки на него; классический способ защитить целостность.
- Аналогично `ON UPDATE CASCADE` — если поменялся ключ в родительской таблице (редко для автогенерируемых ID), то обновления применяются и в дочерних строках.

**Примеры:**

```sql
-- Удаление поставщика удалит все его товары
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  title TEXT,
  supplier_id INTEGER,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

**Важно (для SQLite):** по умолчанию в SQLite проверка внешних ключей выключена. Нужно включать явной командой:

```sql
PRAGMA foreign_keys = ON;
```

Или включать в соединении из приложения. Иначе `FOREIGN KEY` будет только декларацией, но не `enforced`.

## Что происходит со связанными данными (на практике)?

1. **При вставке:** если у дочерней записи указан `supplier_id`, которого нет в `suppliers`, СУБД с включённой проверкой FK не позволит вставить такую строку (ошибка referential integrity). Это предотвращает «висящие» ссылки.

2. **При обновлении родителя:**

   - Если `ON UPDATE CASCADE` — значения в дочерних строках обновятся автоматически.
   - Если нет — обновление родительского PK запрещено, либо дочерние строки остаются неконсистентными (в большинстве реализаций операция запрещена).

3. **При удалении родителя:** зависит от `ON DELETE`:

   - `CASCADE` — дочерние строки удаляются автоматически.
   - `SET NULL` — дочерние FK становятся `NULL`.
   - `RESTRICT/NO ACTION` — удаление запрещено при существующих ссылках.

4. **Проблемы и стратегии:**

   - **Опасность каскада:** `ON DELETE CASCADE` может «слить» большое дерево данных — используйте с осторожностью и только когда действительно нужно удалить всё вместе.
   - **Софт-удаление (soft delete):** вместо физического удаления ставить флаг `deleted = TRUE`. Это сохраняет историю и избегает потерь.
   - **Транзакции:** любые операции, затрагивающие несколько таблиц (например, удалить поставщика и логировать операцию), следует выполнять в транзакции, чтобы сохранить атомарность.

_Транзакция — это набор SQL-операций, которые выполняются как единое целое._

## Какой `ON DELETE` чаще применяется на практике?

- **`ON DELETE RESTRICT`** или **`NO ACTION`** — чаще всего.
  Это защита: нельзя удалить родителя, пока на него ссылаются данные. Так сохраняется целостность.
- **`ON DELETE CASCADE`** используют реже, но удобно в ситуациях, где дочерние записи **не имеют смысла без родителя**. Например: если удалить заказ — должны исчезнуть и все его позиции (`order_items`).
- **`ON DELETE SET NULL`** — применяют, если допустимо, чтобы у строки временно не было связи (например, товар «осиротел» без поставщика).

**Практическое правило:**

- Для большинства справочников (категории, пользователи, предметы) — `RESTRICT`.
- Для зависимых данных (детали заказа, оценки студентов) — `CASCADE`.

---

## Составные (композитные) внешние ключи

Иногда таблица ссылается не на один столбец, а на комбинацию. Например, если первичный ключ — составной (`(order_id, product_id)`), то и внешний ключ должен ссылаться на оба поля одновременно.

```sql
CREATE TABLE order_items (
  order_id INTEGER,
  product_id INTEGER,
  qty INTEGER,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (product_id) REFERENCES products(id)
);
```

(Если parent PK композитный, то `FOREIGN KEY` должен перечислить все соответствующие столбцы.)

## Как правильно заполнять композитные внешние ключи?

Композитный (составной) внешний ключ ссылается сразу на **несколько столбцов**.
Пример: таблица «оценки» ссылается на `(student_id, subject_id)`.

```sql
CREATE TABLE grades (
    student_id INTEGER,
    subject_id INTEGER,
    grade INTEGER,
    FOREIGN KEY (student_id, subject_id) REFERENCES student_subjects(student_id, subject_id)
);
```

**Как заполнять:**

- в строке должны быть значения **обоих ключей**, которые уже есть в родительской таблице.
- если в родительской таблице нет пары `(student_id, subject_id)`, то вставка не пройдёт.

**Пример результата:**

```
student_subjects:
+------------+------------+
| student_id | subject_id |
+------------+------------+
| 1          | 10         |
| 2          | 20         |

grades:
+------------+------------+-------+
| student_id | subject_id | grade |
+------------+------------+-------+
| 1          | 10         |   5   |  ✅ допустимо
| 2          | 20         |   4   |  ✅ допустимо
| 1          | 20         |   3   |  ❌ ошибка (такой пары нет в student_subjects)
```

---

## Индексация внешних ключей

### Что такое индексы и индексация? (коротко)

**Индекс** в БД — это структура данных (обычно дерево), которая ускоряет поиск строк по определённому столбцу (или нескольким).
Он работает как «оглавление» или «алфавитный указатель в книге».

- Без индекса БД просматривает всю таблицу (full scan).
- С индексом поиск быстрее, но индексы занимают место и замедляют вставку/обновление (нужно поддерживать структуру).

### **Примеры, когда индекс нужен:**

- на `PRIMARY KEY` и `UNIQUE` поля индекс создаётся автоматически,
- на `FOREIGN KEY` обычно добавляют вручную,
- на часто используемые в фильтрах/сортировках поля (`WHERE`, `JOIN`, `ORDER BY`).

Пример создания индекса:

```sql
CREATE INDEX idx_products_supplier ON products(supplier_id);
```

---

#### Практика показывает:

**Индексировать FK полезно**. Когда вы делаете JOIN или удаляете/обновляете родителя, СУБД быстро находит дочерние строки по FK, если по этому полю есть индекс. В SQLite при PK обычно индекс уже есть, но для FK в дочерних таблицах индекс следует создать вручную при больших объёмах данных.

## Имена и соглашения (рекомендации)

- Таблицы именовать во множественном числе (`products`, `suppliers`) или единственном — главное соблюдать единообразие.
- Поля PK: `id` (типично).
- Внешние ключи: `<entity>_id` → `supplier_id`, `student_id`, `subject_id`.
- Для FK-ограничений давать явные имена (в СУБД, где это возможно) — упрощает отладку:

  ```sql
  CONSTRAINT fk_products_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
  ```

## Краткие практические примеры (объединяем концепции)

**Пример: студенты и оценки**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL
);

CREATE TABLE grades (
  id INTEGER PRIMARY KEY,
  student_id INTEGER NOT NULL,
  subject_id INTEGER NOT NULL,
  grade INTEGER,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE RESTRICT
);
```

- `student_id` и `subject_id` — FK.
- При удалении студента его оценки удаляются автоматически (`CASCADE`).
- При попытке удалить предмет, если есть оценки, `ON DELETE RESTRICT` запретит удаление.

**Пример JOIN (наглядно, без визуала):**

```sql
SELECT s.name, sub.title, g.grade
FROM grades g
JOIN students s ON s.id = g.student_id
JOIN subjects sub ON sub.id = g.subject_id;
```

В результате вы получите табличный вывод, где каждая строка — студент + предмет + оценка. Так вы «соединяете» области данных, хранящиеся в разных таблицах.

---

# 3. Виды связей между таблицами

В реляционной модели данные хранятся в таблицах — но реальный мир устроен так, что одна сущность связана с другой. Существует три фундаментальных типа связей:

## 1) Один-к-одному (1:1)

**Описание:** каждой строке в таблице A соответствует не более одной строки в таблице B, и наоборот.
**Примеры:** человек ↔ паспорт (в реальности один человек может иметь один паспорт), пользователь ↔ профиль настроек.

**Как моделируют в БД:**

- Обычно одна из таблиц получает внешний ключ на другую с уникальным ограничением, либо обе таблицы используют один и тот же PK (shared PK).
- Часто `table_a.id` — PK; `table_b.a_id` — FK с `UNIQUE` (или `PRIMARY KEY`) — это гарантирует 1:1.

**DDL (вариант с UNIQUE FK):**

```sql
CREATE TABLE person (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE passport (
  id INTEGER PRIMARY KEY,
  person_id INTEGER UNIQUE,   -- уникальная связь
  passport_number TEXT,
  FOREIGN KEY (person_id) REFERENCES person(id)
);
```

**Пояснение:** `person_id` помечен `UNIQUE`, поэтому на одного `person.id` не может ссылаться более одной строки `passport`. При необходимости можно поставить `person_id` как `PRIMARY KEY` в `passport`.

## 2) Один-ко-многим (1\:M)

**Описание:** одной строке в таблице A соответствует много строк в таблице B. Это самый частый тип связей.
**Примеры:** категорию ↔ продукты (одна категория — много продуктов), преподаватель ↔ предметы, студент ↔ оценки.

**Моделирование:** у «многих» в таблице B есть поле-ссылка `a_id` (FK), указывающее на `A.id`.

**DDL:**

```sql
CREATE TABLE category (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE product (
  id INTEGER PRIMARY KEY,
  title TEXT,
  category_id INTEGER,
  FOREIGN KEY (category_id) REFERENCES category(id)
);
```

**Пояснение:** каждый `product` содержит `category_id`. Один `category` может иметь множество `product`.

## 3) Многие-ко-многим (M\:N)

**Описание:** строки таблицы A связаны с множеством строк таблицы B и наоборот.
**Примеры:** студенты ↔ предметы (студент учит много предметов, предмет изучают многие студенты), товары ↔ теги.

**Моделирование:** создаётся промежуточная (junction) таблица, которая хранит пары ссылок — это и есть связь M\:N. Часто эту таблицу называют `student_subject`, `product_tag` и т.п.

**DDL:**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT
);

CREATE TABLE student_subjects (   -- junction table
  student_id INTEGER,
  subject_id INTEGER,
  PRIMARY KEY (student_id, subject_id),  -- составный PK
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (subject_id) REFERENCES subjects(id)
);
```

**Пояснение:**

- `student_subjects` хранит пары `(student_id, subject_id)`.
- Для одного студента может быть несколько строк с разными `subject_id` (и наоборот).
- Составной PK `PRIMARY KEY (student_id, subject_id)` гарантирует, что одна и та же пара не повторится.

---

# 4. Основы нормализации — почему и как «разворачивать» данные

Нормализация — это набор правил и приёмов, цель которых — уменьшить избыточность и аномалии данных, повысить однозначность и удобство поддержания. Давайте разберёмся на конкретном примере: начнём с **одной «толстой» таблицы** и шаг за шагом нормализуем её до 3НФ.

## Изначальная (денормализованная) таблица — «всё в одном»

Предположим, у вас система учёта оценок и вы изначально храните всё в одной таблице `records`:

```sql
CREATE TABLE records (
  id INTEGER PRIMARY KEY,
  student_name TEXT,
  student_email TEXT,
  subject_title TEXT,
  teacher_name TEXT,
  teacher_email TEXT,
  semester TEXT,
  grade INTEGER,
  created_at TEXT
);
```

**Примеры строк:**

| id  | student_name  | student_email                         | subject_title | teacher_name | teacher_email                             | semester | grade | created_at |
| --- | ------------- | ------------------------------------- | ------------- | ------------ | ----------------------------------------- | -------- | ----- | ---------- |
| 1   | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Математика    | Петров       | [petrov@mail.com](mailto:petrov@mail.com) | 2023S1   | 5     | 2023-06-01 |
| 2   | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Физика        | Сидоров      | [sidor@mail.com](mailto:sidor@mail.com)   | 2023S1   | 4     | 2023-06-02 |
| 3   | Ольга Петрова | [olga@mail.com](mailto:olga@mail.com) | Математика    | Петров       | [petrov@mail.com](mailto:petrov@mail.com) | 2023S1   | 5     | 2023-06-01 |

**Проблемы такой таблицы:**

- **Дублирование данных:** `student_name` / `student_email` повторяются для каждой оценки студента; `teacher_*` повторяются для каждого предмета; `subject_title` тоже многократно повторяется.
- **Аномалии обновления:** если у `Петров` меняется email, нужно обновить множество строк.
- **Нарушение единичного источника правды:** нет центра, где хранится информация о студентах или предметах.
- **Сложности ссылочной целостности:** нельзя легко обеспечить FK и уникальность.

Теперь — нормализуем шаг за шагом.

---

## 1НФ (первая нормальная форма) — атомарность значений

**Правило 1НФ:** все значения в колонках — атомарны (не списки/массивы), таблица имеет четкую структуру строк и столбцов. Т.е. **в каждой ячейке только одно значение, нет повторяющихся групп или списков**.

**Частые нарушения 1НФ:** в одной колонке хранится «список предметов через запятую» или «массив телефонов». Такое нужно разобрать — сохранить каждое значение в отдельной строке.

### **Неправильный пример (НЕ 1НФ):**

| id  | student_name | student_email | subject_title      | teacher_name    | teacher_email               | semester | grade | created_at |
| --- | ------------ | ------------- | ------------------ | --------------- | --------------------------- | -------- | ----- | ---------- |
| 1   | Иван Иванов  | ivan@mail.ru  | Математика, Физика | Петров, Сидоров | petrov@mail.ru, sid@mail.ru | 2024-1   | 5, 4  | 2024-06-01 |

> _Здесь в некоторых ячейках сразу несколько значений (через запятую)._

### **Правильный пример (1НФ):**

| id  | student_name | student_email | subject_title | teacher_name | teacher_email  | semester | grade | created_at |
| --- | ------------ | ------------- | ------------- | ------------ | -------------- | -------- | ----- | ---------- |
| 1   | Иван Иванов  | ivan@mail.ru  | Математика    | Петров       | petrov@mail.ru | 2024-1   | 5     | 2024-06-01 |
| 2   | Иван Иванов  | ivan@mail.ru  | Физика        | Сидоров      | sid@mail.ru    | 2024-1   | 4     | 2024-06-01 |

> _Теперь в каждой ячейке только одно значение._

---

## 2НФ (вторая нормальная форма) — убрать частичные зависимости

**Правило 2НФ:** **таблица должна быть в 1НФ** и **все неключевые атрибуты должны полностью зависеть от всего составного первичного ключа**, а не от его части. Смысл: убрать частичные зависимости, которые возможны, если PK составной.

В нашем первоначальном `records` PK был `id` (суррогатный), поэтому формально 2НФ не нарушается из-за частичных зависимостей, но логически мы видим, что `student_*` и `teacher_*` не зависят от оценки: они зависят только от студента/преподавателя. Поэтому естественный шаг — выделить студентов, предметы и преподавателей в отдельные таблицы.

### **Неправильный пример (НЕ 2НФ):**

| student_name | student_email | subject_title | teacher_name | teacher_email  | semester | grade | created_at |
| ------------ | ------------- | ------------- | ------------ | -------------- | -------- | ----- | ---------- |
| Иван Иванов  | ivan@mail.ru  | Математика    | Петров       | petrov@mail.ru | 2024-1   | 5     | 2024-06-01 |
| Иван Иванов  | ivan@mail.ru  | Физика        | Сидоров      | sid@mail.ru    | 2024-1   | 4     | 2024-06-01 |

> _Здесь email студента зависит только от имени студента, а не от всей строки (например, предмета). Аналогично с учителем._

### **Правильные таблицы (2НФ):**

#### **Таблица студентов:**

| student_id | student_name | student_email |
| ---------- | ------------ | ------------- |
| 1          | Иван Иванов  | ivan@mail.ru  |

#### **Таблица учителей:**

| teacher_id | teacher_name | teacher_email  |
| ---------- | ------------ | -------------- |
| 1          | Петров       | petrov@mail.ru |
| 2          | Сидоров      | sid@mail.ru    |

#### **Таблица предметов:**

| subject_id | subject_title |
| ---------- | ------------- |
| 1          | Математика    |
| 2          | Физика        |

#### **Таблица оценок (журнал):**

| record_id | student_id | subject_id | teacher_id | semester | grade | created_at |
| --------- | ---------- | ---------- | ---------- | -------- | ----- | ---------- |
| 1         | 1          | 1          | 1          | 2024-1   | 5     | 2024-06-01 |
| 2         | 1          | 2          | 2          | 2024-1   | 4     | 2024-06-01 |

> _Теперь email студента и учителя хранятся только в своих таблицах, а не дублируются._

**Что поменялось (логика):**

- `students` содержит данные про студента один раз.
- `teachers` содержит данные про преподавателя один раз.
- `subjects` ссылается на `teacher` (если предмет ведёт конкретный преподаватель).
- `grades` хранит только «связь» студент→предмет и саму оценку.

Это устраняет большое количество дублирования.

---

## 3НФ (третья нормальная форма) — убрать транзитивные зависимости

**Правило 3НФ:** **таблица в 2НФ** и **никакой неключевой атрибут не должен зависеть транзитивно от ключа** (не должно быть A → B → C, где C зависит от B, а B — от ключа). Т.е. **нет неключевых столбцов, зависящих друг от друга**.

### **Неправильный пример (НЕ 3НФ):**

| student_id | student_name | student_email | student_group | group_curator |
| ---------- | ------------ | ------------- | ------------- | ------------- |
| 1          | Иван Иванов  | ivan@mail.ru  | Группа 101    | Смирнов       |

> _Здесь curator зависит от группы, а не от студента напрямую._

### **Правильные таблицы (3НФ):**

#### **Таблица студентов:**

| student_id | student_name | student_email | group_id |
| ---------- | ------------ | ------------- | -------- |
| 1          | Иван Иванов  | ivan@mail.ru  | 1        |

#### **Таблица групп:**

| group_id | group_name | group_curator |
| -------- | ---------- | ------------- |
| 1        | Группа 101 | Смирнов       |

> _Теперь curator хранится только в таблице групп, а не у каждого студента._

---

## **Результат нормализации**

В результате нормализации ваша база будет состоять из связанных таблиц:

- **students** (студенты)
- **teachers** (преподаватели)
- **subjects** (предметы)
- **groups** (группы, если нужно)
- **grades/records** (журнал оценок)

Это уменьшает избыточность, повышает целостность данных и облегчает сопровождение базы данных.

---

## Когда нормализация — не лучшая идея? (кратко)

- **Производительность**: на очень больших объёмах частые `JOIN` могут быть дорогими; иногда ради скорости данные денормализуют (например, сохраняют `category_name` прямо в `products`) — это trade-off.
- **Аналитические хранилища (OLAP)**: часто используют денормализованные схемы (звёздные/снежинки) для быстрой агрегации.
- **Простота разработки**: для очень простых приложений иногда проще начинать с небольшой денормализованной структуры и нормализовать позже.

Но **в операционных системах (OLTP)** обычно стремятся к 3НФ или близким к ней формам, чтобы избегать аномалий и облегчить поддержку.

---

# 5. JOIN — основы

Когда мы разобрались с тем, как создавать таблицы и связывать их через **первичные** и **внешние ключи**, настал момент научиться работать с данными сразу из нескольких таблиц. На практике почти никогда не бывает так, что нужная информация лежит в одной таблице.

Например:

- В таблице **students** у нас есть только имена студентов.
- В таблице **grades** — оценки, но они ссылаются на `student_id`.
- В таблице **subjects** — список предметов.

Чтобы вывести красивый список вроде:

> "Иван Иванов получил по математике 5",

нам нужно связать между собой **три разные таблицы**. Именно для этого в SQL есть соединения (JOIN).

---

### INNER JOIN

**INNER JOIN** показывает **только те строки, которые совпадают** в обеих таблицах.
Представьте себе два круга в диаграмме Венна — результат будет пересечение.

Пример: студенты, у которых есть оценки. Те студенты, у кого пока оценок нет, просто не попадут в выборку.

> Обычно `INNER JOIN` используется чаще всего, потому что мы в большинстве случаев работаем только с данными, которые реально связаны.

---

**Пример.** Получить список студентов и их оценки вместе с названием предмета.

```sql
SELECT s.name AS student,
       subj.title AS subject,
       g.grade
FROM grades g
INNER JOIN students s ON g.student_id = s.id
INNER JOIN subjects subj ON g.subject_id = subj.id;
```

> Здесь берутся только те строки, где есть совпадение и по студенту, и по предмету. Если нет оценки — студент не попадёт. Это базовый и самый используемый вариант.

---

### LEFT JOIN

**LEFT JOIN** берёт все строки из левой таблицы и добавляет к ним данные из правой, если они есть. Если совпадений нет — в правой части будут `NULL`.

Пример: мы хотим вывести **всех студентов**, даже если у кого-то ещё нет оценок. В таком случае **LEFT JOIN** покажет студента, а в колонке "grade" будет пусто (`NULL`).

> Это очень удобно, когда нам нужно видеть "всю картину", даже если часть данных ещё не заполнена.

---

**Пример.** Показать всех студентов и их оценки, даже если у кого-то пока нет ни одной оценки.

```sql
SELECT s.name AS student,
       g.grade,
       g.subject_id
FROM students s
LEFT JOIN grades g ON s.id = g.student_id;
```

> Все студенты попадут в выборку, даже если в `grades` у них пусто. Для «безоценочных» студентов в колонках из `grades` будут NULL.

---

### RIGHT JOIN

**RIGHT JOIN** — это зеркальная версия LEFT JOIN.
Она показывает **все строки из правой таблицы**, а слева — совпадения, если есть.

⚠️ Но в SQLite нет оператора `RIGHT JOIN`.
Что делать? Мы можем просто поменять таблицы местами и использовать `LEFT JOIN`. То есть технически он нам не нужен, но знать о нём полезно: в PostgreSQL, MySQL и других СУБД он встречается.

---

**Пример.** Показать все оценки и имена студентов (если студент удалён, а запись в `grades` осталась, имя будет NULL).

Так как SQLite **не поддерживает RIGHT JOIN напрямую**, поэтому заменяем порядок таблиц и используем LEFT JOIN.

```sql
SELECT g.id AS grade_id,
       g.grade,
       s.name AS student
FROM grades g
LEFT JOIN students s ON g.student_id = s.id;
```

> Это «аналог RIGHT JOIN students → grades», только через перестановку таблиц. Основной приём для SQLite.

---

### FULL OUTER JOIN

**FULL OUTER JOIN** объединяет результат **LEFT JOIN** и **RIGHT JOIN**.
То есть показывает вообще все строки из обеих таблиц: совпавшие и не совпавшие.

⚠️ В SQLite тоже нет прямой поддержки FULL OUTER JOIN.
Но мы можем получить аналог через объединение (`UNION`) результатов двух запросов:

- Один через LEFT JOIN
- Второй через RIGHT JOIN (эмулированный)

И в итоге мы получим то же самое.

> На практике FULL OUTER JOIN используется нечасто, потому что обычно нужны конкретные связи, а не "абсолютно всё".

---

**Пример.** Показать всех студентов и все оценки: если у студента нет оценок — будут строки с NULL в `grades`; если в `grades` есть «осиротевшие» записи без студента — тоже должны попасть.

```sql
SELECT s.id AS student_id,
       s.name AS student,
       g.grade
FROM students s
LEFT JOIN grades g ON s.id = g.student_id
UNION
SELECT s.id AS student_id,
       s.name AS student,
       g.grade
FROM grades g
LEFT JOIN students s ON g.student_id = s.id;
```

> Такой приём объединяет результаты двух LEFT JOIN в обе стороны, что и даёт FULL OUTER JOIN. На практике используется редко, но знать принцип полезно.

### CROSS JOIN

**CROSS JOIN** — это **декартово произведение**.
Каждая строка из первой таблицы соединяется с каждой строкой из второй.

Например:

- У нас 10 студентов и 5 предметов.
- Если сделать CROSS JOIN, получится 50 комбинаций "студент–предмет".

Такой приём используется редко, но иногда он удобен для генерации всех возможных комбинаций, особенно если потом мы добавляем фильтрацию.

---

**Пример.** Получить все возможные комбинации «студент × предмет» (например, чтобы подготовить таблицу для последующего заполнения оценками).

```sql
SELECT s.name AS student,
       subj.title AS subject
FROM students s
CROSS JOIN subjects subj;
```

> Это декартово произведение: если 10 студентов и 5 предметов — будет 50 строк. Используется осторожно, т.к. результат растёт очень быстро.

### Итог: какие JOIN используются чаще всего?

- **INNER JOIN** — основа работы, применяется чаще всего.
- **LEFT JOIN** — когда нужно увидеть все записи из одной таблицы, даже если нет связей.
- **RIGHT JOIN** и **FULL OUTER JOIN** — встречаются редко, и в SQLite работают только через обходные пути.
- **CROSS JOIN** — специфический инструмент, но знать о нём стоит.

> В нашей практике мы будем концентрироваться в первую очередь на **INNER JOIN** и **LEFT JOIN**, так как это самые полезные операторы для реальной работы с данными.

---

# 6. Логический порядок выполнения запросов.

## Обновлённый логический порядок выполнения SQL-запроса, учитывающий оператор JOIN:

- `FROM` — выбор основной таблицы.
- `JOIN` — присоединение других таблиц к основной (по условиям соединения).
- `WHERE` — фильтрация строк (до группировки).
- `GROUP BY` — объединение строк в группы.
- `HAVING` — фильтрация групп (по агрегатам или выражениям над группой).
- `SELECT` — вычисление итоговых выражений, агрегатов, алиасов.
- `ORDER BY` — сортировка результирующих строк.
- `LIMIT` — ограничение числа возвращаемых строк.

**Важно:**

**JOIN** — это часть этапа **FROM**, но логически сначала выбирается основная таблица, затем к ней присоединяются остальные через JOIN по заданным условиям.

---

## **Структура таблиц и их связи дле демонстрации запросов**

### **1. students** — студенты

| id  | name           | email          | "group" |
| --- | -------------- | -------------- | ------- |
| 1   | Иван Иванов    | ivan@mail.ru   | 101     |
| 2   | Ольга Петрова  | olga@mail.ru   | 102     |
| 3   | Сергей Смирнов | sergey@mail.ru | 101     |

### **2. teachers** — преподаватели

| id  | name         | email          |
| --- | ------------ | -------------- |
| 1   | Петров П.П.  | petrov@mail.ru |
| 2   | Сидоров С.С. | sid@mail.ru    |

### **3. subjects** — предметы

| id  | title      |
| --- | ---------- |
| 1   | Математика |
| 2   | Физика     |
| 3   | Химия      |

### **4. records** — журнал оценок (связующая таблица)

| id  | student_id | subject_id | teacher_id | semester | grade | created_at |
| --- | ---------- | ---------- | ---------- | -------- | ----- | ---------- |
| 1   | 1          | 1          | 1          | 2024-1   | 5     | 2024-06-01 |
| 2   | 1          | 2          | 2          | 2024-1   | 4     | 2024-06-01 |
| 3   | 2          | 1          | 1          | 2024-1   | 3     | 2024-06-01 |
| 4   | 3          | 1          | 1          | 2024-1   | 2     | 2024-06-01 |
| 5   | 3          | 3          | 2          | 2024-1   | 5     | 2024-06-01 |
| 6   | 2          | 2          | 2          | 2024-1   | 5     | 2024-06-01 |

---

### **Связи между таблицами**

- `records.student_id` → `students.id`
- `records.subject_id` → `subjects.id`
- `records.teacher_id` → `teachers.id`

---

### Создание таблиц

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  "group" TEXT NOT NULL
);

CREATE TABLE teachers (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT NOT NULL
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL
);

CREATE TABLE records (
  id INTEGER PRIMARY KEY,
  student_id INTEGER NOT NULL,
  subject_id INTEGER NOT NULL,
  teacher_id INTEGER NOT NULL,
  semester TEXT NOT NULL,
  grade INTEGER,
  created_at TEXT NOT NULL,
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (subject_id) REFERENCES subjects(id),
  FOREIGN KEY (teacher_id) REFERENCES teachers(id)
);
```

### Заполнение данными

```sql
-- Заполнение таблицы студентов
INSERT INTO students (id, name, email, "group") VALUES
(1, 'Иван Иванов', 'ivan@mail.ru', '101'),
(2, 'Ольга Петрова', 'olga@mail.ru', '102'),
(3, 'Сергей Смирнов', 'sergey@mail.ru', '101');

-- Заполнение таблицы преподавателей
INSERT INTO teachers (id, name, email) VALUES
(1, 'Петров П.П.', 'petrov@mail.ru'),
(2, 'Сидоров С.С.', 'sid@mail.ru');

-- Заполнение таблицы предметов
INSERT INTO subjects (id, title) VALUES
(1, 'Математика'),
(2, 'Физика'),
(3, 'Химия');

-- Заполнение таблицы оценок (журнал)
INSERT INTO records (id, student_id, subject_id, teacher_id, semester, grade, created_at) VALUES
(1, 1, 1, 1, '2024-1', 5, '2024-06-01'),
(2, 1, 2, 2, '2024-1', 4, '2024-06-01'),
(3, 2, 1, 1, '2024-1', 3, '2024-06-01'),
(4, 3, 1, 1, '2024-1', 2, '2024-06-01'),
(5, 3, 3, 2, '2024-1', 5, '2024-06-01'),
(6, 2, 2, 2, '2024-1', 5, '2024-06-01');
```

### Примеры запросов

#### **Пример 1: JOIN + WHERE**

```sql
SELECT students.name, subjects.title
FROM students
JOIN records ON students.id = records.student_id
JOIN subjects ON records.subject_id = subjects.id
WHERE students."group" = '101';
```

**Результат:**  
Покажет имена студентов из группы 101 и названия предметов, которые они изучают.

---

#### **Пример 2: JOIN + GROUP BY + HAVING**

```sql
SELECT subjects.title, COUNT(records.student_id) AS student_count
FROM subjects
JOIN records ON subjects.id = records.subject_id
WHERE records.grade >= 3
GROUP BY subjects.title
HAVING COUNT(records.student_id) > 1;
```

**Результат:**  
Покажет предметы, по которым сдали экзамен (оценка ≥ 3) больше одного студента.

---

#### **Пример 3: JOIN + WHERE + GROUP BY + HAVING + ORDER BY**

```sql
SELECT teachers.name, AVG(records.grade) AS avg_grade
FROM teachers
JOIN records ON teachers.id = records.teacher_id
WHERE records.grade IS NOT NULL
GROUP BY teachers.name
HAVING AVG(records.grade) > 4
ORDER BY avg_grade DESC;
```

**Результат:**  
Покажет преподавателей, у которых средний балл студентов выше 4, отсортированных по убыванию среднего балла.

---

# 7. Практика **«Учебный центр» — Students / Subjects / Teachers → Groups (M:M) → Gradebook (Journal of grades)**

## Основные сущности, связи и архитектура приложения

### Практика 1 — **Students / Subjects / Teachers**

- **teachers**

  - `id`, `name`, `email`

- **subjects**

  - `id`, `name`, `teacher_id`
  - связь: **subject → teacher** — многие предметы у одного преподавателя (1 : M)
  - поведение FK: `ON DELETE SET NULL` (при удалении преподавателя поле `teacher_id` обнуляется)

- **students**

  - `id`, `first_name`, `last_name`, `email`, `subject_id`
  - связь: **student → subject** — у студента «основной» предмет (1 student → 1 subject; subject → many students) (1 : M)
  - поведение FK: `ON DELETE CASCADE` (при удалении предмета соответствующие студенты удаляются — для демонстрации CASCADE)

- Примечание: в данных может быть `NULL` (студент без subject, subject без teacher).

---

### Практика 2 — добавляем **Groups (M:M)**

- **groups**

  - `id`, `name`

- **group_members**

  - `group_id`, `student_id`, `role`
  - связь: **groups ↔ students** через `group_members` — M : M
  - PK: `(group_id, student_id)`
  - FK-ограничения: оба FK с `ON DELETE CASCADE` (удаление группы или студента удаляет записи в `group_members`)

---

### Практика 3 — добавляем **grades (журнал оценок)**

- **grades**

  - `id`, `student_id`, `subject_id`, `teacher_id`, `grade`, `exam_date`
  - связи:

    - `grades.student_id` → `students.id` (FK, `ON DELETE CASCADE`)
    - `grades.subject_id` → `subjects.id` (FK, `ON DELETE CASCADE`)
    - `grades.teacher_id` → `teachers.id` (FK, `ON DELETE SET NULL`)

- Используется для запросов с JOIN + `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY`, оконных функций и т.д.

---

### Архитектура Python-приложения

#### **core.py** — класс/функции для работы с БД (подключение, `PRAGMA foreign_keys = ON`, `create_tables()`, `seed_data()`, `execute()`/`fetchall()` и т.п.).

```python
import sqlite3

class Database:
    def __init__(self, db_name="school.db"):
        self.conn = sqlite3.connect(db_name)
        self.conn.execute("PRAGMA foreign_keys = ON;")  # включаем поддержку FK
        self.cur = self.conn.cursor()

    def executescript(self, script: str):
        """Выполнить SQL-скрипт (несколько команд)."""
        self.conn.executescript(script)
        self.conn.commit()

    def execute(self, query: str, params: tuple = ()):
        """Выполнить одиночный запрос (без fetch)."""
        self.cur.execute(query, params)
        self.conn.commit()

    def fetchall(self, query: str, params: tuple = ()):
        """Выполнить запрос и вернуть все строки."""
        self.cur.execute(query, params)
        return self.cur.fetchall()

    def close(self):
        self.conn.close()

def create_tables(db: Database):
    """
    Функция для создания таблиц. Может включать код для удаления таблиц для удобного перезапуска приложения (DROP TABLE IF EXISTS name_table;).
    """

def seed_data(db: Database):
    """
    Функция для заполнения таблиц данными.
    """
```

#### **function(s).py** — набор функций, реализующих задачи/запросы для практик.

```python
"""
Модуль с реализацией практических задач.
"""
```

#### **interface.py** — CLI/меню для выбора задания и отображения результатов.

```python
from core import Database, create_tables, seed_data
from logic import sql_group_std_count

def show_data(rows):
    """Печатает данные в виде таблицы."""
    if not rows:
        print("Нет данных")
    for row in rows:
        print(row)


def menu(db: Database):
    actions = {
        "1": ("Создать таблицы", lambda: create_tables(db)),
        "2": ("Заполнить тестовыми данными", lambda: seed_data(db)),
        "3": ("Показать всех студентов", lambda: show_data(
            db.fetchall("SELECT id, first_name, last_name, email FROM students;")
        )),
        "4": ("Показать все предметы", lambda: show_data(
            db.fetchall("SELECT id, name, teacher_id FROM subjects;")
        )),
        "5": ("Показать всех преподавателей", lambda: show_data(
            db.fetchall("SELECT id, name, email FROM teachers;")
        )),
        '6': ('Тест', lambda: show_data(db.fetchall(sql_query))),
        "0": ("Выход", lambda: exit(0))
    }

    while True:
        print("\nМеню:")
        for key, (title, _) in actions.items():
            print(f"{key}. {title}")
        choice = input("Выберите действие: ")

        action = actions.get(choice)
        if action:
            action[1]()  # вызываем lambda
        else:
            print("Неверный выбор!")
```

#### **main.py** — точка входа: инициализация БД, меню, опции reset/seed и т.д.

```python
from core import Database
from interface import menu

def main():
    db = Database("school.db")
    try:
        menu(db)
    finally:
        db.close()

if __name__ == "__main__":
    main()
```

---

## Практика 1

### Таблицы

```sql
CREATE TABLE teachers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  email TEXT
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  teacher_id INTEGER,
  FOREIGN KEY (teacher_id) REFERENCES teachers(id) ON DELETE SET NULL
);

CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT,
  last_name TEXT,
  email TEXT,
  subject_id INTEGER,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE CASCADE
);
```

### Фейковые данные

**1. Учителя (`teachers`)**

```sql
INSERT INTO teachers (name, email) VALUES
('Иван Петров', 'ivan.petrov@school.ru'),
('Мария Сидорова', 'maria.sidorova@school.ru'),
('Андрей Кузнецов', 'andrey.kuznetsov@school.ru'),
('Ольга Иванова', 'olga.ivanova@school.ru'),
('Сергей Смирнов', 'sergey.smirnov@school.ru'),
('Екатерина Орлова', 'ekaterina.orlova@school.ru'),
('Павел Волков', 'pavel.volkov@school.ru'),
('Анна Громова', 'anna.gromova@school.ru'),
('Дмитрий Никитин', 'dmitry.nikitin@school.ru'),
('Наталья Романова', 'natalia.romanova@school.ru');
```

---

**2. Предметы (`subjects`)**

```sql
INSERT INTO subjects (name, teacher_id) VALUES
('Математика', 1),
('Информатика', 2),
('Физика', 3),
('История', 4),
('Литература', 5),
('Английский язык', 6),
('Биология', 7);
```

---

**3. Студенты (`students`)**

```sql
INSERT INTO students (first_name, last_name, email, subject_id) VALUES
('Алексей', 'Миронов', 'alexey.mironov@mail.ru', 1),
('Елена', 'Иванова', 'elena.ivanova@mail.ru', 1),
('Игорь', 'Поляков', 'igor.polyakov@mail.ru', 2),
('Наталья', 'Соколова', 'natalia.sokolova@mail.ru', 2),
('Кирилл', 'Волков', 'kirill.volkov@mail.ru', 2),
('Мария', 'Кузнецова', 'maria.kuznetsova@mail.ru', 3),
('Олег', 'Смирнов', 'oleg.smirnov@mail.ru', 3),
('Евгения', 'Орлова', 'evgenia.orlova@mail.ru', 3),
('Сергей', 'Громов', 'sergey.gromov@mail.ru', 4),
('Дмитрий', 'Иванов', 'dmitry.ivanov@mail.ru', 4),
('Анна', 'Романова', 'anna.romanova@mail.ru', 5),
('Павел', 'Никитин', 'pavel.nikitin@mail.ru', 5),
('Виктория', 'Петрова', 'victoria.petrova@mail.ru', 6),
('Артем', 'Сидоров', 'artem.sidorov@mail.ru', 6),
('Людмила', 'Гусева', 'lyudmila.guseva@mail.ru', 6),
('Илья', 'Сорокин', 'ilya.sorokin@mail.ru', 7),
('Дарья', 'Федорова', 'daria.fedorova@mail.ru', 7),
('Владимир', 'Крылов', 'vladimir.krylov@mail.ru', 1),
('Ольга', 'Семенова', 'olga.semenova@mail.ru', 2),
('Галина', 'Лебедева', 'galina.lebedeva@mail.ru', 4);
```

---

### Задачи:

#### Задача 1.

**Вывести всех студентов вместе с названием предмета, который они изучают.**

#### Задача 2.

**Показать имя учителя и предмет, который он преподаёт.**

#### Задача 3.

**Показать имя студента, название предмета и имя преподавателя.**

#### Задача 4.

**Показать всех преподавателей, включая тех, у кого пока нет предметов.**

#### Задача 5.

**Показать все предметы и количество студентов, изучающих каждый из них.**

#### Задача 6.

**Найти преподавателей, у которых больше 3 студентов.**

#### Задача 7.

**Создать кросс-продукт преподавателей и предметов (все возможные пары).**

---

### Решение:

#### Задача 1.

**Вывести всех студентов вместе с названием предмета, который они изучают.**

> Тип JOIN: `INNER JOIN`

```sql
SELECT s.first_name, s.last_name, sub.name AS subject
FROM students AS s
INNER JOIN subjects AS sub ON s.subject_id = sub.id;
```

#### Задача 2.

**Показать имя учителя и предмет, который он преподаёт.**

> Тип JOIN: `INNER JOIN`

```sql
SELECT t.name AS teacher, sub.name AS subject
FROM teachers AS t
INNER JOIN subjects AS sub ON t.id = sub.teacher_id;
```

#### Задача 3.

**Показать имя студента, название предмета и имя преподавателя.**

> Тип JOIN: `INNER JOIN` (с тремя таблицами)

```sql
SELECT s.first_name, s.last_name, sub.name AS subject, t.name AS teacher
FROM students AS s
INNER JOIN subjects AS sub ON s.subject_id = sub.id
INNER JOIN teachers AS t ON sub.teacher_id = t.id;
```

#### Задача 4.

**Показать всех преподавателей, включая тех, у кого пока нет предметов.**

> Тип JOIN: `LEFT JOIN`

```sql
SELECT t.name AS teacher, sub.name AS subject
FROM teachers AS t
LEFT JOIN subjects AS sub ON t.id = sub.teacher_id;
```

#### Задача 5.

**Показать все предметы и количество студентов, изучающих каждый из них.**

> Используется `LEFT JOIN` + `COUNT()`

```sql
SELECT sub.name AS subject, COUNT(s.id) AS student_count
FROM subjects AS sub
LEFT JOIN students AS s ON sub.id = s.subject_id
GROUP BY sub.name;
```

#### Задача 6.

**Найти преподавателей, у которых больше 3 студентов.**

> Используется `INNER JOIN` + `GROUP BY` + `HAVING`

```sql
SELECT t.name AS teacher, COUNT(s.id) AS total_students
FROM teachers AS t
INNER JOIN subjects AS sub ON t.id = sub.teacher_id
INNER JOIN students AS s ON sub.id = s.subject_id
GROUP BY t.name
HAVING COUNT(s.id) > 3;
```

#### Задача 7.

**Создать кросс-продукт преподавателей и предметов (все возможные пары).**

> Тип JOIN: `CROSS JOIN`

```sql
SELECT t.name AS teacher, sub.name AS subject
FROM teachers AS t
CROSS JOIN subjects AS sub;
```

---

## Практика 2

### Таблицы

```sql
CREATE TABLE teachers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  email TEXT
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  teacher_id INTEGER,
  FOREIGN KEY (teacher_id) REFERENCES teachers(id) ON DELETE SET NULL
);

CREATE TABLE groups (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT
);

CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT,
  last_name TEXT,
  email TEXT,
  subject_id INTEGER,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE CASCADE
);

CREATE TABLE group_student (
  group_id INTEGER,
  student_id INTEGER,
  PRIMARY KEY (group_id, student_id),
  FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE
);
```

### Фейковые данные

**1. Учителя (`teachers`)**

```sql
INSERT INTO teachers (name, email) VALUES
('Иван Петров', 'ivan.petrov@school.ru'),
('Мария Сидорова', 'maria.sidorova@school.ru'),
('Андрей Кузнецов', 'andrey.kuznetsov@school.ru'),
('Ольга Иванова', 'olga.ivanova@school.ru'),
('Сергей Смирнов', 'sergey.smirnov@school.ru'),
('Екатерина Орлова', 'ekaterina.orlova@school.ru'),
('Павел Волков', 'pavel.volkov@school.ru'),
('Анна Громова', 'anna.gromova@school.ru'),
('Дмитрий Никитин', 'dmitry.nikitin@school.ru'),
('Наталья Романова', 'natalia.romanova@school.ru');
```

---

**2. Предметы (`subjects`)**

```sql
INSERT INTO subjects (name, teacher_id) VALUES
('Математика', 1),
('Информатика', 2),
('Физика', 3),
('История', 4),
('Литература', 5),
('Английский язык', 6),
('Биология', 7);
```

---

**3. Группы (`groups`)**

```sql
INSERT INTO groups (name) VALUES
('Поток А'),
('Поток B'),
('Поток C'),
('Поток D');
```

---

**4. Студенты (`students`)**

```sql
INSERT INTO students (first_name, last_name, email, subject_id) VALUES
('Алексей', 'Миронов', 'alexey.mironov@mail.ru', 1),
('Елена', 'Иванова', 'elena.ivanova@mail.ru', 1),
('Игорь', 'Поляков', 'igor.polyakov@mail.ru', 2),
('Наталья', 'Соколова', 'natalia.sokolova@mail.ru', 2),
('Кирилл', 'Волков', 'kirill.volkov@mail.ru', 2),
('Мария', 'Кузнецова', 'maria.kuznetsova@mail.ru', 3),
('Олег', 'Смирнов', 'oleg.smirnov@mail.ru', 3),
('Евгения', 'Орлова', 'evgenia.orlova@mail.ru', 3),
('Сергей', 'Громов', 'sergey.gromov@mail.ru', 4),
('Дмитрий', 'Иванов', 'dmitry.ivanov@mail.ru', 4),
('Анна', 'Романова', 'anna.romanova@mail.ru', 5),
('Павел', 'Никитин', 'pavel.nikitin@mail.ru', 5),
('Виктория', 'Петрова', 'victoria.petrova@mail.ru', 6),
('Артем', 'Сидоров', 'artem.sidorov@mail.ru', 6),
('Людмила', 'Гусева', 'lyudmila.guseva@mail.ru', 6),
('Илья', 'Сорокин', 'ilya.sorokin@mail.ru', 7),
('Дарья', 'Федорова', 'daria.fedorova@mail.ru', 7),
('Владимир', 'Крылов', 'vladimir.krylov@mail.ru', 1),
('Ольга', 'Семенова', 'olga.semenova@mail.ru', 2),
('Галина', 'Лебедева', 'galina.lebedeva@mail.ru', 4);
```

---

**5. Связи `group_student`**

- Группа A — 6 студентов
- Группа B — 5 студентов
- Группа C — 9 студентов
- Группа D — пустая

```sql
-- Поток A
INSERT INTO group_student (group_id, student_id) VALUES
(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6);

-- Поток B
INSERT INTO group_student (group_id, student_id) VALUES
(2, 7), (2, 8), (2, 9), (2, 10), (2, 11);

-- Поток C
INSERT INTO group_student (group_id, student_id) VALUES
(3, 12), (3, 13), (3, 14), (3, 15), (3, 16), (3, 17), (3, 18), (3, 19), (3, 20);

-- Поток D — пока без студентов
```

---

### Задачи:

#### Задача 1.

**Вывести список всех студентов и групп, в которых они состоят.**

#### Задача 2.

**Показать все группы, включая те, где пока нет студентов.**

#### Задача 3.

**Показать имя студента, предмет, и группу, в которой он учится.**

#### Задача 4.

**Показать все группы и количество студентов в каждой.**

#### Задача 5.

**Показать всех преподавателей и студентов, изучающих их предметы.**

#### Задача 6.

**Показать список всех преподавателей и количество студентов у каждого.**

#### Задача 7.

**Создать кросс-продукт всех студентов и всех групп (все возможные сочетания).**

---

### Решение:

#### Задача 1.

**Вывести список всех студентов и групп, в которых они состоят.**

> Тип JOIN: `INNER JOIN`

```sql
SELECT s.first_name, s.last_name, g.name AS group_name
FROM students AS s
INNER JOIN group_student AS gs ON s.id = gs.student_id
INNER JOIN groups AS g ON gs.group_id = g.id;
```

---

#### Задача 2.

**Показать все группы, включая те, где пока нет студентов.**

> Тип JOIN: `LEFT JOIN`

```sql
SELECT g.name AS group_name, s.first_name, s.last_name
FROM groups AS g
LEFT JOIN group_student AS gs ON g.id = gs.group_id
LEFT JOIN students AS s ON s.id = gs.student_id;
```

---

#### Задача 3.

**Показать имя студента, предмет, и группу, в которой он учится.**

> Тип JOIN: `INNER JOIN` с четырьмя таблицами

```sql
SELECT s.first_name, s.last_name, sub.name AS subject, g.name AS group_name
FROM students AS s
INNER JOIN subjects AS sub ON s.subject_id = sub.id
INNER JOIN group_student AS gs ON s.id = gs.student_id
INNER JOIN groups AS g ON gs.group_id = g.id;
```

---

#### Задача 4.

**Показать все группы и количество студентов в каждой.**

> Тип JOIN: `LEFT JOIN` + `COUNT()`

```sql
SELECT g.name AS group_name, COUNT(gs.student_id) AS student_count
FROM groups AS g
LEFT JOIN group_student AS gs ON g.id = gs.group_id
GROUP BY g.name;
```

---

#### Задача 5.

**Показать всех преподавателей и студентов, изучающих их предметы.**

> Тип JOIN: `INNER JOIN` с тремя таблицами

```sql
SELECT t.name AS teacher, s.first_name, s.last_name, sub.name AS subject
FROM teachers AS t
INNER JOIN subjects AS sub ON t.id = sub.teacher_id
INNER JOIN students AS s ON s.subject_id = sub.id;
```

---

#### Задача 6.

**Показать список всех преподавателей и количество студентов у каждого.**

> Тип JOIN: `LEFT JOIN` + `COUNT()` + `GROUP BY`

```sql
SELECT t.name AS teacher, COUNT(s.id) AS total_students
FROM teachers AS t
LEFT JOIN subjects AS sub ON t.id = sub.teacher_id
LEFT JOIN students AS s ON s.subject_id = sub.id
GROUP BY t.name;
```

---

#### Задача 7.

**Создать кросс-продукт всех студентов и всех групп (все возможные сочетания).**

> Тип JOIN: `CROSS JOIN`

```sql
SELECT s.first_name, s.last_name, g.name AS group_name
FROM students AS s
CROSS JOIN groups AS g;
```

---

## Практика 3

### Таблицы

```sql
CREATE TABLE teachers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  email TEXT
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT,
  teacher_id INTEGER,
  FOREIGN KEY (teacher_id) REFERENCES teachers(id) ON DELETE SET NULL
);

CREATE TABLE groups (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT
);

CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  first_name TEXT,
  last_name TEXT,
  email TEXT,
  subject_id INTEGER,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE CASCADE
);

CREATE TABLE group_student (
  group_id INTEGER,
  student_id INTEGER,
  PRIMARY KEY (group_id, student_id),
  FOREIGN KEY (group_id) REFERENCES groups(id) ON DELETE CASCADE,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE
);

CREATE TABLE grades (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  student_id INTEGER,
  subject_id INTEGER,
  teacher_id INTEGER,
  grade INTEGER,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE CASCADE,
  FOREIGN KEY (teacher_id) REFERENCES teachers(id) ON DELETE SET NULL
);
```

### Фейковые данные

**1. Учителя (`teachers`)**

```sql
INSERT INTO teachers (name, email) VALUES
('Иван Петров', 'ivan.petrov@school.ru'),
('Мария Сидорова', 'maria.sidorova@school.ru'),
('Андрей Кузнецов', 'andrey.kuznetsov@school.ru'),
('Ольга Иванова', 'olga.ivanova@school.ru'),
('Сергей Смирнов', 'sergey.smirnov@school.ru'),
('Екатерина Орлова', 'ekaterina.orlova@school.ru'),
('Павел Волков', 'pavel.volkov@school.ru'),
('Анна Громова', 'anna.gromova@school.ru'),
('Дмитрий Никитин', 'dmitry.nikitin@school.ru'),
('Наталья Романова', 'natalia.romanova@school.ru');
```

---

**2. Предметы (`subjects`)**

```sql
INSERT INTO subjects (name, teacher_id) VALUES
('Математика', 1),
('Информатика', 2),
('Физика', 3),
('История', 4),
('Литература', 5),
('Английский язык', 6),
('Биология', 7);
```

---

**3. Группы (`groups`)**

```sql
INSERT INTO groups (name) VALUES
('Поток А'),
('Поток B'),
('Поток C'),
('Поток D');
```

---

**4. Студенты (`students`)**

```sql
INSERT INTO students (first_name, last_name, email, subject_id) VALUES
('Алексей', 'Миронов', 'alexey.mironov@mail.ru', 1),
('Елена', 'Иванова', 'elena.ivanova@mail.ru', 1),
('Игорь', 'Поляков', 'igor.polyakov@mail.ru', 2),
('Наталья', 'Соколова', 'natalia.sokolova@mail.ru', 2),
('Кирилл', 'Волков', 'kirill.volkov@mail.ru', 2),
('Мария', 'Кузнецова', 'maria.kuznetsova@mail.ru', 3),
('Олег', 'Смирнов', 'oleg.smirnov@mail.ru', 3),
('Евгения', 'Орлова', 'evgenia.orlova@mail.ru', 3),
('Сергей', 'Громов', 'sergey.gromov@mail.ru', 4),
('Дмитрий', 'Иванов', 'dmitry.ivanov@mail.ru', 4),
('Анна', 'Романова', 'anna.romanova@mail.ru', 5),
('Павел', 'Никитин', 'pavel.nikitin@mail.ru', 5),
('Виктория', 'Петрова', 'victoria.petrova@mail.ru', 6),
('Артем', 'Сидоров', 'artem.sidorov@mail.ru', 6),
('Людмила', 'Гусева', 'lyudmila.guseva@mail.ru', 6),
('Илья', 'Сорокин', 'ilya.sorokin@mail.ru', 7),
('Дарья', 'Федорова', 'daria.fedorova@mail.ru', 7),
('Владимир', 'Крылов', 'vladimir.krylov@mail.ru', 1),
('Ольга', 'Семенова', 'olga.semenova@mail.ru', 2),
('Галина', 'Лебедева', 'galina.lebedeva@mail.ru', 4);
```

---

**5. Промежуточная таблица `group_student`**

```sql
-- Поток А
INSERT INTO group_student (group_id, student_id) VALUES
(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6);

-- Поток B
INSERT INTO group_student (group_id, student_id) VALUES
(2, 7), (2, 8), (2, 9), (2, 10), (2, 11);

-- Поток C
INSERT INTO group_student (group_id, student_id) VALUES
(3, 12), (3, 13), (3, 14), (3, 15), (3, 16), (3, 17), (3, 18), (3, 19), (3, 20);

-- Поток D — пока пуст
```

---

**6. Оценки (`grades`)**

```sql
INSERT INTO grades (student_id, subject_id, teacher_id, grade) VALUES
(1, 1, 1, 10), (1, 2, 2, 8), (1, 3, 3, 11), (1, 4, 4, 9), (1, 6, 6, 12),
(2, 1, 1, 9), (2, 2, 2, 10), (2, 5, 5, 7), (2, 6, 6, 10), (2, 7, 7, 8),
(3, 2, 2, 11), (3, 3, 3, 9), (3, 4, 4, 10), (3, 5, 5, 8), (3, 6, 6, 11),
(4, 1, 1, 8), (4, 2, 2, 12), (4, 3, 3, 9), (4, 4, 4, 7), (4, 7, 7, 10),
(5, 1, 1, 6), (5, 2, 2, 7), (5, 3, 3, 8), (5, 5, 5, 9), (5, 6, 6, 10),
(6, 3, 3, 12), (6, 4, 4, 10), (6, 5, 5, 11), (6, 6, 6, 9), (6, 7, 7, 10),
(7, 1, 1, 8), (7, 2, 2, 9), (7, 3, 3, 11), (7, 4, 4, 10), (7, 5, 5, 7),
(8, 1, 1, 10), (8, 3, 3, 11), (8, 5, 5, 8), (8, 6, 6, 9), (8, 7, 7, 12),
(9, 2, 2, 8), (9, 3, 3, 10), (9, 4, 4, 11), (9, 5, 5, 7), (9, 6, 6, 10),
(10, 1, 1, 7), (10, 2, 2, 9), (10, 3, 3, 11), (10, 5, 5, 10), (10, 6, 6, 8),
(11, 4, 4, 12), (11, 5, 5, 9), (11, 6, 6, 10), (11, 7, 7, 11), (11, 1, 1, 8),
(12, 2, 2, 9), (12, 3, 3, 8), (12, 4, 4, 10), (12, 5, 5, 11), (12, 7, 7, 7),
(13, 6, 6, 12), (13, 2, 2, 9), (13, 3, 3, 10), (13, 4, 4, 8), (13, 7, 7, 9),
(14, 1, 1, 11), (14, 2, 2, 10), (14, 3, 3, 9), (14, 4, 4, 12), (14, 5, 5, 10),
(15, 1, 1, 9), (15, 2, 2, 8), (15, 3, 3, 10), (15, 5, 5, 9), (15, 7, 7, 11),
(16, 6, 6, 11), (16, 2, 2, 9), (16, 3, 3, 10), (16, 5, 5, 8), (16, 7, 7, 12),
(17, 4, 4, 10), (17, 3, 3, 9), (17, 6, 6, 12), (17, 7, 7, 8), (17, 5, 5, 11),
(18, 1, 1, 12), (18, 2, 2, 9), (18, 3, 3, 8), (18, 5, 5, 10), (18, 7, 7, 11),
(19, 4, 4, 9), (19, 2, 2, 10), (19, 6, 6, 11), (19, 7, 7, 8), (19, 1, 1, 12),
(20, 3, 3, 11), (20, 4, 4, 10), (20, 5, 5, 9), (20, 6, 6, 12), (20, 7, 7, 8);
```

---

### Задачи (усложнённые JOIN):

#### Задача 1.

**Показать имя студента, предмет и оценку.**

#### Задача 2.

**Показать среднюю оценку каждого студента.**

#### Задача 3.

**Показать среднюю оценку по каждому предмету.**

#### Задача 4.

**Показать всех студентов и их группы, даже если у студента нет оценок.**

#### Задача 5.

**Показать преподавателей и среднюю оценку по их предметам.**

#### Задача 6. \* (Подзапрос)

**Показать студентов с максимальной оценкой по каждому предмету.**

#### Задача 7.

**Показать среднюю оценку каждого потока.**

### Решение:

#### Задача 1.

**Показать имя студента, предмет и оценку.**

> `INNER JOIN` с таблицами `students`, `subjects`, `grades`

```sql
SELECT s.first_name, s.last_name, sub.name AS subject, g.grade
FROM grades AS g
INNER JOIN students AS s ON g.student_id = s.id
INNER JOIN subjects AS sub ON g.subject_id = sub.id;
```

---

#### Задача 2.

**Показать среднюю оценку каждого студента.**

> `INNER JOIN` + `GROUP BY` + `AVG()`

```sql
SELECT s.first_name, s.last_name, ROUND(AVG(g.grade), 2) AS avg_grade
FROM students AS s
INNER JOIN grades AS g ON s.id = g.student_id
GROUP BY s.id;
```

---

#### Задача 3.

**Показать среднюю оценку по каждому предмету.**

> `INNER JOIN` + `GROUP BY`

```sql
SELECT sub.name AS subject, ROUND(AVG(g.grade), 2) AS avg_grade
FROM subjects AS sub
INNER JOIN grades AS g ON sub.id = g.subject_id
GROUP BY sub.name;
```

---

#### Задача 4.

**Показать всех студентов и их группы, даже если у студента нет оценок.**

> `LEFT JOIN` между `students`, `group_student`, `groups` и `grades`

```sql
SELECT s.first_name, s.last_name, g2.name AS group_name, COUNT(g1.id) AS total_grades
FROM students AS s
LEFT JOIN group_student AS gs ON s.id = gs.student_id
LEFT JOIN groups AS g2 ON gs.group_id = g2.id
LEFT JOIN grades AS g1 ON s.id = g1.student_id
GROUP BY s.id;
```

---

#### Задача 5.

**Показать преподавателей и среднюю оценку по их предметам.**

> `INNER JOIN` + `GROUP BY`

```sql
SELECT t.name AS teacher, ROUND(AVG(g.grade), 2) AS avg_grade
FROM teachers AS t
INNER JOIN subjects AS sub ON t.id = sub.teacher_id
INNER JOIN grades AS g ON sub.id = g.subject_id
GROUP BY t.name;
```

---

#### Задача 6.

**Показать студентов с максимальной оценкой по каждому предмету.**

> `INNER JOIN` + подзапрос (допускается, как часть JOIN)

```sql
SELECT s.first_name, s.last_name, sub.name AS subject, g.grade
FROM grades AS g
INNER JOIN students AS s ON g.student_id = s.id
INNER JOIN subjects AS sub ON g.subject_id = sub.id
WHERE g.grade = (
  SELECT MAX(g2.grade)
  FROM grades AS g2
  WHERE g2.subject_id = g.subject_id
);
```

---

#### Задача 7.

**Показать среднюю оценку каждого потока.**

> Использует `INNER JOIN` между `groups`, `group_student`, `students`, `grades` + `AVG()`

```sql
SELECT gr.name AS group_name, ROUND(AVG(g.grade), 2) AS avg_grade
FROM groups AS gr
INNER JOIN group_student AS gs ON gr.id = gs.group_id
INNER JOIN students AS s ON gs.student_id = s.id
INNER JOIN grades AS g ON s.id = g.student_id
GROUP BY gr.name;
```

---

# 8. Вопросы

1. **Зачем в базе данных хранить связанные таблицы, а не одну «большую» таблицу со всеми данными сразу?**

2. **Что такое первичный ключ (PRIMARY KEY) и какие у него свойства?**
   _(подсказка: уникальность, не NULL, используется для идентификации строки)_

3. **Что такое внешний ключ (FOREIGN KEY) и зачем он нужен?**

4. **Какую проблему решает внешний ключ, если у нас есть таблицы `students` и `grades`?**

5. **Какие бывают виды связей между таблицами? Приведите короткий пример для каждой.**

6. **Почему в реляционных базах данных не рекомендуется дублировать одни и те же данные в разных местах?**
   _(подсказка: нормализация, изменение в одном месте должно автоматически отражаться во всех зависимостях)_

7. **Что произойдёт, если удалить строку в таблице `students`, у которой есть связанные оценки в таблице `grades`, но связь настроена без `ON DELETE CASCADE`?**

8. **В чём разница между INNER JOIN и LEFT JOIN? Когда лучше использовать LEFT JOIN?**

9. **Почему таблица «связка» (join table) нужна при связи «многие ко многим»?**
   _(например, `students_subjects` для учёта, кто какие предметы изучает)_

10. **Представьте: у вас есть таблица `teachers`, `subjects` и `grades`. Как одним запросом найти средний балл по каждому предмету и преподавателю? Какой оператор SQL здесь поможет?**
    _(подсказка: GROUP BY + агрегатная функция)_

---

# 9. Домашняя работа

**Задание 1.**
Выведите список всех студентов, которые зарегистрированы в базе.
Покажите только их `id` и `имя`. Это поможет убедиться, что таблица `students` работает правильно и в ней действительно есть данные.

---

**Задание 2.**
Получите список всех уникальных предметов, которые присутствуют в базе.
Используйте оператор `DISTINCT`, чтобы предметы не повторялись, даже если на них учится несколько студентов.

---

**Задание 3.**
Найдите всех студентов, у которых длина имени больше **5 символов**.
Подсказка: используйте функцию `LENGTH(name)`. Это может пригодиться, если, например, нужно отобрать длинные имена для отчёта.

---

**Задание 4.**
Выведите все оценки студентов, которые находятся в диапазоне **от 3 до 5 включительно**.
Используйте оператор `BETWEEN`. Это удобный способ отобрать оценки «выше среднего».

---

**Задание 5.**
Найдите всех студентов, чьё имя начинается на букву **"A"**.
Используйте `LIKE 'A%'`. Такой поиск часто применяют, когда нужно отобрать данные по маске (например, фамилии на определённую букву).

---

**Задание 6.**
Выведите список всех предметов, у которых **нет преподавателя**.
Подсказка: для этого нужно проверить, что в таблице `teachers` не существует записи с таким `subject_id`. Это проверяется через `IS NULL` или через подзапрос `NOT IN`.

---

**Задание 7.**
Найдите **3 студентов**, у которых наибольшее количество оценок.
Подсказка: сначала сгруппируйте оценки по студенту (`GROUP BY`), потом отсортируйте результат по количеству (`ORDER BY`), и ограничьте вывод с помощью `LIMIT`.

---

**Задание 8.**
Посчитайте **средний балл по каждому предмету**.
Подсказка: используйте `GROUP BY subject_id` и агрегатную функцию `AVG(grade)`. Это позволит узнать, по каким предметам студенты учатся лучше, а где хуже.

---

**Задание 9.**
Найдите всех студентов, у которых **больше двух оценок**.
Подсказка: после группировки (`GROUP BY student_id`) используйте `HAVING COUNT(*) > 2`. Это отфильтрует только тех, кто сдавал предметы чаще.

---

**Задание 10.**
Проверьте, как работает ограничение **ON DELETE CASCADE**.

1. Удалите одного студента из таблицы `students`.
2. Проверьте, остались ли его оценки в таблице `grades`.
   Они должны удалиться автоматически. Если это произошло — значит связь `FOREIGN KEY ... ON DELETE CASCADE` работает корректно.

---

[Предыдущий урок](lesson07.md) | [Следующий урок](lesson09.md)
