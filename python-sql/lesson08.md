# Модуль 2. Урок 8. Связи таблиц и основы нормализации. Соединения таблиц (JOIN)

## **Цель урока:**

- узнать, **что такое** связи между таблицами
- разобраться **почему** нужны связи между таблицами
- познакомится глубже с понятиями **первичный** и **внешний ключ**
- научится **нормализовать данные**, разделяя их на связанные таблицы
- практиковать запросы из нескольких таблиц сразу с помощью **JOIN**

# 1. Введение: зачем нужны связи между таблицами?

Представьте простую ситуацию: у вас есть интернет-магазин, и вы храните в одной таблице всю информацию о **товарах**, их **поставщиках**, **категориях** и **складских операциях**. На первый взгляд — удобно: один запрос → всё на месте. Но на практике такая **«толстая»** (или «монолитная») таблица быстро оборачивается рядом серьёзных проблем.

## Проблема «толстой» таблицы (денормализованная структура)

1. **Дублирование данных.**
   Если про каждого поставщика вы храните имя, адрес и контакты прямо в строках товаров, то данные о поставщике повторяются для каждого товара. При тысяче товаров одного поставщика — имя и контакт повторятся тысячу раз.

2. **Аномалии обновления (update anomaly).**
   Когда нужно поменять одно поле поставщика (например, телефон), придётся обновить множество строк. Если какую-то строку забыли — данные станут **неконсистентными** (телефон будет разным в разных местах).

3. **Аномалии вставки (insert anomaly).**
   Невозможно добавить поставщика, пока нет товара, если схема построена так, что поставщик — просто текстовое поле товаров и нет отдельной таблицы поставщиков с уникальными записями (иногда это мешает логике приложения).

4. **Аномалии удаления (delete anomaly).**
   Если удалить последний товар поставщика, то вместе с ним «исчезнут» и данные о поставщике (если они только в таблице товаров). То есть потеряется информация, которую желательно хранить независимо.

5. **Избыточное потребление места и ухудшение производительности.**
   Повторяющиеся строки увеличивают объём хранения и приводят к лишним операциям при поиске/сортировке.

6. **Трудности поддержания целостности данных.**
   Без единого места для поставщика трудно гарантировать уникальность, валидацию, историю изменений и т. п.

## Решение: разделение информации и связывание таблиц

Чтобы устранить все описанные проблемы, данные логически делят на отдельные сущности (таблицы). Например:

- `suppliers` — данные о поставщиках (id, name, phone, address…),
- `products` — данные о товарах (id, title, price, supplier_id…),
- `categories` — категории товаров (id, name…),
- `stock` или `inventory` — операции прихода/расхода.

После этого таблицы **связывают между собой** — обычно связывают строку в таблице A с соответствующей записью в таблице B через специальное поле (идентификатор).

Это позволяет:

- хранить уникальную запись о поставщике только в `suppliers` (без дублирования),
- в `products` ссылаться на поставщика через `supplier_id`,
- без проблем обновлять информацию о поставщике в одном месте,
- выполнять проверки ссылочной целостности (нет «висящих» ссылок на несуществующих поставщиков),
- легче добавлять метаданные (например историю изменений, адреса, контакты) и расширять модель.

---

# 2. Первичный и внешний ключ

Для связи таблиц используются две фундаментальные концепции: **первичный ключ (PRIMARY KEY)** и **внешний ключ (FOREIGN KEY)**. Разберём подробно — что это такое, как обычно называют поля, как задаются ограничения и что происходит с зависимыми данными при обновлении или удалении.

## Первичный ключ (PRIMARY KEY)

**Определение:** первичный ключ — это **столбец (или набор столбцов), однозначно идентифицирующий строку в таблице**.

**Свойства PK:**

- **уникальность**: значения не повторяются;
- **ненулевое значение** (NOT NULL);
- **обеспечивает быстрый поиск** (обычно по PK создаётся индекс);
- служит **точкой ссылки для других таблиц** (в них будут внешние ключи на этот PK).

**Варианты ключей:**

- **Суррогатный ключ** — искусственный идентификатор, чаще всего `id INTEGER PRIMARY KEY AUTOINCREMENT`. Удобен, прост и не зависит от реальных данных.
- **Натуральный ключ** — реальное поле(я), которые уже уникальны по смыслу (например, `email` для пользователей или `isbn` для книг). Использовать натуральные ключи можно, но есть риск, что «естественные» значения изменятся со временем (и это сложнее поддерживать).

**Примеры [DDL](lesson01.md#4-что-такое-sql-и-как-он-устроен):**

```sql
-- суррогатный ключ
CREATE TABLE suppliers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  phone TEXT
);

-- составной (композитный) первичный ключ
CREATE TABLE course_schedule (
  course_id INTEGER,
  weekday INTEGER,
  PRIMARY KEY (course_id, weekday)
);
```

**Практическая рекомендация:** чаще всего используют `id` как `PRIMARY KEY` (единообразие упрощает JOIN’ы и код).

## Внешний ключ (FOREIGN KEY)

**Определение:** внешний ключ — это **столбец (или набор столбцов) в одной таблице, значение которого ссылается на первичный (или уникальный) ключ другой таблицы**. Он реализует связь «сущность A ссылается на сущность B».

**Типичный пример:** в таблице `products` есть колонка `supplier_id`, которая хранит `id` из таблицы `suppliers`. Тогда `supplier_id` — внешний ключ, ссылающийся на `suppliers(id)`.

**Как обычно называют поля:**

- `id` — PK в таблице (например, `suppliers.id`),
- `<entity>_id` — FK в зависимой таблице (например, `supplier_id` в `products`). Такое именование (`snake_case`) стандартно и удобно.

**Пример DDL с FK (SQLite / SQL):**

```sql
CREATE TABLE suppliers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL
);

CREATE TABLE products (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT,
  supplier_id INTEGER,
  price REAL,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);
```

### Ограничения и действия (ON DELETE / ON UPDATE)

FK обычно сопровождается правилом, что делать при удалении или обновлении строки, на которую ссылаются:

- `ON DELETE CASCADE` — при удалении родителя (например, поставщика) автоматически удаляются все дочерние строки (товары). Удобно, но опасно: можно потерять много данных по одной операции.
- `ON DELETE SET NULL` — при удалении родителя значение FK в дочерних строках устанавливается в `NULL` (если FK допускает NULL). Позволяет сохранить записи, но «отсоединёнными».
- `ON DELETE RESTRICT` / `NO ACTION` — запретить удаление родителя, если существуют ссылки на него; классический способ защитить целостность.
- Аналогично `ON UPDATE CASCADE` — если поменялся ключ в родительской таблице (редко для автогенерируемых ID), то обновления применяются и в дочерних строках.

**Примеры:**

```sql
-- Удаление поставщика удалит все его товары
CREATE TABLE products (
  id INTEGER PRIMARY KEY,
  title TEXT,
  supplier_id INTEGER,
  FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

**Важно (для SQLite):** по умолчанию в SQLite проверка внешних ключей выключена. Нужно включать явной командой:

```sql
PRAGMA foreign_keys = ON;
```

Или включать в соединении из приложения. Иначе `FOREIGN KEY` будет только декларацией, но не `enforced`.

## Что происходит со связанными данными (на практике)?

1. **При вставке:** если у дочерней записи указан `supplier_id`, которого нет в `suppliers`, СУБД с включённой проверкой FK не позволит вставить такую строку (ошибка referential integrity). Это предотвращает «висящие» ссылки.

2. **При обновлении родителя:**

   - Если `ON UPDATE CASCADE` — значения в дочерних строках обновятся автоматически.
   - Если нет — обновление родительского PK запрещено, либо дочерние строки остаются неконсистентными (в большинстве реализаций операция запрещена).

3. **При удалении родителя:** зависит от `ON DELETE`:

   - `CASCADE` — дочерние строки удаляются автоматически.
   - `SET NULL` — дочерние FK становятся `NULL`.
   - `RESTRICT/NO ACTION` — удаление запрещено при существующих ссылках.

4. **Проблемы и стратегии:**

   - **Опасность каскада:** `ON DELETE CASCADE` может «слить» большое дерево данных — используйте с осторожностью и только когда действительно нужно удалить всё вместе.
   - **Софт-удаление (soft delete):** вместо физического удаления ставить флаг `deleted = TRUE`. Это сохраняет историю и избегает потерь.
   - **Транзакции:** любые операции, затрагивающие несколько таблиц (например, удалить поставщика и логировать операцию), следует выполнять в транзакции, чтобы сохранить атомарность.

_Транзакция — это набор SQL-операций, которые выполняются как единое целое._

## Какой `ON DELETE` чаще применяется на практике?

- **`ON DELETE RESTRICT`** или **`NO ACTION`** — чаще всего.
  Это защита: нельзя удалить родителя, пока на него ссылаются данные. Так сохраняется целостность.
- **`ON DELETE CASCADE`** используют реже, но удобно в ситуациях, где дочерние записи **не имеют смысла без родителя**. Например: если удалить заказ — должны исчезнуть и все его позиции (`order_items`).
- **`ON DELETE SET NULL`** — применяют, если допустимо, чтобы у строки временно не было связи (например, товар «осиротел» без поставщика).

**Практическое правило:**

- Для большинства справочников (категории, пользователи, предметы) — `RESTRICT`.
- Для зависимых данных (детали заказа, оценки студентов) — `CASCADE`.

---

## Составные (композитные) внешние ключи

Иногда таблица ссылается не на один столбец, а на комбинацию. Например, если первичный ключ — составной (`(order_id, product_id)`), то и внешний ключ должен ссылаться на оба поля одновременно.

```sql
CREATE TABLE order_items (
  order_id INTEGER,
  product_id INTEGER,
  qty INTEGER,
  PRIMARY KEY (order_id, product_id),
  FOREIGN KEY (product_id) REFERENCES products(id)
);
```

(Если parent PK композитный, то `FOREIGN KEY` должен перечислить все соответствующие столбцы.)

## Как правильно заполнять композитные внешние ключи?

Композитный (составной) внешний ключ ссылается сразу на **несколько столбцов**.
Пример: таблица «оценки» ссылается на `(student_id, subject_id)`.

```sql
CREATE TABLE grades (
    student_id INTEGER,
    subject_id INTEGER,
    grade INTEGER,
    FOREIGN KEY (student_id, subject_id) REFERENCES student_subjects(student_id, subject_id)
);
```

**Как заполнять:**

- в строке должны быть значения **обоих ключей**, которые уже есть в родительской таблице.
- если в родительской таблице нет пары `(student_id, subject_id)`, то вставка не пройдёт.

**Пример результата:**

```
student_subjects:
+------------+------------+
| student_id | subject_id |
+------------+------------+
| 1          | 10         |
| 2          | 20         |

grades:
+------------+------------+-------+
| student_id | subject_id | grade |
+------------+------------+-------+
| 1          | 10         |   5   |  ✅ допустимо
| 2          | 20         |   4   |  ✅ допустимо
| 1          | 20         |   3   |  ❌ ошибка (такой пары нет в student_subjects)
```

---

## Индексация внешних ключей

### Что такое индексы и индексация? (коротко)

**Индекс** в БД — это структура данных (обычно дерево), которая ускоряет поиск строк по определённому столбцу (или нескольким).
Он работает как «оглавление» или «алфавитный указатель в книге».

- Без индекса БД просматривает всю таблицу (full scan).
- С индексом поиск быстрее, но индексы занимают место и замедляют вставку/обновление (нужно поддерживать структуру).

### **Примеры, когда индекс нужен:**

- на `PRIMARY KEY` и `UNIQUE` поля индекс создаётся автоматически,
- на `FOREIGN KEY` обычно добавляют вручную,
- на часто используемые в фильтрах/сортировках поля (`WHERE`, `JOIN`, `ORDER BY`).

Пример создания индекса:

```sql
CREATE INDEX idx_products_supplier ON products(supplier_id);
```

---

#### Практика показывает:

**Индексировать FK полезно**. Когда вы делаете JOIN или удаляете/обновляете родителя, СУБД быстро находит дочерние строки по FK, если по этому полю есть индекс. В SQLite при PK обычно индекс уже есть, но для FK в дочерних таблицах индекс следует создать вручную при больших объёмах данных.

## Имена и соглашения (рекомендации)

- Таблицы именовать во множественном числе (`products`, `suppliers`) или единственном — главное соблюдать единообразие.
- Поля PK: `id` (типично).
- Внешние ключи: `<entity>_id` → `supplier_id`, `student_id`, `subject_id`.
- Для FK-ограничений давать явные имена (в СУБД, где это возможно) — упрощает отладку:

  ```sql
  CONSTRAINT fk_products_supplier FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
  ```

## Краткие практические примеры (объединяем концепции)

**Пример: студенты и оценки**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT NOT NULL
);

CREATE TABLE grades (
  id INTEGER PRIMARY KEY,
  student_id INTEGER NOT NULL,
  subject_id INTEGER NOT NULL,
  grade INTEGER,
  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
  FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE RESTRICT
);
```

- `student_id` и `subject_id` — FK.
- При удалении студента его оценки удаляются автоматически (`CASCADE`).
- При попытке удалить предмет, если есть оценки, `ON DELETE RESTRICT` запретит удаление.

**Пример JOIN (наглядно, без визуала):**

```sql
SELECT s.name, sub.title, g.grade
FROM grades g
JOIN students s ON s.id = g.student_id
JOIN subjects sub ON sub.id = g.subject_id;
```

В результате вы получите табличный вывод, где каждая строка — студент + предмет + оценка. Так вы «соединяете» области данных, хранящиеся в разных таблицах.

---

# 3. Виды связей между таблицами

В реляционной модели данные хранятся в таблицах — но реальный мир устроен так, что одна сущность связана с другой. Существует три фундаментальных типа связей:

## 1) Один-к-одному (1:1)

**Описание:** каждой строке в таблице A соответствует не более одной строки в таблице B, и наоборот.
**Примеры:** человек ↔ паспорт (в реальности один человек может иметь один паспорт), пользователь ↔ профиль настроек.

**Как моделируют в БД:**

- Обычно одна из таблиц получает внешний ключ на другую с уникальным ограничением, либо обе таблицы используют один и тот же PK (shared PK).
- Часто `table_a.id` — PK; `table_b.a_id` — FK с `UNIQUE` (или `PRIMARY KEY`) — это гарантирует 1:1.

**DDL (вариант с UNIQUE FK):**

```sql
CREATE TABLE person (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE passport (
  id INTEGER PRIMARY KEY,
  person_id INTEGER UNIQUE,   -- уникальная связь
  passport_number TEXT,
  FOREIGN KEY (person_id) REFERENCES person(id)
);
```

**Пояснение:** `person_id` помечен `UNIQUE`, поэтому на одного `person.id` не может ссылаться более одной строки `passport`. При необходимости можно поставить `person_id` как `PRIMARY KEY` в `passport`.

## 2) Один-ко-многим (1\:M)

**Описание:** одной строке в таблице A соответствует много строк в таблице B. Это самый частый тип связей.
**Примеры:** категорию ↔ продукты (одна категория — много продуктов), преподаватель ↔ предметы, студент ↔ оценки.

**Моделирование:** у «многих» в таблице B есть поле-ссылка `a_id` (FK), указывающее на `A.id`.

**DDL:**

```sql
CREATE TABLE category (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE product (
  id INTEGER PRIMARY KEY,
  title TEXT,
  category_id INTEGER,
  FOREIGN KEY (category_id) REFERENCES category(id)
);
```

**Пояснение:** каждый `product` содержит `category_id`. Один `category` может иметь множество `product`.

## 3) Многие-ко-многим (M\:N)

**Описание:** строки таблицы A связаны с множеством строк таблицы B и наоборот.
**Примеры:** студенты ↔ предметы (студент учит много предметов, предмет изучают многие студенты), товары ↔ теги.

**Моделирование:** создаётся промежуточная (junction) таблица, которая хранит пары ссылок — это и есть связь M\:N. Часто эту таблицу называют `student_subject`, `product_tag` и т.п.

**DDL:**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY,
  name TEXT
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY,
  title TEXT
);

CREATE TABLE student_subjects (   -- junction table
  student_id INTEGER,
  subject_id INTEGER,
  PRIMARY KEY (student_id, subject_id),  -- составный PK
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (subject_id) REFERENCES subjects(id)
);
```

**Пояснение:**

- `student_subjects` хранит пары `(student_id, subject_id)`.
- Для одного студента может быть несколько строк с разными `subject_id` (и наоборот).
- Составной PK `PRIMARY KEY (student_id, subject_id)` гарантирует, что одна и та же пара не повторится.

---

# 4. Основы нормализации — почему и как «разворачивать» данные

Нормализация — это набор правил и приёмов, цель которых — уменьшить избыточность и аномалии данных, повысить однозначность и удобство поддержания. Давайте разберёмся на конкретном примере: начнём с **одной «толстой» таблицы** и шаг за шагом нормализуем её до 3НФ.

## Изначальная (денормализованная) таблица — «всё в одном»

Предположим, у вас система учёта оценок и вы изначально храните всё в одной таблице `records`:

```sql
CREATE TABLE records (
  id INTEGER PRIMARY KEY,
  student_name TEXT,
  student_email TEXT,
  subject_title TEXT,
  teacher_name TEXT,
  teacher_email TEXT,
  semester TEXT,
  grade INTEGER,
  created_at TEXT
);
```

**Примеры строк:**

| id  | student_name  | student_email                         | subject_title | teacher_name | teacher_email                             | semester | grade | created_at |
| --- | ------------- | ------------------------------------- | ------------- | ------------ | ----------------------------------------- | -------- | ----- | ---------- |
| 1   | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Математика    | Петров       | [petrov@mail.com](mailto:petrov@mail.com) | 2023S1   | 5     | 2023-06-01 |
| 2   | Иван Иванов   | [ivan@mail.com](mailto:ivan@mail.com) | Физика        | Сидоров      | [sidor@mail.com](mailto:sidor@mail.com)   | 2023S1   | 4     | 2023-06-02 |
| 3   | Ольга Петрова | [olga@mail.com](mailto:olga@mail.com) | Математика    | Петров       | [petrov@mail.com](mailto:petrov@mail.com) | 2023S1   | 5     | 2023-06-01 |

**Проблемы такой таблицы:**

- **Дублирование данных:** `student_name` / `student_email` повторяются для каждой оценки студента; `teacher_*` повторяются для каждого предмета; `subject_title` тоже многократно повторяется.
- **Аномалии обновления:** если у `Петров` меняется email, нужно обновить множество строк.
- **Нарушение единичного источника правды:** нет центра, где хранится информация о студентах или предметах.
- **Сложности ссылочной целостности:** нельзя легко обеспечить FK и уникальность.

Теперь — нормализуем шаг за шагом.

---

## 1НФ (первая нормальная форма) — атомарность значений

**Правило 1НФ:** все значения в колонках — атомарны (не списки/массивы), таблица имеет четкую структуру строк и столбцов.

**Частые нарушения 1НФ:** в одной колонке хранится «список предметов через запятую» или «массив телефонов». Такое нужно разобрать — сохранить каждое значение в отдельной строке.

В нашем примере `records` уже в общем виде в 1НФ (каждое поле — атомарное). Но если бы была колонка `subjects` со значением `'Математика, Физика'`, нужно было бы вынести в отдельные строки/таблицы.

---

## 2НФ (вторая нормальная форма) — убрать частичные зависимости

**Правило 2НФ:** таблица должна быть в 1НФ и **все неключевые атрибуты должны полностью зависеть от всего первичного ключа**, а не от его части. Смысл: убрать частичные зависимости, которые возможны, если PK составной.

В нашем первоначальном `records` PK был `id` (суррогатный), поэтому формально 2НФ не нарушается из-за частичных зависимостей, но логически мы видим, что `student_*` и `teacher_*` не зависят от оценки: они зависят только от студента/преподавателя. Поэтому естественный шаг — выделить студентов, предметы и преподавателей в отдельные таблицы.

**Нормализация в 2 шага (выделяем сущности):**

1. Создаём таблицы `students`, `teachers`, `subjects`, `grades` (где `grades` хранит только связь и оценку).

**DDL после разделения:**

```sql
CREATE TABLE students (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT UNIQUE
);

CREATE TABLE teachers (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  email TEXT UNIQUE
);

CREATE TABLE subjects (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  teacher_id INTEGER,
  FOREIGN KEY (teacher_id) REFERENCES teachers(id)
);

CREATE TABLE grades (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  student_id INTEGER NOT NULL,
  subject_id INTEGER NOT NULL,
  semester TEXT,
  grade INTEGER,
  created_at TEXT,
  FOREIGN KEY (student_id) REFERENCES students(id),
  FOREIGN KEY (subject_id) REFERENCES subjects(id)
);
```

**Что поменялось (логика):**

- `students` содержит данные про студента один раз.
- `teachers` содержит данные про преподавателя один раз.
- `subjects` ссылается на `teacher` (если предмет ведёт конкретный преподаватель).
- `grades` хранит только «связь» студент→предмет и саму оценку.

Это устраняет большое количество дублирования.

---

## 3НФ (третья нормальная форма) — убрать транзитивные зависимости

**Правило 3НФ:** таблица в 2НФ и **никакой неключевой атрибут не должен зависеть транзитивно от ключа** (т.е. не должно быть A → B → C, где C зависит от B, а B — от ключа).

Применение в нашем примере: убедиться, что в таблице `grades` нет полей, которые зависят не от `student_id, subject_id` напрямую, а от связанных сущностей. Например, если в `grades` оставили `teacher_email`, то это транзитивная зависимость (`grade` → `subject_id` → `teacher_id` → `teacher_email`) — это нарушение 3НФ. Поэтому такие поля были вынесены в `teachers`.

**Итог:** структура из предыдущего шага удовлетворяет 3НФ, потому что:

- `grades` содержит только поля, непосредственно связанные со связью студент-предмет (оценка, семестр).
- сведения о преподавателях и студентах вынесены в отдельные таблицы.

---

## Пример переноса конкретных строк: «до» → «после»

**До (records):**

| id  | student_name | student_email                         | subject_title | teacher_name | grade |
| --- | ------------ | ------------------------------------- | ------------- | ------------ | ----- |
| 1   | Иван Иванов  | [ivan@mail.com](mailto:ivan@mail.com) | Математика    | Петров       | 5     |
| 2   | Иван Иванов  | [ivan@mail.com](mailto:ivan@mail.com) | Физика        | Сидоров      | 4     |
| 3   | Ольга        | [olga@mail.com](mailto:olga@mail.com) | Математика    | Петров       | 5     |

**После нормализации:**

`students`:

| id  | name        | email                                 |
| --- | ----------- | ------------------------------------- |
| 1   | Иван Иванов | [ivan@mail.com](mailto:ivan@mail.com) |
| 2   | Ольга       | [olga@mail.com](mailto:olga@mail.com) |

`teachers`:

| id  | name    | email        |
| --- | ------- | ------------ |
| 1   | Петров  | petrov\@mail |
| 2   | Сидоров | sidor\@mail  |

`subjects`:

| id  | title      | teacher_id |
| --- | ---------- | ---------- |
| 1   | Математика | 1          |
| 2   | Физика     | 2          |

`grades`:

| id  | student_id | subject_id | grade |
| --- | ---------- | ---------- | ----- |
| 1   | 1          | 1          | 5     |
| 2   | 1          | 2          | 4     |
| 3   | 2          | 1          | 5     |

Теперь:

- чтобы получить те же отчёты, мы делаем `JOIN` между `grades`, `students`, `subjects`, `teachers`.
- при изменении email преподавателя — меняем одну строку в `teachers`, не ходим по множеству записей.

---

## Немного про 3НФ — что такое «транзитивная зависимость» простыми словами

Если в таблице А есть столбец B, и столбец B определяет столбец C (т.е. B → C), то C транзитивно зависит от первичного ключа (PK → B → C). В 3НФ такого быть не должно — C нужно вынести в отдельную таблицу, где она принадлежит B.

Пример: в таблице `products` есть `category_id` и `category_name`. Здесь `category_name` транзитивно зависит от `category_id` — правильнее создать таблицу `categories(id, name)`.

---

## Когда нормализация — не лучшая идея? (кратко)

- **Производительность**: на очень больших объёмах частые `JOIN` могут быть дорогими; иногда ради скорости данные денормализуют (например, сохраняют `category_name` прямо в `products`) — это trade-off.
- **Аналитические хранилища (OLAP)**: часто используют денормализованные схемы (звёздные/снежинки) для быстрой агрегации.
- **Простота разработки**: для очень простых приложений иногда проще начинать с небольшой денормализованной структуры и нормализовать позже.

Но **в операционных системах (OLTP)** обычно стремятся к 3НФ или близким к ней формам, чтобы избегать аномалий и облегчить поддержку.

---

# 5. Практика. Шаги по созданию и отработке связей.

## Шаг 1. Проект связных таблиц:

1. **students**

   - Поля:

     - `id` — уникальный идентификатор студента (рекомендуется integer, PRIMARY KEY, автогенерация).
     - `name` — текстовое имя студента (NOT NULL).

2. **subjects**

   - Поля:

     - `id` — PK для предмета.
     - `title` — название предмета (NOT NULL).

3. **grades**

   - Поля:

     - `id` — PK записи (или можно использовать составной ключ (student_id, subject_id) — на ваше усмотрение).
     - `student_id` — ссылка на `students.id` (FOREIGN KEY).
     - `subject_id` — ссылка на `subjects.id` (FOREIGN KEY).
     - `grade` — числовая оценка (например INTEGER).

   - Связи:

     - `student_id` REFERENCES `students(id)`
     - `subject_id` REFERENCES `subjects(id)`

   - Дополнительно: решите стратегию удаления/обновления — `ON DELETE RESTRICT` или `ON DELETE CASCADE` (смотрите подсказки ниже).

4. **teachers**

   - Поля:

     - `id` — PK преподавателя.
     - `name` — имя (NOT NULL).
     - `subject_id` — ссылка на `subjects.id` (FOREIGN KEY) — означает, что преподаватель ведёт конкретный предмет (в этом простом варианте один преподаватель привязан к одному предмету).

---

## Шаг 2. Заполнить таблицы данными:

**students** (пример 6 студентов)

```
1, "Иван Иванов"
2, "Мария Петрова"
3, "Алексей Смирнов"
4, "Ольга Кузнецова"
5, "Дмитрий Орлов"
6, "Светлана Никифорова"
```

**subjects** (пример 4 предмета)

```
1, "Математика"
2, "Физика"
3, "История"
4, "Информатика"
```

**teachers** (пример; связываем с subject_id)

```
1, "Петров", 1      -- преподаватель Петров ведёт Математику (subject_id = 1)
2, "Сидоров", 2     -- Сидоров — Физика
3, "Иванова", 4     -- Иванова — Информатика
```

(оставьте поле subject_id NULL для преподавателя, если хотите показать «не назначен»)

**grades** (пример оценок)

```
1, 1, 1, 5   -- id, student_id(1=Иван), subject_id(1=Математика), grade=5
2, 1, 4, 4   -- Иван по Информатике — 4
3, 2, 1, 3   -- Мария по Математике — 3
4, 3, 2, 4   -- Алексей по Физике — 4
5, 4, 3, 5   -- Ольга по Истории —5
6, 5, 1, 4   -- Дмитрий по Математике —4
7, 6, 4, 5   -- Светлана по Информатике —5
```

## Шаг 3. Составить сырые запросы согласно заданиям

### Задание 1 — Базовый SELECT + ORDER BY + LIMIT

**Задача.** Вывести список студентов (id, name), отсортированный по имени в алфавитном порядке, первые 20 записей.

### Задание 2 — DISTINCT

**Задача.** Вывести уникальные названия предметов (без дублирующихся `title`).

### Задание 3 — LENGTH и сортировка по длине

**Задача.** Показать предметы с длиной их названия (title) и отсортировать по длине названия по убыванию.

### Задание 4 — WHERE + BETWEEN

**Задача.** Вывести все записи из `grades`, где оценка (grade) между 4 и 5 включительно, отсортированные по убыванию оценки.

### Задание 5 — LIKE (поиск по шаблону)

**Задача.** Найти всех студентов, у которых в имени встречается фрагмент `Иван` (например «Иван», «Иванов», «Иванова»).

### Задание 6 — IS NULL / IS NOT NULL

**Задача A.** Показать всех преподавателей, у которых **нет** назначенного предмета (`subject_id IS NULL`).
**Задача B.** Показать всех преподавателей, у которых есть назначенный предмет (`subject_id IS NOT NULL`).

### Задание 7 — ORDER BY + LIMIT + OFFSET (пагинация)

**Задача.** Реализовать «вторую страницу» списка студентов: вывести 10 студентов, отсортированных по имени, начиная с 11-й записи (т.е. OFFSET 10).

### Задание 8 — GROUP BY + COUNT (с DISTINCT)

**Задача.** Для каждого студента посчитать, по скольким **разным предметам** у него есть оценки (т.е. кол-во уникальных `subject_id`). Отсортировать по убыванию этого числа.

### Задание 9 — GROUP BY + AVG + HAVING

**Задача.** Найти предметы (`subject_id`), где средний балл (по всем записям в `grades`) **не ниже 4.5**.

## Шаг 4. Проверка практических заданий

## Задание 1 — Базовый SELECT + ORDER BY + LIMIT

**Задача.** Вывести список студентов (id, name), отсортированный по имени в алфавитном порядке, первые 20 записей.

**SQL**

```sql
SELECT id, name
FROM students
ORDER BY name ASC
LIMIT 20;
```

**Пояснение.**
`SELECT` выбирает нужные колонки. `ORDER BY name ASC` сортирует по имени по возрастанию (A→Z). `LIMIT 20` ограничивает объём вывода — удобно для больших таблиц и первой страницы отображения. Такой запрос — базовый шаблон для отображения списка с пагинацией (добавив OFFSET — получим следующую страницу).

---

## Задание 2 — DISTINCT

**Задача.** Вывести уникальные названия предметов (без дублирующихся `title`).

**SQL**

```sql
SELECT DISTINCT title
FROM subjects
ORDER BY title;
```

**Пояснение.**
`DISTINCT` убирает дублирующиеся строки по колонке `title`. Полезно, если в таблице `subjects` по ошибке есть одинаковые названия или если вы хотите получить справочник уникальных наименований. `ORDER BY` делает вывод упорядоченным для удобочитаемости.

---

## Задание 3 — LENGTH и сортировка по длине

**Задача.** Показать предметы с длиной их названия (title) и отсортировать по длине названия по убыванию.

**SQL**

```sql
SELECT title, LENGTH(title) AS len
FROM subjects
ORDER BY len DESC, title;
```

**Пояснение.**
`LENGTH(title)` возвращает число символов в названии (в SQLite — длину строки в байтах/символах; для простых латиницы/кириллицы этого достаточно). Алиас `AS len` упрощает сортировку и вывод. Сортируем сначала по `len DESC` (самые длинные — вверху), затем по `title` для детерминированности среди одинаковой длины.

---

## Задание 4 — WHERE + BETWEEN

**Задача.** Вывести все записи из `grades`, где оценка (grade) между 4 и 5 включительно, отсортированные по убыванию оценки.

**SQL**

```sql
SELECT id, student_id, subject_id, grade
FROM grades
WHERE grade BETWEEN 4 AND 5
ORDER BY grade DESC;
```

**Пояснение.**
`WHERE grade BETWEEN 4 AND 5` — краткая запись для `grade >= 4 AND grade <= 5`. `BETWEEN` делает условие читабельным для диапазонов. `ORDER BY grade DESC` показывает сначала лучшие оценки. Если в таблице есть NULL в `grade`, они не попадут (BETWEEN не выбирает NULL).

---

## Задание 5 — LIKE (поиск по шаблону)

**Задача.** Найти всех студентов, у которых в имени встречается фрагмент `Иван` (например «Иван», «Иванов», «Иванова»).

**SQL**

```sql
SELECT id, name
FROM students
WHERE name LIKE '%Иван%';
```

**Пояснение.**
`LIKE '%Иван%'` ищет `Иван` в любом месте строки (перед и/или после могут быть другие символы). В SQLite поиск по `LIKE` по умолчанию чувствителен к регистру — если нужен нечувствительный — можно использовать `LOWER(name) LIKE LOWER('%ivan%')` (или колlation). Обратите внимание на производительность: на больших таблицах `LIKE '%...%'` не использует индекс.

---

## Задание 6 — IS NULL / IS NOT NULL

**Задача A.** Показать всех преподавателей, у которых **нет** назначенного предмета (`subject_id IS NULL`).
**Задача B.** Показать всех преподавателей, у которых есть назначенный предмет (`subject_id IS NOT NULL`).

**SQL A**

```sql
SELECT id, name
FROM teachers
WHERE subject_id IS NULL;
```

**SQL B**

```sql
SELECT id, name, subject_id
FROM teachers
WHERE subject_id IS NOT NULL;
```

**Пояснение.**
`IS NULL` и `IS NOT NULL` — специальные операторы для проверки отсутствия значения. Нельзя писать `= NULL`. Используется, чтобы найти «осиротевшие» записи или, наоборот, заполненные. Часто применяется при валидации данных и подготовке исправлений.

---

## Задание 7 — ORDER BY + LIMIT + OFFSET (пагинация)

**Задача.** Реализовать «вторую страницу» списка студентов: вывести 10 студентов, отсортированных по имени, начиная с 11-й записи (т.е. OFFSET 10).

**SQL**

```sql
SELECT id, name
FROM students
ORDER BY name
LIMIT 10 OFFSET 10;
```

**Пояснение.**
`LIMIT 10 OFFSET 10` вернёт записи 11–20 (поскольку OFFSET пропускает первые 10). Такой паттерн часто применяется в UI для постраничной навигации. Для больших таблиц подумать о `ORDER BY` по индексированному полю (обычно по `id` или `name` с индексом).

---

## Задание 8 — GROUP BY + COUNT (с DISTINCT)

**Задача.** Для каждого студента посчитать, по скольким **разным предметам** у него есть оценки (т.е. кол-во уникальных `subject_id`). Отсортировать по убыванию этого числа.

**SQL**

```sql
SELECT student_id, COUNT(DISTINCT subject_id) AS subjects_count
FROM grades
GROUP BY student_id
ORDER BY subjects_count DESC;
```

**Пояснение.**
`GROUP BY student_id` агрегирует строки по студенту. `COUNT(DISTINCT subject_id)` считает число уникальных предметов, по которым студент имел оценки — удобный приём, чтобы убрать повторные попытки по одному предмету. `ORDER BY ... DESC` выводит наиболее «разнообразных» студентов в начале.

---

## Задание 9 — GROUP BY + AVG + HAVING

**Задача.** Найти предметы (`subject_id`), где средний балл (по всем записям в `grades`) **не ниже 4.5**.

**SQL**

```sql
SELECT subject_id, AVG(grade) AS avg_grade
FROM grades
GROUP BY subject_id
HAVING AVG(grade) >= 4.5
ORDER BY avg_grade DESC;
```

**Пояснение.**
`AVG(grade)` вычисляет среднее по группе. `HAVING` фильтрует уже сгруппированные данные — именно для агрегатов (нельзя использовать `AVG` в `WHERE`). `ORDER BY avg_grade DESC` выводит лучшие предметы первыми. Учтите: если у предмета нет записей (нет оценок), он не появится в результате — либо используйте LEFT JOIN с subjects (запрещено пока), либо заранее вставляйте нулевые/плейсхолдерные значения.

---

# 6. JOIN — основы

Когда мы разобрались с тем, как создавать таблицы и связывать их через **первичные** и **внешние ключи**, настал момент научиться работать с данными сразу из нескольких таблиц. На практике почти никогда не бывает так, что нужная информация лежит в одной таблице.

Например:

- В таблице **students** у нас есть только имена студентов.
- В таблице **grades** — оценки, но они ссылаются на `student_id`.
- В таблице **subjects** — список предметов.

Чтобы вывести красивый список вроде:

> "Иван Иванов получил по математике 5",

нам нужно связать между собой **три разные таблицы**. Именно для этого в SQL есть соединения (JOIN).

---

### INNER JOIN

**INNER JOIN** показывает **только те строки, которые совпадают** в обеих таблицах.
Представьте себе два круга в диаграмме Венна — результат будет пересечение.

Пример: студенты, у которых есть оценки. Те студенты, у кого пока оценок нет, просто не попадут в выборку.

> Обычно `INNER JOIN` используется чаще всего, потому что мы в большинстве случаев работаем только с данными, которые реально связаны.

---

**Пример.** Получить список студентов и их оценки вместе с названием предмета.

```sql
SELECT s.name AS student,
       subj.title AS subject,
       g.grade
FROM grades g
INNER JOIN students s ON g.student_id = s.id
INNER JOIN subjects subj ON g.subject_id = subj.id;
```

> Здесь берутся только те строки, где есть совпадение и по студенту, и по предмету. Если нет оценки — студент не попадёт. Это базовый и самый используемый вариант.

---

### LEFT JOIN

**LEFT JOIN** берёт все строки из левой таблицы и добавляет к ним данные из правой, если они есть. Если совпадений нет — в правой части будут `NULL`.

Пример: мы хотим вывести **всех студентов**, даже если у кого-то ещё нет оценок. В таком случае **LEFT JOIN** покажет студента, а в колонке "grade" будет пусто (`NULL`).

> Это очень удобно, когда нам нужно видеть "всю картину", даже если часть данных ещё не заполнена.

---

**Пример.** Показать всех студентов и их оценки, даже если у кого-то пока нет ни одной оценки.

```sql
SELECT s.name AS student,
       g.grade,
       g.subject_id
FROM students s
LEFT JOIN grades g ON s.id = g.student_id;
```

> Все студенты попадут в выборку, даже если в `grades` у них пусто. Для «безоценочных» студентов в колонках из `grades` будут NULL.

---

### RIGHT JOIN

**RIGHT JOIN** — это зеркальная версия LEFT JOIN.
Она показывает **все строки из правой таблицы**, а слева — совпадения, если есть.

⚠️ Но в SQLite нет оператора `RIGHT JOIN`.
Что делать? Мы можем просто поменять таблицы местами и использовать `LEFT JOIN`. То есть технически он нам не нужен, но знать о нём полезно: в PostgreSQL, MySQL и других СУБД он встречается.

---

**Пример.** Показать все оценки и имена студентов (если студент удалён, а запись в `grades` осталась, имя будет NULL).

Так как SQLite **не поддерживает RIGHT JOIN напрямую**, поэтому заменяем порядок таблиц и используем LEFT JOIN.

```sql
SELECT g.id AS grade_id,
       g.grade,
       s.name AS student
FROM grades g
LEFT JOIN students s ON g.student_id = s.id;
```

> Это «аналог RIGHT JOIN students → grades», только через перестановку таблиц. Основной приём для SQLite.

---

### FULL OUTER JOIN

**FULL OUTER JOIN** объединяет результат **LEFT JOIN** и **RIGHT JOIN**.
То есть показывает вообще все строки из обеих таблиц: совпавшие и не совпавшие.

⚠️ В SQLite тоже нет прямой поддержки FULL OUTER JOIN.
Но мы можем получить аналог через объединение (`UNION`) результатов двух запросов:

- Один через LEFT JOIN
- Второй через RIGHT JOIN (эмулированный)

И в итоге мы получим то же самое.

> На практике FULL OUTER JOIN используется нечасто, потому что обычно нужны конкретные связи, а не "абсолютно всё".

---

**Пример.** Показать всех студентов и все оценки: если у студента нет оценок — будут строки с NULL в `grades`; если в `grades` есть «осиротевшие» записи без студента — тоже должны попасть.

```sql
SELECT s.id AS student_id,
       s.name AS student,
       g.grade
FROM students s
LEFT JOIN grades g ON s.id = g.student_id
UNION
SELECT s.id AS student_id,
       s.name AS student,
       g.grade
FROM grades g
LEFT JOIN students s ON g.student_id = s.id;
```

> Такой приём объединяет результаты двух LEFT JOIN в обе стороны, что и даёт FULL OUTER JOIN. На практике используется редко, но знать принцип полезно.

### CROSS JOIN

**CROSS JOIN** — это **декартово произведение**.
Каждая строка из первой таблицы соединяется с каждой строкой из второй.

Например:

- У нас 10 студентов и 5 предметов.
- Если сделать CROSS JOIN, получится 50 комбинаций "студент–предмет".

Такой приём используется редко, но иногда он удобен для генерации всех возможных комбинаций, особенно если потом мы добавляем фильтрацию.

---

**Пример.** Получить все возможные комбинации «студент × предмет» (например, чтобы подготовить таблицу для последующего заполнения оценками).

```sql
SELECT s.name AS student,
       subj.title AS subject
FROM students s
CROSS JOIN subjects subj;
```

> Это декартово произведение: если 10 студентов и 5 предметов — будет 50 строк. Используется осторожно, т.к. результат растёт очень быстро.

### Итог: какие JOIN используются чаще всего?

- **INNER JOIN** — основа работы, применяется чаще всего.
- **LEFT JOIN** — когда нужно увидеть все записи из одной таблицы, даже если нет связей.
- **RIGHT JOIN** и **FULL OUTER JOIN** — встречаются редко, и в SQLite работают только через обходные пути.
- **CROSS JOIN** — специфический инструмент, но знать о нём стоит.

> В нашей практике мы будем концентрироваться в первую очередь на **INNER JOIN** и **LEFT JOIN**, так как это самые полезные операторы для реальной работы с данными.

---

# 7. Практика (Приложение)

### Шаг 1 — Создаём core.py (класс для работы с БД и схема)

Файл `core.py` — централизует подключение, включает проверку внешних ключей, создаёт таблицы и наполняет их тестовыми данными (`seed`).

```python
# core.py
import sqlite3
from pathlib import Path

DB_PATH = Path("school.db")

class Database:
    def __init__(self, db_path: Path = DB_PATH):
        self.db_path = Path(db_path)
        self.conn = sqlite3.connect(str(self.db_path))
        # Чтобы получать удобные объекты строк по имени колонки:
        self.conn.row_factory = sqlite3.Row
        # Включаем проверку внешних ключей (важно в SQLite)
        self.conn.execute("PRAGMA foreign_keys = ON;")
        self.conn.commit()

    def exec_write(self, sql: str, params=None):
        cur = self.conn.cursor()
        if params is None:
            cur.execute(sql)
        elif isinstance(params, list):
            cur.executemany(sql, params)
        else:
            cur.execute(sql, params)
        self.conn.commit()
        return cur

    def exec_read(self, sql: str, params=()):
        cur = self.conn.cursor()
        cur.execute(sql, params)
        return cur.fetchall()

    def create_tables(self):
        """Создаёт схему: students, subjects, teachers, grades."""
        sqls = [
            # students
            """
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL
            );
            """,
            # subjects
            """
            CREATE TABLE IF NOT EXISTS subjects (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL
            );
            """,
            # teachers (каждый teacher может быть связан с subject через subject_id)
            """
            CREATE TABLE IF NOT EXISTS teachers (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                subject_id INTEGER,
                FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE SET NULL
            );
            """,
            # grades: оценки привязаны к студенту и предмету
            """
            CREATE TABLE IF NOT EXISTS grades (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                student_id INTEGER NOT NULL,
                subject_id INTEGER NOT NULL,
                grade INTEGER,
                created_at TEXT DEFAULT (date('now')),
                FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,
                FOREIGN KEY (subject_id) REFERENCES subjects(id) ON DELETE CASCADE
            );
            """
        ]
        for s in sqls:
            self.exec_write(s)

    def seed_data(self, force: bool = False):
        """
        Наполняет тестовыми данными, если таблицы пусты.
        Если force=True — переписывает (удаляет старые данные и вставляет заново).
        """
        if force:
            # осторожно — удаляем содержимое
            for t in ("grades", "teachers", "students", "subjects"):
                self.exec_write(f"DELETE FROM {t};")
                self.exec_write(f"DELETE FROM sqlite_sequence WHERE name='{t}';")  # сброс AUTOINC (SQLite)
        # проверяем есть ли данные
        cnt = self.exec_read("SELECT COUNT(*) as c FROM students;")[0]["c"]
        if cnt > 0 and not force:
            print("Seed: данные уже есть — пропускаю (use force=True to reset).")
            return

        # вставляем справочники: students, subjects, teachers
        students = [
            ("Иван Иванов",),
            ("Мария Петрова",),
            ("Алексей Смирнов",),
            ("Ольга Кузнецова",),
            ("Дмитрий Орлов",),
            ("Светлана Никифорова",)
        ]
        subjects = [
            ("Математика",),
            ("Физика",),
            ("История",),
            ("Информатика",)
        ]
        # teachers: (name, subject_id) — привязка преподавателя к предмету
        # После вставки subjects мы узнаем их id, но используем фиксированные id,
        # потому что мы только что создали subjects в этой же базе.
        # Предполагаем, что subject ids будут 1..len(subjects)
        teachers = [
            ("Петров", 1),   # Математика
            ("Сидоров", 2),  # Физика
            ("Иванова", 4)   # Информатика
        ]
        grades = [
            # (student_id, subject_id, grade)
            (1, 1, 5),
            (1, 4, 4),
            (2, 1, 3),
            (3, 2, 4),
            (4, 3, 5),
            (5, 1, 4),
            (6, 4, 5)
        ]

        self.exec_write("INSERT INTO students (name) VALUES (?);", students)
        self.exec_write("INSERT INTO subjects (title) VALUES (?);", subjects)
        self.exec_write("INSERT INTO teachers (name, subject_id) VALUES (?, ?);", teachers)
        self.exec_write("INSERT INTO grades (student_id, subject_id, grade) VALUES (?, ?, ?);", grades)
        print("Seed: данные вставлены.")

    def close(self):
        self.conn.close()
```

**Пояснения:**

- `PRAGMA foreign_keys = ON;` — обязательно, без этого FK не проверяются в SQLite.
- `ON DELETE CASCADE` на `grades` — обычно удобно: при удалении студента/предмета связанные оценки удаляются автоматически (демонстрация поведения).
- `ON DELETE SET NULL` на `teachers.subject_id` — если предмет удалён, у преподавателя поле `subject_id` станет `NULL` (преподаватель «без предмета»).

### Подробнее о `PRAGMA foreign_keys = ON;`

`PRAGMA foreign_keys = ON;` включает _проверку ограничений внешних ключей_ (FOREIGN KEY) **для конкретного соединения** SQLite. Без этого включения SQLite **не будет** запрещать вставки/удаления/обновления, которые ломают ссылочную целостность, и `ON DELETE`/`ON UPDATE` не будут выполняться.

---

### Почему это важно

1. **По умолчанию в SQLite проверка FK отключена.**
   Исторически поддержка FK в SQLite появилась, но по умолчанию она выключена — чтобы она работала, надо явно включить. (Практически во всех приложениях принято включать её вручную.)

2. **Если FK не включены, данные могут стать неконсистентными.**
   Пример: вы сможете вставить запись в `grades` со `student_id = 999`, хотя такого студента нет. Это создаёт «висящие» ссылки и ломает логику приложения.

3. **Включение — на уровне соединения.**
   Это не глобальная настройка базы на диск; она действует только для текущего `sqlite3.Connection`. Если вы откроете второе соединение к той же базе, вам нужно снова выполнить `PRAGMA foreign_keys = ON` в этом соединении.

4. **Включение даёт вам реальное поведение FK-ограничений:**

   - запрещает вставку дочерней строки без родителя (выдаст `sqlite3.IntegrityError`),
   - запрещает удаление родителя при `RESTRICT`/`NO ACTION`,
   - вызывает каскадный удаление `ON DELETE CASCADE`,
   - позволяет `ON DELETE SET NULL`, и т.д.

---

### Шаг 2 — Создаём `logic.py` (функции-решения 10 задач)

Файл с функциями, которые выполняют SQL-запросы и возвращают результаты.

#### Задание 1. Список студентов, предметов и их оценок (INNER JOIN)

**Описание:**
Выведите список студентов, предметов и полученных ими оценок. Если у студента нет оценки по предмету — он в выборку не попадёт.

**Ожидаемый результат:**
Таблица с колонками: `student_name`, `subject_title`, `grade`.

---

#### Задание 2. Все студенты и их оценки (LEFT JOIN)

**Описание:**
Составьте список всех студентов и их оценок по предметам (если они есть). Если студент ещё не получил оценок, в поле `grade` должно стоять `NULL`.

**Ожидаемый результат:**
Таблица с колонками: `student_name`, `subject_title`, `grade`, где могут встречаться строки с пустыми оценками.

---

#### Задание 3. Количество оценок по каждому предмету (COUNT)

**Описание:**
Посчитайте, сколько оценок выставлено по каждому предмету.

**Ожидаемый результат:**
Таблица с колонками: `subject_title`, `grades_count`.

---

#### Задание 4. Средний балл по предметам (AVG)

**Описание:**
Для каждого предмета вычислите средний балл студентов.

**Ожидаемый результат:**
Таблица с колонками: `subject_title`, `avg_grade`.

---

#### Задание 5. Топ-студенты (фильтрация по среднему баллу)

**Описание:**
Найдите студентов, чей средний балл по всем предметам выше заданного порога (`threshold`).
Например, `threshold = 4.5`.

**Ожидаемый результат:**
Таблица с колонками: `student_name`, `avg_grade`.

---

#### Задание 6. Предметы и средний балл у каждого преподавателя

**Описание:**
Выведите список преподавателей, предметов, которые они ведут, и средний балл студентов по этим предметам.

**Ожидаемый результат:**
Таблица с колонками: `teacher_name`, `subject_title`, `avg_grade`.

---

#### Задание 7. Предметы без преподавателя

**Описание:**
Выведите список предметов, у которых ещё не назначен преподаватель (`teacher_id IS NULL`).

**Ожидаемый результат:**
Таблица с колонкой: `subject_title`.

---

#### Задание 8. Сколько раз каждый студент сдавал каждый предмет

**Описание:**
Посчитайте, сколько раз каждый студент получал оценку по каждому предмету (например, пересдачи).

**Ожидаемый результат:**
Таблица с колонками: `student_name`, `subject_title`, `attempts_count`.

---

#### Задание 9. Проверка каскадного удаления (ON DELETE CASCADE)

**Описание:**
Удалите одного студента из таблицы `students` и посмотрите, что произойдёт с его оценками в таблице `grades`.
(Подсказка: при правильно настроенных связях его оценки должны удалиться автоматически).

**Ожидаемый результат:**

- В таблице `students` выбранный студент исчезает.
- В таблице `grades` все записи, связанные с этим студентом, тоже исчезают.

---

### Шаг 3 — Проверка решенных задач.

```python
# logic.py
from core import Database

# 1) INNER JOIN: список (student, subject, grade)
def list_student_subject_grades(db: Database):
    sql = """
    SELECT s.id AS student_id, s.name AS student_name,
           sub.id AS subject_id, sub.title AS subject_title,
           g.grade
    FROM grades g
    INNER JOIN students s ON s.id = g.student_id
    INNER JOIN subjects sub ON sub.id = g.subject_id
    ORDER BY s.id, sub.id;
    """
    return db.exec_read(sql)

# 2) LEFT JOIN: все студенты и их оценки (если есть)
def list_students_with_optional_grades(db: Database):
    sql = """
    SELECT s.id AS student_id, s.name AS student_name,
           sub.title AS subject_title, g.grade
    FROM students s
    LEFT JOIN grades g ON g.student_id = s.id
    LEFT JOIN subjects sub ON sub.id = g.subject_id
    ORDER BY s.id;
    """
    return db.exec_read(sql)

# 3) Количество студентов/оценок по предметам (COUNT)
def subject_student_counts(db: Database):
    sql = """
    SELECT sub.id AS subject_id, sub.title AS subject_title,
           COUNT(DISTINCT g.student_id) AS students_count,
           COUNT(g.id) AS grades_count
    FROM subjects sub
    LEFT JOIN grades g ON g.subject_id = sub.id
    GROUP BY sub.id, sub.title
    ORDER BY students_count DESC;
    """
    return db.exec_read(sql)

# 4) Средний балл по предметам (AVG)
def avg_grade_per_subject(db: Database):
    sql = """
    SELECT sub.id AS subject_id, sub.title AS subject_title,
           AVG(g.grade) AS avg_grade
    FROM subjects sub
    LEFT JOIN grades g ON g.subject_id = sub.id
    GROUP BY sub.id, sub.title
    ORDER BY avg_grade DESC;
    """
    return db.exec_read(sql)

# 5) Топ-студенты (средний >= threshold)
def top_students_by_avg(db: Database, threshold: float = 4.5):
    sql = """
    SELECT s.id AS student_id, s.name AS student_name,
           AVG(g.grade) AS avg_grade, COUNT(g.grade) AS grades_count
    FROM students s
    JOIN grades g ON g.student_id = s.id
    GROUP BY s.id, s.name
    HAVING AVG(g.grade) >= ?
    ORDER BY avg_grade DESC;
    """
    return db.exec_read(sql, (threshold,))

# 6) Преподаватели: предметы и средний балл по их предметам
def teachers_subjects_avg(db: Database):
    sql = """
    SELECT t.id AS teacher_id, t.name AS teacher_name,
           sub.id AS subject_id, sub.title AS subject_title,
           AVG(g.grade) AS avg_grade
    FROM teachers t
    LEFT JOIN subjects sub ON sub.id = t.subject_id
    LEFT JOIN grades g ON g.subject_id = sub.id
    GROUP BY t.id, t.name, sub.id, sub.title
    ORDER BY t.id;
    """
    return db.exec_read(sql)

# 7) Предметы без преподавателя
def subjects_without_teacher(db: Database):
    sql = """
    SELECT sub.id AS subject_id, sub.title AS subject_title
    FROM subjects sub
    LEFT JOIN teachers t ON t.subject_id = sub.id
    WHERE t.id IS NULL;
    """
    return db.exec_read(sql)

# 8) Сколько раз каждый студент сдавал каждый предмет (COUNT per student+subject)
def attempts_count_per_student_subject(db: Database):
    sql = """
    SELECT s.id AS student_id, s.name AS student_name,
           sub.id AS subject_id, sub.title AS subject_title,
           COUNT(g.id) AS attempts
    FROM students s
    LEFT JOIN grades g ON g.student_id = s.id
    LEFT JOIN subjects sub ON sub.id = g.subject_id
    GROUP BY s.id, sub.id
    ORDER BY s.id, attempts DESC;
    """
    return db.exec_read(sql)

# 9) Проверка ON DELETE CASCADE: удаляем студента и смотрим что произошло
def delete_student_and_show_effect(db: Database, student_id: int):
    # посчитаем оценки до удаления
    before = db.exec_read("SELECT COUNT(*) AS cnt FROM grades WHERE student_id = ?;", (student_id,))[0]["cnt"]
    # удаляем студента
    db.exec_write("DELETE FROM students WHERE id = ?;", (student_id,))
    after = db.exec_read("SELECT COUNT(*) AS cnt FROM grades WHERE student_id = ?;", (student_id,))[0]["cnt"]
    return {"student_deleted": student_id, "grades_before": before, "grades_after": after}
```

### Шаг 4 — Создаём `main.py` (меню и запуск)

Файл, который запускает приложение, и предлагает пользователю выбор. Скопируйте:

```python
# main.py
from core import Database
import logic

def print_rows(rows):
    if not rows:
        print("Ничего не найдено.")
        return
    for r in rows:
        # sqlite3.Row поддерживает доступ как по имени, так и по индексу
        print(dict(r))

def main():
    db = Database()
    db.create_tables()
    db.seed_data()  # если таблицы пусты — seed вставит данные

    menu = {
        "1": ("Список (студент, предмет, оценка) — INNER JOIN", lambda: logic.list_student_subject_grades(db)),
        "2": ("Все студенты и их оценки (LEFT JOIN)", lambda: logic.list_students_with_optional_grades(db)),
        "3": ("Кол-во студентов и оценок по предметам", lambda: logic.subject_student_counts(db)),
        "4": ("Средний балл по предметам", lambda: logic.avg_grade_per_subject(db)),
        "5": ("Топ-студенты по среднему (>=4.5)", lambda: logic.top_students_by_avg(db, 4.5)),
        "6": ("Преподаватели: предметы и средний балл", lambda: logic.teachers_subjects_avg(db)),
        "7": ("Предметы без преподавателя", lambda: logic.subjects_without_teacher(db)),
        "8": ("Кол-во попыток (студент+предмет)", lambda: logic.attempts_count_per_student_subject(db)),
        "9": ("Демонстрация транзакции (вставка + откат)", lambda: logic.transaction_demo(db)),
        "10": ("Удалить студента и показать эффект ON DELETE CASCADE", lambda: logic.delete_student_and_show_effect(db, int(input('ID студента для удаления: ')))),
        "0": ("Выход", None)
    }

    while True:
        print("\n=== Меню: JOIN и связанная практика ===")
        for k, (desc, _) in menu.items():
            print(f"{k}) {desc}")
        choice = input("Выберите пункт: ").strip()
        if choice == "0":
            print("До встречи.")
            break
        if choice not in menu:
            print("Неверный пункт.")
            continue
        desc, action = menu[choice]
        print(f"\n--- {desc} ---")
        try:
            result = action()
            # result может быть list[Row] либо dict (для операций)
            if isinstance(result, list):
                print_rows(result)
            else:
                print(result)
        except Exception as e:
            print("Ошибка при выполнении пункта:", e)
        input("\nНажмите Enter чтобы продолжить...")

    db.close()

if __name__ == "__main__":
    main()
```

**Пояснения:**

- `seed_data()` вызывается один раз при первом запуске. Если вы не хотите перезаписывать данные — не используйте `force=True`.
- В пункте 10 запрашиваем `student_id` у пользователя и удаляем его — это демонстрация работы `ON DELETE CASCADE` на `grades`.

---

# 8. Вопросы

1. **Зачем в базе данных хранить связанные таблицы, а не одну «большую» таблицу со всеми данными сразу?**

2. **Что такое первичный ключ (PRIMARY KEY) и какие у него свойства?**
   _(подсказка: уникальность, не NULL, используется для идентификации строки)_

3. **Что такое внешний ключ (FOREIGN KEY) и зачем он нужен?**

4. **Какую проблему решает внешний ключ, если у нас есть таблицы `students` и `grades`?**

5. **Какие бывают виды связей между таблицами? Приведите короткий пример для каждой.**

6. **Почему в реляционных базах данных не рекомендуется дублировать одни и те же данные в разных местах?**
   _(подсказка: нормализация, изменение в одном месте должно автоматически отражаться во всех зависимостях)_

7. **Что произойдёт, если удалить строку в таблице `students`, у которой есть связанные оценки в таблице `grades`, но связь настроена без `ON DELETE CASCADE`?**

8. **В чём разница между INNER JOIN и LEFT JOIN? Когда лучше использовать LEFT JOIN?**

9. **Почему таблица «связка» (join table) нужна при связи «многие ко многим»?**
   _(например, `students_subjects` для учёта, кто какие предметы изучает)_

10. **Представьте: у вас есть таблица `teachers`, `subjects` и `grades`. Как одним запросом найти средний балл по каждому предмету и преподавателю? Какой оператор SQL здесь поможет?**
    _(подсказка: GROUP BY + агрегатная функция)_

---

# 9. Домашняя работа

**Задание 1.**
Выведите список всех студентов, которые зарегистрированы в базе.
Покажите только их `id` и `имя`. Это поможет убедиться, что таблица `students` работает правильно и в ней действительно есть данные.

---

**Задание 2.**
Получите список всех уникальных предметов, которые присутствуют в базе.
Используйте оператор `DISTINCT`, чтобы предметы не повторялись, даже если на них учится несколько студентов.

---

**Задание 3.**
Найдите всех студентов, у которых длина имени больше **5 символов**.
Подсказка: используйте функцию `LENGTH(name)`. Это может пригодиться, если, например, нужно отобрать длинные имена для отчёта.

---

**Задание 4.**
Выведите все оценки студентов, которые находятся в диапазоне **от 3 до 5 включительно**.
Используйте оператор `BETWEEN`. Это удобный способ отобрать оценки «выше среднего».

---

**Задание 5.**
Найдите всех студентов, чьё имя начинается на букву **"A"**.
Используйте `LIKE 'A%'`. Такой поиск часто применяют, когда нужно отобрать данные по маске (например, фамилии на определённую букву).

---

**Задание 6.**
Выведите список всех предметов, у которых **нет преподавателя**.
Подсказка: для этого нужно проверить, что в таблице `teachers` не существует записи с таким `subject_id`. Это проверяется через `IS NULL` или через подзапрос `NOT IN`.

---

**Задание 7.**
Найдите **3 студентов**, у которых наибольшее количество оценок.
Подсказка: сначала сгруппируйте оценки по студенту (`GROUP BY`), потом отсортируйте результат по количеству (`ORDER BY`), и ограничьте вывод с помощью `LIMIT`.

---

**Задание 8.**
Посчитайте **средний балл по каждому предмету**.
Подсказка: используйте `GROUP BY subject_id` и агрегатную функцию `AVG(grade)`. Это позволит узнать, по каким предметам студенты учатся лучше, а где хуже.

---

**Задание 9.**
Найдите всех студентов, у которых **больше двух оценок**.
Подсказка: после группировки (`GROUP BY student_id`) используйте `HAVING COUNT(*) > 2`. Это отфильтрует только тех, кто сдавал предметы чаще.

---

**Задание 10.**
Проверьте, как работает ограничение **ON DELETE CASCADE**.

1. Удалите одного студента из таблицы `students`.
2. Проверьте, остались ли его оценки в таблице `grades`.
   Они должны удалиться автоматически. Если это произошло — значит связь `FOREIGN KEY ... ON DELETE CASCADE` работает корректно.

---

[Предыдущий урок](lesson07.md) | [Следующий урок](lesson09.md)
