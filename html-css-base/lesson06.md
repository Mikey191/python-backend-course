# Модуль 2. Урок 6. Работа со списками (ul, ol). Стилизация списков. Псевдо-классы и псевдо-элементы.

# Списки в HTML — теория, семантика и простая стилизация

## Введение — зачем вообще нужны списки

**Списки** — это один из фундаментальных блоков HTML. Они позволяют упорядоченно представить несколько однородных элементов: пункты меню, шаги инструкции, перечень характеристик, набор ссылок и т.д. Когда вы используете списки, вы даёте браузеру и вспомогательным технологиям (экранным читалкам, поисковым роботам) **информацию о структуре**: «это именно перечисление, а не просто набор абзацев». Это делает разметку более семантичной, понятной и удобной для автоматической обработки.

Ключевая мысль: **семантика делает код понятнее не только человеку, но и машине** — и это важно для доступности (accessibility) и SEO.

---

## 1. Что такое списки в HTML — базовые теги и их смысл

В HTML у нас есть несколько типов списков, и каждый из них имеет своё назначение:

- `<ul>` — _unordered list_, **ненумерованный список**. Используется, когда порядок элементов не важен: перечень характеристик, меню, список ссылок. Элементы этого списка записываются в `<li>`.

  ```html
  <ul>
    <li>Молоко</li>
    <li>Хлеб</li>
    <li>Яйца</li>
  </ul>
  ```

- `<ol>` — _ordered list_, **нумерованный список**. Используется, когда важен порядок: шаги инструкции, ранжированный перечень.

  ```html
  <ol>
    <li>Включить питание</li>
    <li>Подключить кабель</li>
    <li>Запустить приложение</li>
  </ol>
  ```

- `<li>` — **элемент списка** (list item). Всегда находится внутри `<ul>` или `<ol>`.

- `<dl>`, `<dt>`, `<dd>` — **описательный список** (description list). Подходит для «термин — определение», спецификаций, пар «вопрос — ответ».

  ```html
  <dl>
    <dt>HTML</dt>
    <dd>язык разметки для web-страниц</dd>
    <dt>CSS</dt>
    <dd>язык стилей для оформления</dd>
  </dl>
  ```

**Почему разные теги важны:** потому что семантика каждого из них подразумевает разную роль. Экранный читалка, прочитав `<ol>`, может объявить «список из N пунктов» и сообщить пользователю номер текущего пункта — это облегчает навигацию. Если вы сделаете всё просто через `<div>` и стилизуете «под список», вы потеряете эту встроенную информацию.

---

## 2. Где обычно применяют списки — типичные кейсы

Списки применяются почти повсюду. Короткий обзор наиболее частых сценариев:

- **Навигация (меню).** Горизонтальные меню в шапке сайта и вертикальные — в сайдбарах — почти всегда реализуют как `<ul><li><a>…</a></li></ul>`. Это логично: меню — это перечисление ссылок.

- **Списки товаров / возможностей / шагов.** Перечисление характеристик товара или преимуществ сервиса — классический `ul`.

- **Breadcrumbs (хлебные крошки).** Обычно используют `<ol>` потому что хлебные крошки показывают путь с порядком (например: Главная → Каталог → Раздел → Товар).

- **Чек-листы и формы.** Перечисления задач, пунктов чек-листа.

- **Форматированный вывод описаний и спецификаций.** Здесь удачно работает `<dl>`.

- **Семантические меню, списки контактов и т. п.** Повсеместно применяются списки, когда есть набор однородных элементов.

Главное правило: **используйте списки тогда, когда по смыслу у вас действительно перечисление**. Не применяйте `<ul>` только ради удобства стилизации — семантика важнее.

---

## 3. Браузерное поведение по умолчанию — от чего отталкиваемся

Браузеры по умолчанию выводят списки с определёнными стилями:

- `ul` обычно имеет `padding-left` (в разных браузерах примерно 40px) — это чтобы маркеры (буллеты) не налезали на содержимое.
- `li` получает маркер (точка, кружок, диск, квадрат и т.п.) у ненумерованного списка; `ol` — номера.
- `dl` обычно имеет `dt` жирный, `dd` с отступом.

Когда вы начнёте стилизовать списки, полезно понимать эти значения по умолчанию — обычно первым шагом делают **reset**: убирают внешние/внутренние отступы и стандартные маркеры, чтобы начать с «чистого листа».

Пример сброса:

```css
ul,
ol {
  margin: 0;
  padding: 0;
}
ul {
  list-style: none; /* удаляем маркеры */
}
```

---

## 4. Простая стилизация списков — основные приёмы и объяснение «почему»

Далее — набор практических приёмов с пояснениями.

### 4.1. Убираем маркеры: `list-style: none;`

Когда вы хотите контролировать визуальный вид списка полностью через CSS (например, поставить свои иконки или сделать горизонтальное меню), обычно убирают стандартные маркеры:

```css
ul {
  list-style: none;
}
```

**Почему:** стандартный маркер управляется браузером и имеет ограниченные возможности по стилю; свой маркер гибче и позволяет единообразную стилизацию в разных браузерах.

**Замечание по доступности:** если вы убираете маркеры в списке, сам список всё ещё остаётся семантичным (экранный читалка всё равно видит список). Однако если маркеры важны визуально для восприятия (например, в чек-листе), замените их на свои с помощью `::before` или `background-image`, чтобы пользователи с визуальными ограничениями не потеряли контекст.

---

### 4.2. Меняем позицию маркера: `list-style-position`

Свойство `list-style-position` может принимать `inside` или `outside`.

- `outside` (по умолчанию): маркер рисуется **слева вне** блока содержимого; текст переносится с отступом.
- `inside`: маркер рисуется **внутри** блока; если текст строки переносится на следующую строку, она будет выравнена под маркером (что меняет визуальную «вложенность»).

Пример:

```css
ul {
  list-style-position: inside;
}
```

**Когда использовать:** `inside` удобно, когда вы хотите, чтобы перенос строки сохранял отступ под маркером; `outside` — когда нужен привычный вид «выпадающего» маркера.

---

### 4.3. Кастомные маркеры: `::before + content` и `list-style-image`

Есть несколько способов поставить собственный маркер:

**a) `list-style-image`:**

```css
ul {
  list-style-image: url("/icons/bullet.svg");
}
```

Это простой способ, но у него ограничения: мало контроля над позицией и размерами в разных браузерах.

**b) Псевдоэлемент `::before`:** гораздо гибче:

```css
li {
  position: relative; /* не всегда обязательно, но полезно */
}

li::before {
  content: "•"; /* можно использовать Unicode символ */
  color: crimson;
  display: inline-block;
  width: 1em;
  margin-right: 0.5em;
  /* или использовать background-image, width/height и display:inline-block */
}
```

Или с иконкой:

```css
li::before {
  content: "";
  display: inline-block;
  width: 16px;
  height: 16px;
  background-image: url("icon.png");
  background-size: contain;
  margin-right: 8px;
}
```

**Почему `::before` лучше:** полное управление размером, цветом, положением; можно добавлять анимацию, hover-эффекты; работает в современных браузерах. Также — легче управлять отступами/выровнением.

---

### 4.4. Выравнивание и отступы: `padding` и `margin` у `<ul>`/`li`

По умолчанию браузер ставит `padding-left` у `<ul>`/`ol`. При создании «чистого» меню или карточек вы часто хотите убрать эти значения и задать свои. Общий шаблон:

```css
ul {
  margin: 0; /* убираем внешние отступы у списка */
  padding: 0; /* убираем внутренние отступы */
}
li {
  margin: 0.5em 0; /* вертикальные отступы между пунктами */
  padding: 0.2em 0; /* внутренняя «подушка» */
}
```

**Почему это важно:** без контроля над margin/padding вы получите несовместимый вид в разных браузерах. Контролируемые отступы помогают выровнять пункты меню, сделать кликабельную область у ссылок и избежать наложений.

---

### 4.5. Горизонтальное размещение элементов: `display: inline-block` или `display: inline`

Чтобы элементы списка выстроились в одну строку (горизонтальное меню), можно использовать:

```css
ul.menu {
  padding: 0;
  margin: 0;
  list-style: none;
  text-align: center; /* центрирование всей 'строки' */
}

ul.menu li {
  display: inline-block; /* превращаем li в строчно-блочный */
  margin: 0 10px;
}
```

Или:

```css
ul.menu li {
  display: inline; /* менее гибко, чем inline-block */
}
```

**Пояснение различий:**

- `display: inline` — элемент ведёт себя как слово в тексте: нельзя задать ширину/высоту; вертикальные отступы работают не как у блоков.
- `display: inline-block` — элемент остаётся в строке, но на него можно задавать `width`, `height`, `padding`, `margin` и `vertical-align`. Поэтому для меню обычно используют `inline-block`.

**Проблема whitespace:** при использовании `inline-block` между элементами HTML может появиться расстояние (пробелы, перевод строки) — браузер считает это пробелом текста. Решения:

1. Убирать пробелы в HTML: `<li>...</li><li>...</li>` — без пробела между тегами.
2. Комментарий-трюк: `</li><!--\n--><li>` — ugly but works.
3. Сделать `font-size: 0` у родителя и восстановить размер у дочерних элементов:

   ```css
   ul.menu {
     font-size: 0;
   }
   ul.menu li {
     font-size: 16px;
   }
   ```

4. Использовать отрицательный `margin` у `li` для компенсации — не рекомендуется, хрупко.
5. Использовать `float:left` (альтернативный подход) — тогда пробелов нет, но появляются свои проблемы (нужна очистка `clear`/clearfix).

Выбор зависит от проекта; `inline-block` + контроль whitespace — самый удобный и чистый способ для учебного меню.

---

### 4.6. Контроль кликабельной зоны: стиль ссылки внутри `li`

В меню полезно делать саму ссылку (`<a>`) блочной или строчно-блочной, чтобы вся «плитка» была кликабельной:

```css
ul.menu li a {
  display: inline-block;
  padding: 10px 15px;
  color: #333;
  text-decoration: none;
}
ul.menu li a:hover,
ul.menu li a:focus {
  background-color: #eee;
}
```

**Почему:** пользователь легче попадёт мышью/пальцем по более широкой зоне; это особенно важно на мобильных устройствах.

---

## 5. Псевдо-классы и псевдо-элементы применительно к спискам

### 5.1. Псевдо-классы для интерактивности

- `:hover` — стиль при наведении курсора. Часто используют для подсветки пункта меню.
- `:focus` и `:focus-visible` — **крайне важны для доступности**: при навигации с клавиатуры пользователь должен видеть, на каком элементе он сейчас. Не пренебрегайте фокус-стилями!
- `:active` — состояние при нажатии.
- `:visited` — стиль для уже посещённых ссылок (ограниченно поддерживается в современных браузерах по соображениям приватности).

Пример:

```css
ul.menu li a:hover,
ul.menu li a:focus {
  background: #ddd;
  outline: none; /* аккуратно: не убирайте фокусную рамку полностью без замены */
}
```

**Важно:** если вы убираете стандартную рамку фокуса (`outline`), всегда заменяйте её другим заметным стилем (например, `box-shadow: 0 0 0 3px rgba(0,123,255,.25);`), иначе клавиатурным пользователям станет трудно ориентироваться.

### 5.2. Псевдо-элементы `::before` / `::after` в списках

Мы уже говорили о `::before` для маркеров. Кроме того, `::after` удобно использовать для разделителей или декоративных элементов:

```css
ul.menu li:not(:last-child)::after {
  content: "|";
  margin-left: 10px;
  color: #ccc;
}
```

Здесь через `:not(:last-child)` мы добавляем разделитель между пунктами, но не после последнего — это часто применяемый приём.

---

## 6. Вложенные списки (подменю) — кратко о практике

Меню часто имеет подменю — это просто вложенный `ul` внутри `li`. Примерный HTML:

```html
<ul class="menu">
  <li>
    <a href="#">Каталог</a>
    <ul class="sub">
      <li><a href="#">Категория A</a></li>
      <li><a href="#">Категория B</a></li>
    </ul>
  </li>
  <li><a href="#">О нас</a></li>
</ul>
```

Стилизовать подменю можно, скрывая `.sub` по умолчанию и показывая при `li:hover` или при фокусе (`li:focus-within`). Про это — подробнее в разделе про навигацию и выпадающие меню (следующий блок урока).

---

## 7. Практические советы и «подводные камни»

- **Не используйте списки для layout'а.** Списки — для перечислений, а не для позиционирования произвольных блоков. Для layout лучше использовать контейнеры `<div>` и современные CSS-инструменты.
- **Семантика важнее внешнего вида.** Даже если в дизайне пункт не выглядит как «элемент списка», используйте `<ul>`/`<ol>` там, где это логично.
- **Доступность.** Не убирайте focus-стили; добавляйте `aria`-атрибуты для сложных меню (например `role="menu"`, `aria-haspopup`, `aria-expanded` — при динамическом управлении через JS).
- **Контроль whitespace при inline-block.** Продумайте, как вы будете избавляться от лишних пробелов в горизонтальных меню.
- **Унифицируйте reset для списков.** Часто на проекте делают общий reset для `ul, ol, li` чтобы иметь предсказуемую базу.

---

## 8. Мини-практика (сценарии для закрепления)

Ниже — четыре небольших задания, которые можно выполнять прямо сейчас, чтобы прочувствовать описанные приёмы. (Задания описаны в формате «что сделать» — без готового кода.)

**Задача 1 — Базовый список покупок**

1. Создайте `ul` с 5 пунктами (названия продуктов).
2. Сбросьте стандартные отступы у `ul` (margin/padding = 0) и уберите маркеры (`list-style: none`).
3. Добавьте `li::before` с содержимым `"•"` (Unicode bullet) красного цвета и отступом справа 0.5em.

**Что проверить:** каждый пункт должен начинаться с красной точки, выровнено, переносы текста выглядят аккуратно.

---

**Задача 2 — Горизонтальное меню**

1. Разметьте `nav > ul > li > a` с 4 ссылками.
2. Сделайте `ul` с `list-style: none` и `text-align: center`.
3. Сделайте `li` `display: inline-block`, задайте `li a` внутренние отступы так, чтобы зона клика была удобной.
4. Уберите пробелы между `li` (укажите выбранный способ: удалить пробелы в HTML или `font-size: 0` у `ul` и восстановление у `li`).

**Что проверить:** пункты выстроены в одну линию, центрированы, большая кликабельная зона у ссылок, при наведении фон или цвет меняются.

---

**Задача 3 — Меню с декоративным разделителем**

1. В горизонтальном меню (задача 2) добавьте разделитель `|` между пунктами, но **не** после последнего пункта.
2. Реализуйте это через `li:not(:last-child)::after`.

**Что проверить:** разделители есть между пунктами, последний пункт не имеет после себя `|`.

---

**Задача 4 — Описательный список (FAQ)**

1. Создайте `dl` с тремя парами `dt` (вопрос) / `dd` (ответ).
2. Стилизуйте `dt` жирным и `dd` с небольшим отступом слева.
3. Сделайте первый `dt` другим цветом через `dt:first-child` или через `:first-of-type`.

**Что проверить:** читаемая структура вопросов и ответов, визуальная иерархия.

---

# Навигация (semantics & практики)

Навигация — один из важнейших элементов любой страницы. Она даёт пользователю карту: куда можно перейти и как добраться до нужного раздела. Правильная разметка, аккуратная стилизация и корректная поддержка взаимодействия (клавиатура, touch, экранные читалки) делают сайт удобным и доступным.

---

## 1. Что такое навигация в контексте сайта

### Семанический тег `<nav>`

Тег `<nav>` — это семантический контейнер для _основной навигации_ страницы: набор ссылок, которые переводят пользователя по разделам сайта. `<nav>` сигнализирует браузерам и вспомогательным технологиям: «в этом месте — меню». Это важно для:

- **Доступности**: экранные читалки могут пропускать прямо к навигации.
- **SEO**: поисковики понимают, где находятся важные ссылки.
- **Поддерживаемости кода**: читающему разработчику сразу видно, что внутри — меню.

**Когда использовать `<nav>`?** — Если у вас есть блок ссылок, предназначенных для навигации по разделам/страницам (главное меню, футер-меню, сайдбарная навигация). Для одиночных ссылок (например, «читать далее» в контенте) `<nav>` не нужен.

### Глобальная vs локальная навигация

- **Глобальная (site-wide) навигация** — основное меню сайта (обычно в шапке), ведёт по разделам всего сайта: Главная, Каталог, Контакты и т.д. Для неё обязательно семантический `<nav>`.
- **Локальная (contextual) навигация** — навигация внутри раздела или статьи (таб «в этой секции», меню статей). Локальная навигация тоже может использовать `<nav>`, но часто оформляется как вспомогательный элемент внутри раздела.

**Пример:**

```html
<nav class="site-nav">... глобальное меню ...</nav>
<article>
  <nav class="article-nav">... ссылки по статье ...</nav>
</article>
```

---

## 2. Вертикальная vs горизонтальная навигация — где что уместно

### Горизонтальная навигация

- Обычно размещается в _шапке_ сайта.
- Подходит для небольшого числа пунктов (обычно 3–8).
- Вёрстка: пункты располагаются в одну строку — `inline-block` / `float` (в старых проектах) или `flex` (в современных, но мы пока без flex).
- Частые требования: центрирование меню, равные интервалы между пунктами, кликабельные «плитки» (увеличенные зоны ссылок).

### Вертикальная навигация

- Часто в сайдбаре — много пунктов, вложенных категорий.
- Удобна для длинных списков, фильтров, каталога разделов.
- Вёрстка: `display: block` для ссылок в колонке; можно скрывать/раскрывать подкатегории.

### Подходы верстки (без flex)

- `inline-block` + `text-align` у родителя — для горизонтального меню. Преимущества: просто и кроссбраузерно; недостаток: пробелы между элементами.
- `float:left` — тоже классический способ. Преимущества: нет пробелов; недостаток: необходима очистка потока (clearfix), и поведение усложняется.
- `display:inline` — простой, но неудобный для настройки размеров; обычно `inline-block` предпочтительнее.

---

## 3. Псевдо-классы для интерактивности навигации

Интерактивность меню — важнейшая часть UX. Ниже ключевые псевдо-классы и как их применять.

### `:hover` — наводим мышь

Применяется для визуальной реакции на наведение курсора:

```css
.nav a:hover {
  background: #f0f0f0;
  color: #000;
}
```

**Замечание:** `:hover` работает для мыши; на тач-устройствах поведение иное.

### `:focus` и `:focus-visible` — фокус клавиатуры

- `:focus` — элемент в фокусе (после таба), важен для клавиатурной навигации и доступности.
- `:focus-visible` — более современный подход: будет срабатывать, когда фокус видим (обычно при клавиатуре), но не при клике мышью.

Всегда обеспечивайте явный визуальный фокус (outline, box-shadow), чтобы пользователи Tab-навигации видели текущий элемент:

```css
.nav a:focus,
.nav a:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
}
```

**Важно:** если убирать `outline`, заменяйте его на другой хорошо различимый эффект.

### `:active` — при клике

Используется для индикации нажатия:

```css
.nav a:active {
  transform: translateY(1px);
}
```

### `:visited` — посещённые ссылки

Ограничения безопасности блокируют ряд свойств, но можно менять цвет:

```css
.nav a:visited {
  color: #6b6b6b;
}
```

**Примечание:** порядок объявления стилей для ссылок важен — о нём ниже.

### Правильный порядок написания правил для ссылок

В классическом CSS-уроке помнят правило `:link`, `:visited`, `:hover`, `:active` — сокращённо LoVe HA. Когда добавляем `:focus`/`:focus-visible`, рекомендуют ставить фокусные состояния рядом с `:hover`, чтобы они имели приоритет:

```css
/* Рекомендуемый порядок */
a:link {
  ...;
}
a:visited {
  ...;
}
a:hover,
a:focus,
a:focus-visible {
  ...;
}
a:active {
  ...;
}
```

**Почему это важно:** порядок влияет на то, какое правило будет применено, если селекторы одинаковой специфичности. Группировка `:hover` и `:focus` делает поведение предсказуемым — визуальные эффекты при наведении и фокусе совпадают.

---

## 4. Псевдо-элементы и украшения в навигации

`::before` и `::after` — очень мощные инструменты для добавления декоративных элементов **без** дополнительной разметки.

### Примеры применения

- **Разделители** между пунктами:

```css
.nav li:not(:last-child)::after {
  content: "|";
  margin: 0 10px;
  color: #ccc;
}
```

- **Стрелка (caret)** у пунктов с подменю:

```css
.nav li.has-sub > a::after {
  content: " ▾";
  font-size: 0.9em;
  margin-left: 6px;
  transition: transform 0.2s;
}
.nav li.has-sub:hover > a::after {
  transform: rotate(180deg);
}
```

- **Иконки** вместо маркеров: `::before { content: ""; width: 16px; height: 16px; background-image: url(...) }`

**Почему `::before/::after` удобны:** вы экономите DOM — не добавляете лишние элементы, легко контролируете позиционирование, размеры, анимации, меняете стиль при hover/focus через родительский селектор.

---

## 5. Выпадающие меню (dropdown) на чистом CSS — структура, показ/скрытие, плавность, доступность

Это самый «интересный» и одновременно самый проблемный кейс для реализации _только на CSS_. Дальше — последовательное понимание: HTML, базовый CSS, улучшения через `opacity/visibility/transform`, поддержка клавиатуры, aria-атрибуты и ограничения.

### 5.1. HTML-структура (семантика)

Обычно выпадающее меню — это вложенный `ul` внутри `li`:

```html
<nav class="site-nav">
  <ul>
    <li><a href="#">Главная</a></li>
    <li class="has-sub">
      <a href="#">Каталог</a>
      <ul class="dropdown">
        <li><a href="#">Категория 1</a></li>
        <li><a href="#">Категория 2</a></li>
        <li><a href="#">Категория 3</a></li>
      </ul>
    </li>
    <li><a href="#">Контакты</a></li>
  </ul>
</nav>
```

- `li.has-sub` — маркер, что у пункта есть подменю. Очень удобно для стилей `::after` и для JS (если он понадобится).

### 5.2. Базовый CSS-приём (показ/скрытие через `display`)

Простейший подход — скрывать подменю с помощью `display: none` и показывать на `:hover`.

```css
.site-nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
}
.site-nav li {
  position: relative;
  display: inline-block;
}
.site-nav .dropdown {
  position: absolute;
  left: 0;
  top: 100%;
  display: none; /* скрыто по умолчанию */
  background: white;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}
.site-nav li:hover > .dropdown {
  display: block; /* показ при наведении */
}
```

**Проблемы `display`:**

- `display` нельзя анимировать — внезапное появление/исчезновение без плавности.
- `display: none` исключает элемент из потока и из таб-индекса, поэтому фокусировка на скрытый элемент невозможна.

### 5.3. Более плавный способ: `visibility` + `opacity` + `transform`

Чтобы сделать анимацию плавной и сохранить возможность перехода фокуса, лучше менять `opacity`/`visibility` и использовать `transform`:

```css
.site-nav .dropdown {
  position: absolute;
  left: 0;
  top: 100%;
  opacity: 0;
  visibility: hidden;
  transform: translateY(8px);
  transition: opacity 0.18s ease, transform 0.18s ease;
}
.site-nav li:hover > .dropdown,
.site-nav li:focus-within > .dropdown {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}
```

**Пояснения:**

- `visibility: hidden` + `opacity: 0` — скрывают элемент визуально, но элемент остаётся в DOM, и некоторые браузеры могут позволить фокусироваться (комбинация важна).
- `transform` помогает дать эффект подъёма.
- `transition` обеспечивает плавность.

### 5.4. Поддержка клавиатуры: `:focus-within`

Чисто hover-реакция плохо работает для клавиатуры и на touch-устройствах. CSS предоставляет `:focus-within` — срабатывает, когда внутри элемента есть фокус (например, пользователь табом попал на ссылку внутри `li`), поэтому можно раскрывать подменю и в этом случае:

```css
.site-nav li:focus-within > .dropdown {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}
```

**Результат:** пользователь табом попадает на пункт `Каталог` (`<a>` внутри `li`), `li:focus-within` становится истинным, и подменю раскрывается — после этого таб продвигается в подпункты. Это даёт базовую поддержку клавиатуры _без JS_.

### 5.5. aria-атрибуты — что добавить в HTML (и почему)

Для лучшей доступности полезно добавить атрибуты:

- `aria-haspopup="true"` — у родительской ссылки, чтобы указать, что есть подменю.
- `aria-expanded="false"` / `aria-expanded="true"` — указывают, раскрыто меню или нет (для динамики нужен JS, но полезно иметь начальное значение `false`).
- `role="menu"` / `role="menuitem"` — для сложных меню, но нужно осторожно: aria-роль меняет ожидания ассистивных технологий; использовать их только когда действительно реализуется меню-поведение (включая клавиатурные стрелки).

Пример:

```html
<li class="has-sub">
  <a href="#" aria-haspopup="true" aria-expanded="false">Каталог</a>
  <ul class="dropdown" role="menu">
    ...
  </ul>
</li>
```

**Примечание:** без JS `aria-expanded` статично; в продакшене JS должен переключать его в соответствии с видимостью подменю.

### 5.6. Touch-устройства и \:hover

На мобильных устройствах `:hover` часто не работает так, как на десктопе. Некоторые браузеры симулируют hover при первом тапе — но поведение непредсказуемо. Поэтому:

- используйте `:focus-within`, чтобы раскрытие происходило после фокуса (первый тап фокусирует ссылку).
- всё равно лучше добавлять небольшую логику на JS для надёжного UX на тачах (например, первый тап раскрывает подменю, второй — переходит по ссылке).

### 5.7. Ограничения CSS-only dropdowns

Pure-CSS dropdown возможен и подходит для простых меню, но:

- сложная клавиатурная навигация (стрелки вверх/вниз, Esc для закрытия) требует JS;
- управление `aria-expanded` и объявление состояния пользователю — тоже требует JS;
- для мобильных и «edge cases» (многоуровневые меню, закрытие при клике вне меню) нужен JavaScript.

Итого: **CSS-only — хороший старт и учебный кейс**, но для полноценного, доступного и предсказуемого меню в продакшене нужен JS.

---

## 6. Пошаговые примеры (короткие, но рабочие) и объяснения почему так

### Пример A — простое горизонтальное меню с hover и focus

```html
<nav class="site-nav">
  <ul>
    <li><a href="#">Главная</a></li>
    <li><a href="#">Каталог</a></li>
    <li><a href="#">Контакты</a></li>
  </ul>
</nav>
```

```css
.site-nav ul {
  list-style: none;
  margin: 0;
  padding: 0;
  text-align: center;
}
.site-nav li {
  display: inline-block;
}
.site-nav a {
  display: inline-block;
  padding: 10px 14px;
  color: #333;
  text-decoration: none;
}
.site-nav a:hover,
.site-nav a:focus,
.site-nav a:focus-visible {
  background: #eee;
  color: #000;
  outline: none;
}
.site-nav a:active {
  transform: translateY(1px);
}
```

**Почему так:**

- `inline-block` даёт контроль размеров ссылок;
- `text-align:center` у родителя центрирует меню;
- hover/focus объединены для одинакового визуального отклика, обеспечивая доступность.

### Пример B — dropdown с плавным появлением + focus-within

```html
<nav class="site-nav">
  <ul>
    <li><a href="#">Главная</a></li>
    <li class="has-sub">
      <a href="#" aria-haspopup="true">Каталог</a>
      <ul class="dropdown">
        <li><a href="#">Категория A</a></li>
        <li><a href="#">Категория B</a></li>
      </ul>
    </li>
    <li><a href="#">Контакты</a></li>
  </ul>
</nav>
```

```css
.site-nav li {
  position: relative;
  display: inline-block;
}
.site-nav .dropdown {
  position: absolute;
  left: 0;
  top: 100%;
  opacity: 0;
  visibility: hidden;
  transform: translateY(8px);
  transition: opacity 0.15s ease, transform 0.15s ease;
  background: white;
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.08);
  padding: 8px 0;
  min-width: 160px;
}
.site-nav li:hover > .dropdown,
.site-nav li:focus-within > .dropdown {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}
.site-nav .dropdown li {
  display: block;
}
.site-nav .dropdown a {
  display: block;
  padding: 8px 16px;
}
```

**Почему так:**

- использование `opacity/visibility/transform` даёт плавный эффект;
- `focus-within` поддерживает клавиатуру;
- `position: absolute` выводит подменю поверх потока, а `min-width` гарантирует удобную кликабельную зону.

---

## 7. Поддержка клавиатурной навигации — что проверить и как улучшить

Чтобы меню было удобным для пользователей клавиатуры:

1. **Tab order должен охватывать**: пункты верхнего уровня → при раскрытом подменю — пункты подменю. `:focus-within` позволяет добиться этого без JS, если структура верна.
2. **Фокус должен быть видим:** используем `:focus`/`:focus-visible` с заметным стилем.
3. **Esc для закрытия и стрелки для перемещения** — это уже продвинутые кейсы, требующие JS. Рекомендуется добавить базовый JS для управления `aria-expanded` и для обработки Esc/up/down.
4. **Проверка:** тестируйте меню, используя клавишу Tab, Shift+Tab и, при наличии JS, стрелки, чтобы убедиться, что фокус перемещается логично.

---

## 8. Резюме — что важно запомнить

- **Семантика** (`<nav>`) — основа: используйте её, чтобы помочь пользователям и машинам найти меню.
- **Верстка**: для горизонтальной навигации удобно `inline-block` + `text-align:center`; `float` — устаревший, но ещё встречается.
- **Интерактивность**: `:hover` — для мыши, `:focus` / `:focus-visible` — для клавиатуры; всегда давайте явный видимый фокус.
- **Dropdown**: `display` прост, но неанимируем; `opacity/visibility/transform` — даёт плавность и лучше интегрируется с `:focus-within`.
- **Доступность**: `:focus-within` помогает без JS; для полноценной клавиатурной навигации и управления `aria-expanded` нужен JS.
- **Псевдо-элементы** — лёгкий способ добавить иконки/разделители без лишней разметки.

---

## 9. Практические задания по навигации (для закрепления)

Я даю три развёрнутых задания, выполняемых шаг за шагом:

### Упражнение 1 — Простое горизонтальное меню (базовое)

1. Разметьте `<nav><ul><li><a>...</a></li></ul></nav>` с 5 пунктами.
2. Сбросьте `ul` (margin/padding) и уберите маркеры.
3. Сделайте `li` `display:inline-block;`. Центрируйте меню через `text-align:center` у `ul`.
4. Задайте `a` `display:inline-block; padding: 10px 16px;` для удобной кликабельной зоны.
5. Добавьте `:hover` и `:focus` стили — изменение фона и цвета текста.
6. Проверьте клавиатурой: Tab должен проходить по всем пунктам, и фокусный стиль должен быть заметен.

### Упражнение 2 — Меню с декоративными разделителями

1. Возьмите меню из Упражнения 1.
2. Добавьте `li:not(:last-child)::after { content: " | "; color: #ccc; margin-left: 10px; }`.
3. Обеспечьте, чтобы последний элемент не имел разделителя (через `:not(:last-child)`).
4. Оптимизируйте для мелких экранов: на ширине < 480px сделайте `li { display: block; }` (вертикальная навигация).

### Упражнение 3 — CSS-only dropdown с focus support

1. Разметьте меню с пунктом `Каталог`, у которого есть вложенный `ul.dropdown` (3 подпункта). Пометьте `li.has-sub`.
2. Стилизуйте подменю как в примере (opacity/visibility/transform).
3. Добавьте `li:focus-within > .dropdown` чтобы раскрывать меню при клавиатурном фокусе.
4. Добавьте псевдо-элемент `a::after` у `.has-sub > a` чтобы показать caret.
5. Тест: Навигация по клавиатуре — Tab к пункту «Каталог» должен раскрыть подменю, далее Tab — перейти к подпунктам.

---

# Псевдо-классы и псевдо-элементы — детальный разбор

Псевдо-класс и псевдо-элемент — это разные механизмы CSS для выбора или создания «виртуального» состояния/содержимого элемента. Оба — очень полезные инструменты, потому что позволяют управлять отображением без добавления лишней разметки.

- **Псевдо-класс** (`:hover`, `:nth-child()` и т.д.) — это _состояние_ или _структурный селектор_, который выбирает уже существующие элементы в документе на основе состояния, положения или структуры.
- **Псевдо-элемент** (`::before`, `::after`) — это способ _сгенерировать_ виртуальный дочерний элемент и вставить в него контент/декор без изменения HTML.

Важно: псевдо-элемент — это не DOM-элемент в HTML; он создаётся браузером на рендер-уровне. Поэтому не стоит полагаться на него для важного смыслового контента, который обязан видеть/читать экранный читалка.

Важно: **Что такое DOM?**

_DOM (**Document Object Model**, модель объекта документа) — это специальная структура, в которой браузер хранит всю вашу HTML-страницу. Представьте, что браузер превращает HTML-код в большое дерево, где каждый тег становится отдельным "узлом" или "объектом". Это дерево позволяет программам (например, JavaScript) и стилям (CSS) легко находить, изменять или добавлять элементы на страницу._

---

## 1. Псевдо-классы — ключевые и структурные

### Общая идея и отличия

Псевдо-классы позволяют менять стиль в зависимости от **состояния** (например, наведена мышь) или **положения в дереве** (например, первый ребёнок). Они не добавляют в DOM ничего нового — они _выбирают_ элементы для применения стилей.

### 1.1 Состояния взаимодействия (интерактивные)

- `:hover` — когда пользователь навёл курсор мыши на элемент. Полезен для подсветки ссылок, изменения курсора, показа подменю.
- `:focus` — когда элемент получил фокус (обычно через Tab или клик). Крайне важен для доступности.
- `:focus-visible` — более современный и часто полезный псевдо-класс: срабатывает, когда фокус действительно «видим» (например, при навигации клавиатурой), но не при клике мышью. Позволяет отделить стили фокуса для клавиатуры от клика мышью.
- `:active` — состояние при нажатии (mousedown) — часто используется для «нажатой» анимации.
- `:visited` — для уже посещённых ссылок; современные браузеры ограничивают, какие свойства можно изменять по соображениям приватности.

**Почему это важно:** сочетание `:hover` + `:focus` даёт пользователю одинаковый визуальный отклик при наведении мыши и при фокусе клавиатуры — это хорошая практика доступности.

### 1.2 Структурные псевдо-классы

- `:first-child` — выбирает элемент, который является _первым ребёнком своего родителя_.
- `:last-child` — последний ребёнок.
- `:nth-child(n)` — выбирает n-й ребёнок по формуле; принимает выражения: `odd`/`even`, `2n`, `3n+1`, `5` и т.д. Нумерация **1-based** (первый ребёнок — `:nth-child(1)`).
- `:nth-of-type()` — похож на `nth-child`, но считает только элементы одного типа (только `li`, только `tr` и т.д.), полезно когда в родителе смешаны разные теги.
- `:not(selector)` — исключающий псевдо-класс; очень полезен для исключения последнего пункта (`li:not(:last-child)`) и т.п.

**Примеры использования:**

- `li:first-child { font-weight: 700; }` — выделить первый пункт меню.
- `tr:nth-child(even) { background: #f9f9f9; }` — «зебра» в таблицах.
- `ul.menu li:not(:last-child)::after { content: "|"; }` — добавить разделитель между пунктами, но не после последнего.

### Важные нюансы по `:nth-*`

- `:nth-child(2n)` — эквивалент `:nth-child(even)` — выберет 2,4,6...
- `:nth-child(2n+1)` — эквивалент `:nth-child(odd)` — 1,3,5...
- `:nth-of-type()` применяется когда, например, внутри одного контейнера есть и `li` и другие теги — если хотите «зебру» только для `tr`, лучше `tbody tr:nth-child(even)` или `tbody tr:nth-of-type(even)`.

---

## 2. Псевдо-элементы — `::before` и `::after`

### Что это такое и как работают

`::before`/`::after` создают _виртуальный_ дочерний элемент **перед** или **после** содержимого реального элемента. Эти псевдо-элементы участвуют в рендере и могут получать стили (размер, фон, позиционирование), но не существуют в DOM.

**Обязательное правило:** у псевдо-элемента обязательно задано свойство `content` (даже пустая строка `""`), иначе он не будет создан:

```css
li::after {
  content: ""; /* дальше стили */
}
```

### Что удобно делать через псевдо-элементы

- **Кастомные маркеры** вместо стандартных буллетов;
- **Разделители** (вертикальная черта или точка) между пунктами меню;
- **Декоративные иконки** (в т.ч. через `background-image` или через символы Unicode);
- **Caret/стрелка** у пунктов с подменю;
- **Всплывающие подсказки** (но осторожно — для важного содержания лучше реальная разметка).

### Примеры и практические советы

1. **Иконка перед пунктом:**

```css
li::before {
  content: "";
  display: inline-block;
  width: 16px;
  height: 16px;
  background-image: url("icon.svg");
  background-size: contain;
  margin-right: 8px;
  vertical-align: middle;
}
```

2. **Разделитель между пунктами:**

```css
li:not(:last-child)::after {
  content: "|";
  margin-left: 12px;
  color: #ccc;
}
```

3. **Стрелка у подпункта:**

```css
li.has-sub > a::after {
  content: "▾";
  margin-left: 6px;
  transition: transform 0.18s;
}
li.has-sub:hover > a::after {
  transform: rotate(180deg);
}
```

### Что нельзя / чего стоит избегать

- **Не храните смысловой текст** в `::before/::after`. Сгенерированный CSS-контент может не читаться всеми экранными читалками и не доступен для копирования/поиска. Используйте псевдо-элементы только для декорации или второстепенной информации.
- **Не применяйте `::before/::after` к заменяемым элементам** (например, у большинства браузеров псевдо-элементы не работают для `<img>`, `<input type="text">` и т.п.). Лучше применять к контейнерам (`li`, `a`, `div`).
- Если вы используете `::before` для добавления важной метки (например, «новинка»), лучше продублировать смысл в HTML (атрибут или класс) и только визуально оформить через псевдо-элемент.

---

## 3. Применение в реальных задачах: меню, списки, «зебра» таблиц

### Подсветка первого/последнего пункта

```css
ul.menu li:first-child a {
  padding-left: 0.8em;
}
ul.menu li:last-child a {
  padding-right: 0.8em;
}
```

Это полезно, например, если вы хотите убрать или изменить разделитель у первого/последнего пункта.

### Зебра в списках или таблицах

Для визуального разграничения лучше использовать `nth-child(even)`:

```css
ul.features li:nth-child(even) {
  background: #fafafa;
}
```

Или в таблице:

```css
tbody tr:nth-child(even) {
  background: #f9f9f9;
}
tbody tr:hover {
  background: #f1f1f1;
} /* подсветка строки */
```

### `:not()` как удобный инструмент

Вместо `li:last-child::after { display:none }` лучше сразу писать:

```css
li:not(:last-child)::after {
  content: " | ";
}
```

Это лаконично, быстрее читается и не требует отдельного правила «убрать».

---

## 4. Доступность и псевдо-элементы/псевдо-классы

- **Фокус:** всегда добавляйте видимый стиль для `:focus`/`:focus-visible`. Если вы стилизовали `:hover`, не забывайте про `:focus` — многие пользователи навигируют клавишей Tab.
- **Генерируемый контент:** избегайте добавления важной информации через `::before/::after`. Экранные читалки могут не сообщать её, пользователи не смогут скопировать текст.
- **ARIA + стили:** если вы добавляете визуальную индикацию (например, стрелку для подпункта), при динамическом управлении подменю на JS не забудьте синхронизировать `aria-expanded`.

---

## 5. Производительность и специфика селекторов

- В старые времена сложные CSS-селекторы (особенно с `:nth-child` и глубокой вложенностью) могли быть медленнее. В современных браузерах это незначительная проблема для нормального размера меню. Но всё же избегайте избыточной вложенности селекторов и частых пересчетов в анимациях.
- Предпочтительно писать «плоские» и ясные селекторы: `.menu li::after` лучше, чем `.page .nav .menu ul li::after`, если нет необходимости в такой конкретике.

---

## 6. Практики (подробные пошаговые инструкции)

Ниже — три упражнения, каждое с подробными шагами и пояснениями ожидаемого результата. После выполнения студент сможет применять приёмы в реальных проектах.

---

### Практика 1 — Декоративные разделители между пунктами меню через `::after` и `:last-child`

**Цель:** научиться добавлять разделитель у пунктов меню автоматически и убирать его у последнего пункта.

**HTML (структура, которую создают студенты):**

```html
<nav class="site-nav">
  <ul class="menu">
    <li><a href="#">Главная</a></li>
    <li><a href="#">Каталог</a></li>
    <li><a href="#">О нас</a></li>
    <li><a href="#">Контакты</a></li>
  </ul>
</nav>
```

**Шаги (пошагово):**

1. В CSS сбросьте `ul.menu { margin:0; padding:0; list-style:none; text-align:center; }`.
2. Сделайте `li` горизонтальными: `li { display:inline-block; }`.
3. Стили для ссылок: `a { display:inline-block; padding:8px 12px; text-decoration:none; color:#333; }`.
4. Добавьте правило для разделителя:

   ```css
   .menu li:not(:last-child)::after {
     content: "|";
     margin-left: 12px;
     color: #ccc;
   }
   ```

   — используем `:not(:last-child)` чтобы автоматом исключить последний элемент.

5. Проверьте: открыть страницу — между пунктами видна вертикальная черта, после последнего — ничего нет.

**Пояснение «почему так»:**

- Мы используем `::after` для добавления визуального разделителя без изменения HTML (нет лишних `<span>`).
- `:not(:last-child)` гарантирует, что разделитель не появится после последнего пункта. Это более чистое и устойчивое решение, чем добавлять и убирать через два правила.

**Подсказка/вариант:** если разделитель должен быть иконкой (например, маленькая точка), используйте `content: "•";` или `content: url('dot.svg');` и подгоняйте `vertical-align`/`margin`.

---

### Практика 2 — «Зебра» в списке с `:nth-child(even)`

**Цель:** создать четкую визуальную «зебру» (чередование фона) в длинном списке/каталоге.

**HTML (пример):**

```html
<ul class="features">
  <li>Функция A</li>
  <li>Функция B</li>
  <li>Функция C</li>
  <li>Функция D</li>
  <li>Функция E</li>
</ul>
```

**Шаги (пошагово):**

1. Сбросьте базовые отступы: `.features { margin:0; padding:0; list-style:none; }`.
2. Сделайте базовую карточную стилизацию пунктов:

   ```css
   .features li {
     padding: 12px 16px;
     border-bottom: 1px solid #eee;
   }
   ```

3. Добавьте зебру:

   ```css
   .features li:nth-child(even) {
     background-color: #fbfbfb;
   }
   ```

4. Для улучшения UX добавьте hover:

   ```css
   .features li:hover {
     background-color: #f0f8ff;
   }
   ```

5. Проверьте: строки 2,4,... получили светлый фон, при наведении ряд выделяется цветом.

**Пояснение «почему так»:**

- `nth-child(even)` — простой и понятный способ чередования стилей.
- `:nth-child` считает всех детей, поэтому если у вас внутри `ul` есть другие теги (не `li`), лучше использовать `li:nth-child(...)` или `li:nth-of-type(...)` чтобы избежать неожиданного сдвига.

**Вариант:** если нужно «зебру» только в `tbody` таблицы, лучше `tbody tr:nth-child(even)`.

---

### Практика 3 — «Подсказка (новинка)» через `::after` и управление видимостью через класс

**Цель:** показать как добавить текстовую метку через псевдо-элемент, но **делать её видимой только для элементов с определённым классом** — таким образом мы не вставляем лишний текст в HTML, но сохраняем контроль через атрибут/класс.

**HTML (структура):**

```html
<ul class="products">
  <li class="product">Товар A</li>
  <li class="product new">Товар B</li>
  <li class="product">Товар C</li>
  <li class="product new">Товар D</li>
</ul>
```

Здесь класс `.new` отмечает товары-новинки.

**Шаги (пошагово):**

1. Сбросьте базу: `.products { margin:0; padding:0; list-style:none; } .product { padding: 10px; }`.
2. Создайте дефолтный псевдо-элемент пустым (или вообще не создавать):

   ```css
   .product::after {
     content: "";
   }
   ```

   — но это не обязательно; важнее следующий шаг.

3. Сделайте псевдо-элемент содержать надпись только у класса `.new`:

   ```css
   .product.new::after {
     content: " (новинка)";
     color: #c00;
     font-weight: 700;
     margin-left: 6px;
   }
   ```

   — таким образом у `.product` без `.new` псевдо-элемент либо пуст, либо отсутствует, а у `.product.new` появляется текст.

4. Дополнительно можно использовать `data-*` атрибуты и `attr()` — тогда контент берётся прямо из атрибута:

   ```html
   <li class="product" data-badge="новинка">Товар B</li>
   ```

   ```css
   .product::after {
     content: attr(data-badge);
     color: #c00;
     margin-left: 6px;
     display: none; /* по умолчанию скрыт */
   }
   .product[data-badge]::after {
     display: inline;
   }
   ```

   — это даёт гибкость без добавления классов.

**Пояснение «почему так»:**

- Такой подход позволяет _не дублировать_ текст в HTML (если он не нужен скринридерам) и централизованно включать/выключать метки добавлением/удалением класса или атрибута.
- **ВАЖНО:** если метка важна с точки зрения доступности (информирует о функциональном состоянии товара), лучше включать её в HTML реально (например, `<span class="badge">Новинка</span>`), чтобы гарантировать чтение экранными читалками и индексирование поисковиками. Использование `::after` для _чистой декорации_ — нормально; для смыслового содержимого — нежелательно.

---

## Дополнительные рекомендации, советы и «частые ошибки»

1. **Не полагайтесь на псевдо-элементы для важной информации.** Если текст критичен — положите его в HTML.
2. **Контролируйте пробелы и выравнивание.** Когда добавляете `::before` с иконкой, используйте `vertical-align: middle` и подходящие `margin`.
3. **Будьте осторожны с `content: url(...)`.** Вставка через `url()` работает, но поведение и размеры надо контролировать через `display:inline-block; width/height; background-size:contain;` чаще надёжнее использовать `background-image`.
4. **Используйте `:not()` для удобного исключения.** `li:not(:last-child)::after` — часто удобнее, чем писать отдельное правило для `:last-child` чтобы «убрать» разделитель.
5. **Проверяйте в мобильных браузерах.** Некоторые ховеры/фокусы ведут себя иначе на touch-устройствах. Если функционал важен на мобильных, продумайте поведение или добавьте небольшую JS-поддержку.
6. **Порядок селекторов и специфичность.** Псевдо-классы повышают специфичность так же, как класс. Если правило не применяется — проверь `specificity` и порядок в CSS.
7. **Не забывайте про `::marker`** — современный псевдо-элемент для стилизации стандартного маркера списка (`ul li::marker { color: red; font-size: 1.2em; }`) — полезно, но пока не универсален во всех старых браузерах (проверь поддержку).

---

# Вопросы

---

# Домашняя работа

---

[Предыдущий урок](lesson05.md) | [Следующий урок](lesson07.md)
