# Модуль 2. Урок 9. Свойство position (static, relative, absolute, fixed, sticky). Статичное, относительное, абсолютное, фиксированное и sticky позиционирование.

## 1. Введение — что делает `position`

Коротко: свойство `position` определяет **как элемент располагается на странице** — остаётся он в обычном потоке документов или вынимается из него и позиционируется «от руки» с помощью `top/left/right/bottom`. Понимание `position` — одна из базовых умений верстальщика: от этого зависит, как вести себя шапка, всплывающие меню, рекламные блоки и многое другое.

Ниже — быстрый обзор доступных значений (одной строкой) + короткий практический пример, где это обычно используют.

- **`static` — значение по умолчанию.**
  Элемент находится в нормальном потоке, игнорирует `top/left/right/bottom`. Используется почти всегда (параграфы, заголовки, обычные блоки).

- **`relative` — смещение внутри потока.**
  Элемент остаётся в потоке (его место зарезервировано), но визуально можно сместить его с помощью `top/left/...`. Часто применяется как _контекст позиционирования_ для вложенных `absolute`-элементов (например, чтобы привязать баннер к конкретной карточке).

- **`absolute` — вынимает из потока, позиционируется относительно ближайшего «позиционированного» предка.**
  Элемент не занимает места в документе; `top/left` отсчитываются относительно ближайшего предка, у которого `position ≠ static` (иначе — относительно страницы). Применяется для выпадающих меню, подсказок, рекламных баннеров внутри блока.

- **`fixed` — фиксирован относительно окна просмотра (viewport).**
  Элемент «прилипает» к экрану и остаётся на месте при прокрутке. Отлично для кнопки «вверх», плавающего CTA, глобальной шапки — но требует компенсации пространства (иначе перекроет контент). Важно: некорректно работаeт, если предки создают новый containing block (`transform`, `filter` и т.п.) — об этом позже.

- **`sticky` — гибрид `relative` + `fixed`.**
  Ведёт себя как обычный элемент, пока не достигнет заданного отступа (например `top: 0`), затем «прилипает» к этой позиции внутри своего родителя. Отлично для шапок разделов или сайдбаров, которые должны оставаться видимыми пока пользователь в пределах секции.

---

### Небольшой «живой» пример мыслью

- Хочешь, чтобы баннер в углу карточки всегда был внутри этой карточки — сделай `.card { position: relative }` и `.ad { position: absolute; top: 8px; right: 8px }`.
- Хочешь шапку, которая остаётся видимой при прокрутке, но не перекрывает контент — используй `position: sticky; top: 0;` (и убедись, что у родителя нет `overflow: hidden`).

---

### Быстрая демонстрация синтаксиса

```css
/* пример: закреплённая шапка */
header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
}

/* пример: контекст для абсолютного баннера */
.article {
  position: relative;
}
.article .ad {
  position: absolute;
  top: 10px;
  right: 10px;
}

/* пример: «залипший» заголовок раздела */
.section-title {
  position: sticky;
  top: 0;
}
```

---

Отлично — переходим к первому «практическому» значению. Коротко, ясно и с живой демонстрацией.

## 2. `position: static` — «по умолчанию»

**Суть в одной фразе:**
`position: static` — поведение по умолчанию для всех элементов: элемент остаётся в **нормальном потоке** документа, и свойства `top/left/right/bottom` на него **не влияют**.

**Почему это важно:**
Большинство элементов в обычной вёрстке — параграфы, заголовки, блоки — работают в обычном потоке. Только когда нам нужно «вырвать» элемент из потока или сместить его относительно чего-то — мы меняем `position`. Поэтому `static` — это «без магии», предсказуемое поведение, к которому нужно возвращаться и понимать его роль.

---

### Короткая демонстрация

Скопируйте и откройте в браузере этот HTML — он показывает: если элемент остаётся `static` (по умолчанию), `top: 20px` не сработает. Но если вы поменяете `position` на `relative`, то `top` начинает действовать.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Пример position: static</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }

      /* Два блока в нормальном потоке */
      .box {
        width: 300px;
        padding: 16px;
        margin: 12px 0;
        border: 2px solid #2b7;
        background: #eaffea;
      }

      /* Попытка сместить с помощью top — но позиция по умолчанию (static) */
      .box.static {
        /* position: static;  <-- это значение по умолчанию */
        top: 20px; /* Ничего не произойдёт */
        /* left: 20px; -- тоже не сработает */
      }

      /* Контраст: тот же блок, но position: relative — top сработает */
      .box.relative {
        position: relative;
        top: 20px; /* теперь блок визуально смещён вниз на 20px, но место в потоке остаётся зарезервированным */
        border-color: #27f;
        background: #e7f0ff;
      }

      .note {
        color: #555;
        font-size: 0.9rem;
      }
    </style>
  </head>
  <body>
    <h1>Проверка: position: static (по умолчанию)</h1>

    <div class="box static">
      <strong>static (по умолчанию)</strong><br />
      Я — обычный блок в потоке. Я ВСЕГДА остаюсь там, где меня поставили в
      HTML. Свойство <code>top: 20px</code> на меня не действует.
    </div>

    <div class="box relative">
      <strong>relative</strong><br />
      Я тот же блок, но с <code>position: relative</code>. Теперь
      <code>top: 20px</code> смещает меня визуально, но моё исходное место в
      потоке остаётся зарезервированным.
    </div>

    <p class="note">
      Попробуйте в инструментах разработчика убрать
      <code>position: relative</code> у второго блока — вы увидите, что он
      вернётся «на своё место».
    </p>
  </body>
</html>
```

**Что вы увидите:**

- Первый блок (static) — `top:20px` игнорируется, он остаётся строго в потоке.
- Второй блок (relative) — сдвинут вниз на 20px, но место, где он был, остаётся пустым (так как relative **не вынимает** элемент из потока).

---

### Практические заметки и «когда это встречается»

- Большинство элементов в HTML (p, h1, div) имеют `position: static` по умолчанию — это то, с чем вы работаете 90% времени.
- **Не надо** назначать `position: static` явно — это значение по умолчанию. Назначают `relative`, `absolute`, `fixed`, `sticky` только если нужно особое позиционирование.
- Если `top/left/right/bottom` не работают — первое место для проверки: не забыт ли `position` (на элементе или у родителя). Частая ошибка новичков — ожидать, что `top` «подвинет» static-элемент.

---

### Маленькое задание для проверки

1. Создайте два блока `div` в HTML.
2. Для первого задайте `top: 30px` (ничего не произойдёт).
3. Для второго — добавьте `position: relative; top: 30px;` и посмотрите, как он смещается.
4. Объясните своими словами — почему первый не сдвинулся, а второй да.

---

## 3. `position: relative` — смысл и применение

**Коротко:** `position: relative` не вынимает элемент из потока — его место остаётся зарезервированным. Но при этом элемент можно **визуально сдвинуть** с помощью `top/left/right/bottom`. Ещё одно ключевое применение — **создать контекст позиционирования** для потомков с `position: absolute` (т. е. «привязать» абсолютный элемент к этому родителю).

---

### Что происходит, когда вы ставите `position: relative`

- Элемент остаётся в нормальном документном потоке — соседние элементы ведут себя так, как будто ничего не изменилось.
- Однако вы можете задать `top`, `left`, `right`, `bottom` — элемент **визуально сдвинется**, но оригинальное место останется пустым (зарезервированным).
- Кроме того, этот элемент становится «позиционируемым предком» — если внутри него есть `position: absolute` элементы, они будут позиционироваться **относительно этого родителя** (его **padding box**), а не относительно страницы.

---

### Почему это важно — практические кейсы

- **Привязка рекламного баннера или бейджа к карточке:** вы хотите, чтобы маленькая метка всегда находилась в правом верхнем углу карточки — делаете `.card { position: relative }` и `.badge { position: absolute; top: 8px; right: 8px }`.
- **Всплывающие элементы / dropdowns:** пункт меню имеет `position: relative`, а выпадающий список — `position: absolute; top:100%; left:0;` — тогда меню «выпадает» под заголовок пункта.
- **Небольшие визуальные правки:** «поднять» иконку на пару пикселей, сместить блок на несколько пикселей для выравнивания без изменения потока.
- **Контроль наложения:** `position: relative` вместе с `z-index` используется для управления видимостью слоёв (при этом важно помнить про stacking context).

---

### Демонстрация — пример (HTML + CSS)

Скопируйте и откройте в браузере — видно поведение: родитель с `position: relative`, дочерний `absolute` позиционируется относительно него; также показан пример визуального сдвига самого родителя.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Пример position: relative + absolute</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 24px;
        color: #222;
      }

      /* родительский контейнер */
      .card {
        width: 320px;
        padding: 16px;
        margin: 20px 0;
        border: 1px solid #ccc;
        background: #fff;
        position: relative; /* <- ключ: контекст для absolute-потомков */
      }

      /* абсолютный дочерний элемент — привязан к .card */
      .badge {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #ff5a5f;
        color: #fff;
        padding: 6px 10px;
        border-radius: 4px;
        font-weight: bold;
      }

      /* пример: смещение родителя самим собой (relative + top) */
      .lift {
        position: relative;
        top: -6px; /* визуально приподнимает блок вверх, но место остается */
        border-color: #5a9;
        background: #f6fffa;
      }

      .note {
        font-size: 0.9rem;
        color: #555;
        margin-top: 12px;
      }
    </style>
  </head>
  <body>
    <h1>position: relative — демонстрация</h1>

    <div class="card">
      <div class="badge">РЕКЛАМА</div>
      <h2>Карточка товара</h2>
      <p>
        Описание товара коротко. Здесь видно, что бейдж расположен относительно
        самой карточки — даже если карточка переместится, бейдж остаётся на
        своём месте внутри неё.
      </p>
    </div>

    <div class="card lift">
      <h2>Немного приподнятая карточка</h2>
      <p>
        Этот блок визуально поднят на <code>top: -6px;</code>, но место в потоке
        сохраняется и соседние элементы не займут его место.
      </p>
    </div>

    <p class="note">
      Попробуйте убрать <code>position: relative</code> у .card — бейдж
      перестанет быть привязан к карточке и «уедет» к краю страницы.
    </p>
  </body>
</html>
```

**Что видно в примере:**

- `.badge` занимает позицию `top:10px; right:10px` _относительно_ `.card`, потому что `.card` — позиционирован (relative).
- `.lift` демонстрирует: при `position: relative; top:-6px` блок визуально смещается вверх, но промежуток в документе остаётся — соседние элементы не «поднимаются» на его место.

---

### Важные подробности и подводные камни

1. **`relative` не вынимает элемент из потока.**
   Если вы хотите, чтобы блок «не занимал» место, используйте `absolute`/`fixed` — но не `relative`. Новички часто думают, что `relative` подобен `absolute` — это не так.

2. **Для `absolute` потомков нужен позиционированный предок.**
   Если родитель не имеет `position` отличного от `static`, абсолютный потомок будет привязан к ближайшему такому предку или к корню (viewport / html). Поэтому для локального привязывания всегда ставьте `position: relative` у родителя.

3. **Отсчёт `top/left/right/bottom` для `absolute` — от padding-box родителя.**
   Т.е. если у родителя есть `padding`, позиция дочернего с `top: 0; left: 0;` начнётся _внутри_ padding.

4. **`z-index` и relative:**
   Если у позиционированного элемента (relative/absolute/fixed) задан `z-index`, он участвует в порядке наложения. `position: relative` + `z-index` часто используется, чтобы поднять блок над другими.

5. **Проценты в `left/top` у absolute:**
   Если у дочернего `left: 50%`, то это 50% от **ширины containing block** (т.е. родителя с position ≠ static). Часто используют `transform: translateX(-50%)` для точного центрирования.

6. **Не путать с transform:**
   `transform` у родителя может изменить поведение containing block для fixed-потомков — об этом подробнее будет в секции про containing block.

---

### Частые ошибки (и как их исправлять)

- **Ошибка:** не работает dropdown — думаете `top: 100%` должен позиционировать под пунктом.
  **Причина:** забыли `position: relative` у `li`.
  **Решение:** добавить `nav li { position: relative }`.

- **Ошибка:** бейдж «уйдет» в угол окна.
  **Причина:** родитель не позиционирован — абсолютный элемент привязан к `<html>`.
  **Решение:** добавить `position: relative` родителю.

- **Ошибка:** выставили `top` у relative, ожидая что соседние элементы «подвинутся».
  **Пояснение:** relative смещает визуально, но резервирует место — это нормальное поведение. Если нужно, чтобы соседние элементы перестроились — используйте другие подходы (например, изменить margin у родителя или использовать absolute).

---

### Небольшие советы/правила «на практике»

- **Используйте `position: relative` чаще не ради смещения, а ради создания контекста для `absolute` дочерних элементов.** Это самая частая и полезная причина поставить `relative`.
- **Для мелких визуальных корректировок** (на пару пикселей) `relative` — удобный инструмент: не ломает поток, не меняет layout.
- **Планируйте z-index** — если у вас есть поверхностные элементы (модалки, бейджи), заранее определите порядок наложения.

---

### Мини-задание для закрепления

1. Сделайте блок `.card` (ширина ~300px), внутри поместите небольшой текст. Установите `.card` свойство `position: relative`.
2. Внутри `.card` добавьте элемент `.badge` с `position: absolute; top:8px; right:8px;`.
3. Убедитесь, что бейдж «ездит» вместе с карточкой (т.е. при изменении margin карточки бейдж остаётся на месте).
4. Задайте второму блоку `position: relative; top: 10px;` — увидите визуальный подъем, но место в потоке сохранится.
5. Попробуйте удалить `position: relative` у `.card` — посмотрите, куда уедет `.badge` и объясните почему.

---

## 4. `position: absolute` — объяснение и практические кейсы

### Коротко: что делает `absolute`

- Элемент с `position: absolute` **удаляется из нормального потока** — соседние элементы ведут себя так, как будто его нет.
- Его позиция (свойства `top/right/bottom/left`) вычисляется **относительно containing block** — ближайшего предка, у которого `position` ≠ `static` (например `relative`, `absolute`, `fixed` или `sticky`).
- Если такого предка нет — содержащим блоком будет начальный containing block (обычно `<html>`/viewport).
- Смещения (`top/left` и т.д.) отсчитываются от **padding box** этого containing block. Проценты в `top/left` вычисляются от размеров containing block (например `left:50%` — это 50% ширины containing block).

---

### Зачем и где используют `absolute`

Типичные применения:

- **Всплывающие элементы**: dropdown-меню, тултипы (подсказки).
- **Рекламные баннеры** внутри статьи — чтобы «прицепить» рекламный блок к правому верхнему углу конкретной статьи.
- **Внутриконтейнерные overlay**: значки, бейджи, плавающие кнопки внутри карточек.
- **Модальные окна / центрирование overlay** (в сочетании с transform).

---

### Ключевые моменты

1. **Создавайте контекст позиционирования**
   Если хотите, чтобы абсолютный элемент «прилип» к конкретному контейнеру, сделайте родителю `position: relative;` (или любое другое значение, отличное от `static`). Тогда `top: 0; left: 0;` будет означать «совсем в левом верхнем углу этого родителя».

2. **Absolute не влияет на поток**
   Абсолютный элемент не занимает место — он может перекрыть соседние блоки. Если этот элемент нужен для визуального эффекта, продумайте, как не сломать читаемость (например, добавить внутренний отступ `padding` у родителя или резерв-слой).

3. **Проценты для offset**
   `left: 50%` — это 50% **ширины** containing block, не ширины самого элемента. Частая техника центрирования:

   ```css
   left: 50%;
   transform: translateX(-50%);
   ```

   — смещаем точку по середине, затем двигаем сам элемент на половину его ширины назад.

4. **Transform / filter / perspective могут влиять на контекст**
   Некоторые CSS-свойства (например, `transform`, `filter`, `perspective`, `will-change`) могут создавать новые контексты наложения (stacking context) и влиять на поведение фиксированных/абсолютных элементов в некоторых ситуациях. Если элемент ведёт себя «не как ожидалось», проверьте стили предков.

5. **z-index**
   Чтобы управлять порядком наложения, используйте `z-index`. Но помните: `z-index` работает в пределах stacking context — иногда кажется, что z-index «не действует», потому что родитель создал отдельный stacking context.

---

### Демонстрация 1 — рекламный баннер в правом верхнем углу статьи

**Что показываем:** баннер всегда внутри статьи (не относительно страницы); при прокрутке он не фикcирован — остаётся в рамках статьи.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Absolute: рекламный баннер</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        line-height: 1.5;
      }
      .article {
        width: 700px;
        margin: 0 auto 40px;
        padding: 24px;
        border: 1px solid #ddd;
        background: #fff;
        position: relative; /* <- контекст для .ad */
      }
      .ad {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 160px;
        padding: 10px;
        background: linear-gradient(180deg, #fffae6, #fff1d6);
        border: 1px solid #e6c07a;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.06);
      }
      .content p {
        margin: 0 0 12px;
      }
    </style>
  </head>
  <body>
    <article class="article">
      <div class="ad">
        Рекламный баннер<br /><small>Место для рекламы</small>
      </div>

      <h1>Заголовок статьи</h1>
      <div class="content">
        <p>
          Первый абзац статьи. Lorem ipsum dolor sit amet, consectetur
          adipiscing elit.
        </p>
        <p>
          Второй абзац статьи. Sed do eiusmod tempor incididunt ut labore et
          dolore magna aliqua.
        </p>
        <p>
          Третий абзац — побольше текста, чтобы увидеть, как баннер остаётся в
          верхнем углу статьи.
        </p>
      </div>
    </article>
  </body>
</html>
```

**Пояснение:** `.article` — `position: relative`, поэтому `.ad` — `position: absolute; top:12px; right:12px` — находится внутри данной статьи. Если убрать `position: relative` у `.article`, баннер «прыгает» к углу страницы.

---

### Демонстрация 2 — dropdown-меню (nav → li → ul.dropdown)

**Что показываем:** выпадающее меню, которое «выпадает» под пункт nav.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Absolute: Dropdown</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
      nav {
        background: #222;
        color: #fff;
        padding: 10px;
      }
      nav ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }
      nav li {
        display: inline-block;
        position: relative;
        margin-right: 12px;
      }
      nav a {
        color: #fff;
        text-decoration: none;
        padding: 6px 10px;
        display: inline-block;
      }

      /* Dropdown: абсолютное позиционирование относительно li */
      .dropdown {
        position: absolute;
        top: 100%; /* сразу под кнопкой */
        left: 0;
        min-width: 160px;
        background: #fff;
        color: #222;
        border: 1px solid #ccc;
        display: none; /* скрыто по умолчанию */
      }
      nav li:hover .dropdown {
        display: block;
      } /* простая CSS-логика открытия */
      .dropdown li {
        display: block;
        padding: 8px 10px;
      }
      .dropdown li:hover {
        background: #f3f3f3;
      }
    </style>
  </head>
  <body>
    <nav>
      <ul>
        <li><a href="#">Главная</a></li>
        <li>
          <a href="#">Сервисы ▾</a>
          <ul class="dropdown">
            <li><a href="#">Услуга 1</a></li>
            <li><a href="#">Услуга 2</a></li>
            <li><a href="#">Услуга 3</a></li>
          </ul>
        </li>
        <li><a href="#">О нас</a></li>
      </ul>
    </nav>
  </body>
</html>
```

**Пояснение:** `nav li` — `position: relative`. `.dropdown` — `position: absolute; top:100%; left:0;` → выпадает под пункт. `top:100%` — это 100% высоты родителя (li), поэтому меню располагается сразу под ним.

---

### Демонстрация 3 — центрирование абсолютного элемента

**Что показываем:** классический приём центрирования модального окна/overlay: `left:50% top:50%` + `transform: translate(-50%,-50%)`.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Absolute: Центрирование</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 40px;
      }
      .wrap {
        position: relative;
        height: 300px;
        border: 1px dashed #ccc;
      }
      .modal {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 320px;
        padding: 18px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        background: #fff;
        border-radius: 6px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="modal">
        <h3>Модальное окно</h3>
        <p>
          Пример центрирования абсолютного блока внутри родителя с position:
          relative.
        </p>
      </div>
    </div>
  </body>
</html>
```

**Пояснение:** Центрирование делаем не `margin-left:-width/2` (неудобно), а вычисляем левую/верхнюю точку по containing block (`50%`), затем смещаем сам элемент на половину его размеров с помощью `transform`.

---

### Демонстрация 4 — что если нет позиционированного родителя

**Что показываем:** absolute позиционируется относительно документа (viewport), если у никакого предка `position` ≠ `static`.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Absolute: без позиционированного родителя</title>
    <style>
      body {
        padding: 20px;
        font-family: Arial, sans-serif;
      }
      .floating {
        position: absolute;
        top: 20px;
        right: 20px;
        background: #ffdede;
        padding: 8px 12px;
        border: 1px solid #ff9a9a;
      }
      /* контейнер без position: relative */
      .box {
        border: 1px solid #ccc;
        padding: 16px;
        margin-top: 60px;
      }
    </style>
  </head>
  <body>
    <div class="box">
      <div class="floating">
        Я прикреплён к странице (нет родителя с position)
      </div>
      <p>Контейнер без position: relative</p>
    </div>
  </body>
</html>
```

**Пояснение:** `.floating` позиционируется относительно начального containing block (страницы), а не какого-то внутреннего контейнера.

---

### Практические проблемы и как их решать

1. **Баннер перекрывает текст** — решение: дать родителю padding, либо менять layout так, чтобы было зарезервировано место; либо использовать `position: fixed` только если нужно всегда быть видимым.
2. **Dropdown выходит за пределы окна** — используйте JS или CSS-логики для переключения позиций (например, `left: auto; right: 0;` если выходит справа), или применять `max-height` + `overflow:auto` для длинных списков.
3. **`z-index` не помогает** — проверьте, не создал ли предок новый stacking context (например `transform`, `opacity < 1`, `position` с z-index).
4. **Absolute неожиданно «прилип» к предку с transform** — проверьте наличие `transform`/`filter`/`will-change` у предков — они могут изменить поведение фиксированных и наложенных элементов. Если хотите, чтобы элемент позиционировался относительно viewport, уберите transform у предка или переместите элемент в другое место DOM.
5. **Процентные offsets непредсказуемы** — помните: процент в `left/top` считается от **размеров containing block**.

---

### Рекомендации по организации верстки при использовании `absolute`

- Всегда **осознавайте**: кто является containing block. Если нужен локальный контекст — ставьте `position: relative` на родителя.
- Для элементов, которые не должны перекрывать основной контент, заранее резервируйте место через `padding` или блок-обёртки.
- Для popup/dropdown делайте скрытие через `display:none` или `visibility`/`opacity`, а показ — с переходом/анимацией; это влияет на поведение и доступность (keyboard focus).
- Используйте `transform: translate(...)` для точных смещений и центрирования (без ломки потока).

---

### Мини-практика

1. **Баннер в статье**

   - Создайте блок `.article` с `position: relative` и текстом внутри. Добавьте `.ad` с `position: absolute; top: 12px; right: 12px;`. Убедитесь, что при изменении ширины `.article` баннер остаётся привязанным к уголку статьи.

2. **Dropdown**

   - Сделайте горизонтальное `nav`. Для пункта с подменю добавьте `position: relative` и подпунктам `position: absolute; top:100%; left:0;`. Реализуйте открытие подменю при `:hover`.

3. **Центрированное модальное окно**

   - В родителе с `position: relative` создайте `.modal { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); }`. Добавьте кнопку, которая показывает/скрывает модальное окно (можно просто сделать видимым по умолчанию).

---

## 5. `position: fixed` — объяснение и сравнение

**Коротко:** `position: fixed` вынимает элемент из нормального потока и привязывает его к _viewport_ (окну просмотра). Элемент остаётся на том же месте экрана при прокрутке — идеально для глобальных элементов интерфейса (шапка, кнопка «вверх», плавающий CTA).

---

### Что важно знать (ключевые акценты)

1. **Fixed — относительно viewport.**
   По умолчанию `position: fixed` игнорирует предков и всегда позиционируется относительно окна браузера: `top/left/right/bottom` меряются от границ viewport.

2. **Исключение (ловушка — containing block):**
   Если у **какого-то предка** задано CSS-свойство, создающее новый контекст (например `transform`, `filter`, `perspective`, `will-change: transform`, или в некоторых случаях `contain`), то поведение может измениться: фиксированный элемент будет позиционироваться **относительно этого предка**, а не от viewport. Это частая и неприятная «ловушка» — проверяйте стили предков, если `fixed` вдруг «приклеился» к контейнеру.

3. **Перекрытие контента — компенсация нужна.**
   Фиксированный header перекроет верхнюю часть страницы. Чтобы контент не «ушёл под шапку», обычно добавляют отступ у `body`/`main` (`padding-top`) равный высоте шапки. Альтернативы — использовать `position: sticky` для header (если задача — оставаться в потоке до прилипания) или динамически вычислять высоту через JS.

4. **Производительность:**
   Много `position: fixed` элементов с анимациями, постоянными repaint’ами или heavy shadows может ухудшать работу на мобильных устройствах. Для анимации фиксированных элементов лучше использовать `transform` и `opacity` (GPU), избегать изменения layout-свойств (top/left) в анимированных циклах.

5. **z-index:**
   Фиксированные элементы обычно должны иметь высокий `z-index`, чтобы быть поверх остального. Но помните про stacking context — если предок создал его (например, через `transform`), то z-index будет работать внутри этого контекста.

---

### Демонстрация 1 — Плавающая кнопка (CTA) справа снизу

Классический «заказать звонок» или «наверх».

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fixed CTA</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.5;
        padding: 24px;
      }

      /* Плавающая кнопка — всегда видна */
      .cta {
        position: fixed;
        right: 20px;
        bottom: 20px;
        z-index: 9999; /* выше большинства элементов страницы */
        background: #ff6b6b;
        color: white;
        padding: 12px 18px;
        border-radius: 28px;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18);
        text-decoration: none;
        font-weight: 600;
      }

      /* Длинный контент, чтобы скроллить */
      .content {
        max-width: 700px;
        margin: 0 auto;
      }
      .content p {
        margin: 1rem 0;
      }
    </style>
  </head>
  <body>
    <div class="content">
      <h1>Демо: fixed CTA</h1>
      <!-- много текста -->
      <p>Здесь длинный текст… (скрольте вниз)</p>
      <!-- вставьте несколько абзацев для прокрутки -->
      <p>Lorem ipsum dolor sit amet...</p>
      <p>...</p>
      <p>...</p>
    </div>

    <a class="cta" href="#contact">Заказать звонок</a>
  </body>
</html>
```

**Комментарий:** кнопка всегда видна и не влияет на поток страницы. Убедитесь, что у нее адекватный `z-index` и что она не закрывает важную информацию на мобильных экранах.

---

### Демонстрация 2 — Fixed header и проблема перекрытия контента

Если вы делаете фиксированную шапку — не забывайте компенсировать её высоту.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fixed header — компенсация</title>
    <style>
      body {
        margin: 0;
        font-family: Arial, sans-serif;
      }

      header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 64px;
        background: linear-gradient(90deg, #2b6, #159);
        color: white;
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 1000;
      }

      /* Компенсация: отступ сверху = высота header */
      main {
        padding-top: 64px; /* важно — иначе контент окажется под header */
      }

      .content {
        max-width: 900px;
        margin: 20px auto;
      }
    </style>
  </head>
  <body>
    <header>Фиксированная шапка сайта</header>
    <main>
      <div class="content">
        <h1>Контент страницы</h1>
        <p>
          Если убрать padding-top у main, то заголовок и первые абзацы окажутся
          под шапкой.
        </p>
        <p>Дальше — много текста...</p>
      </div>
    </main>
  </body>
</html>
```

---

### Демонстрация 3 — «Ловушка»: transform превращает fixed в «локальный» (привязка к предку)

Пример: если у родителя задан `transform`, некоторые браузеры сделают этот родитель containing block для фиксированных потомков.

```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fixed внутри трансформированного родителя</title>
    <style>
      body {
        margin: 0;
        font-family: Arial, sans-serif;
      }

      /* контейнер с transform — создаёт контекст */
      .frame {
        transform: translateZ(
          0
        ); /* часто используется для "усиления" рендеринга */
        border: 6px solid #eee;
        margin: 30px;
        padding: 20px;
        height: 600px;
        overflow: auto;
      }

      /* Этот элемент обычно должен быть привязан к viewport,
     но из-за transform родителя он будет привязан к .frame в некоторых браузерах */
      .fixed-inside {
        position: fixed;
        top: 10px;
        right: 10px;
        background: #ffcc00;
        padding: 8px 12px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <div class="frame">
      <div class="fixed-inside">Я кажусь fixed — но приклеен к .frame</div>
      <p>Длинный контент внутри .frame...</p>
      <p>
        Прокрутите внутри блока и посмотрите: поведение может быть неожиданным.
      </p>
      <!-- больше контента -->
    </div>
    <p>Вне .frame этот fixed не виден — проверьте в браузере.</p>
  </body>
</html>
```

**Комментарий:** если вы видите такое поведение — ищите `transform`/`filter`/`will-change` на предках. Уберите или переместите фиксированный элемент вне такого предка, если нужно поведение относительно viewport.

---

### Производительность и анимации

- Избегайте анимирования `top/left` у фиксированных элементов в циклах (это вызывает reflow). Для плавных анимаций используйте `transform: translate()` и `opacity`.
- `will-change` помогает браузеру подготовить оптимизации, но злоупотребление им создаёт проблемы (потребляет память). Применяйте только к часто анимируемым свойствам и снимайте после окончания анимации.
- Тяжёлые тени и большие фиксированные элементы на мобильных устройствах могут тормозить — упрощайте стили.

---

### Доступность и UX: на что обратить внимание

- **Не закрывайте важный контент.** Фиксированные элементы не должны блокировать элементы управления (кнопки, формы).
- **Keyboard / focus:** фиксированные панели и popups должны корректно работать с клавиатурой (tab order).
- **Skip links:** при fixed header добавьте «skip to content» ссылку, чтобы улучшить доступ клавиатурных пользователей.
- **Anchor links:** для якорей (`#anchor`) добавьте `html { scroll-padding-top: var(--header-h); }` или используйте `scroll-margin-top` на целевых элементах, чтобы заголовок не перекрывал якорь.

Пример:

```css
html {
  scroll-padding-top: 64px;
} /* чтобы anchor-скролл учитывал фикс.шапку */
```

---

### Частые ошибки и как их исправлять

- **Ошибка:** fixed header перекрыл контент → **Решение:** добавить `padding-top` на корневой несмещаемый блок (main/body) или использовать `sticky`.
- **Ошибка:** fixed ведёт себя как будто привязан к контейнеру → **Причина:** предок имеет `transform`/`filter`/`will-change`. **Решение:** убрать transform или вынести fixed-элемент в другой уровень DOM.
- **Ошибка:** кнопки fixed закрывают интерактивные элементы на мобильных — **Решение:** уменьшить размер/переместить элемент, давать пользователю возможность закрыть CTA.
- **Ошибка:** анимации fixed вызывают лаги — **Решение:** анимировать `transform`/`opacity`, а не `top/left`.

---

### Небольшие практические задания

1. Сделайте фиксированную кнопку справа внизу экрана (CTA). Убедитесь, что она видна при прокрутке и имеет адекватный `z-index`.
2. Сделайте фиксированную шапку высотой 72px. Скомпенсируйте перекрытие, добавив `padding-top: 72px` для `main`.

---

## Практика (самостоятельно)

**Задача** — сверстать простую страницу с навигацией, статьями и фиксированной кнопкой, применяя разные типы позиционирования.

### Шаги:

1. Создай структуру страницы:

   - `header` с навигацией (`nav > ul > li > a`).
   - `main`, внутри которого размести две статьи (`article`) с картинками.
   - кнопку в правом нижнем углу страницы.

2. Сделай так, чтобы элементы навигации (`li > a`) располагались горизонтально. Используй для этого выравнивание текста по центру и строчно-блочные элементы.

3. Добавь в навигацию выпадающее меню (dropdown):

   - у одного из пунктов должен быть вложенный список (`ul`).
   - вложенное меню должно изначально быть скрыто и появляться при наведении.
   - для позиционирования этого меню используй **абсолютное позиционирование**.

4. Закрепи `header` в верхней части страницы с помощью **липкого позиционирования**. При прокрутке он должен оставаться сверху.

5. Внутри `main` сделай два блока-статьи:

   - каждая статья должна содержать заголовок, текст и картинку.
   - для картинок задай внешние отступы.

6. Добавь в правый нижний угол страницы кнопку.

   - используй **фиксированное позиционирование**, чтобы кнопка всегда оставалась на одном месте при прокрутке.

7. Проверь работу страницы:

   - меню появляется при наведении;
   - шапка «прилипает» сверху при прокрутке;
   - кнопка всегда закреплена в углу.

---

### Подсказка для студентов (чеклист по позиционированию):

- Выпадающее меню → **absolute**
- Шапка сайта (header) → **sticky**
- Кнопка в углу → **fixed**
- Основные статьи и картинки → обычное расположение (**static**)

---

## Вопросы

1. Какое значение свойства `position` используется по умолчанию у всех элементов?
2. Что делает свойство `position: relative` по отношению к статическому положению элемента?
3. Может ли элемент с `position: relative` «вылезти» за пределы родителя?
4. К чему привязывается элемент с `position: absolute`?
5. Что произойдет, если у элемента с `position: absolute` нет позиционированного предка?
6. Чем отличается `position: fixed` от `position: absolute`?
7. Что делает `position: sticky` и чем оно отличается от `fixed`?
8. Для чего в навигации часто используют абсолютное позиционирование?
9. Если нужно закрепить кнопку в правом нижнем углу экрана, какое значение свойства `position` лучше всего использовать?
10. Почему важно понимать работу разных режимов позиционирования при вёрстке?

---

[Предыдущий урок](lesson08.md) | [Следующий урок](lesson10.md)