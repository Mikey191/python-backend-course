# Модуль 3. Урок 20. Создание пользовательского менеджера модели

Когда мы работаем с базой данных через Django ORM, мы постоянно используем вызовы вроде:

```python
Movie.objects.all()
Movie.objects.filter(...)
Movie.objects.get(...)
```

Обрати внимание на слово `objects` — это и есть **менеджер модели**.

Он управляет запросами к базе данных и предоставляет интерфейс для получения, фильтрации и изменения данных.

Но иногда стандартного поведения бывает недостаточно.

Например, нам может понадобиться, чтобы на главной странице сайта отображались **только опубликованные фильмы**, а не все подряд.

Конечно, мы можем каждый раз писать:

```python
Movie.objects.filter(is_published=True)
```

но это неудобно и захламляет код.

> Решение? — создать **собственный менеджер модели**.

---

## Что такое менеджер модели

**Менеджер** — это объект, через который Django обращается к базе данных.

По умолчанию он называется `objects`, но мы можем создавать и свои собственные менеджеры с нужной логикой.

Например, менеджер, который возвращает только опубликованные фильмы.

---

## Добавляем флаг публикации

Для начала добавим в модель `Movie` поле `is_published`.

Оно будет показывать, опубликован фильм или нет.

```python
from django.db import models
from django.urls import reverse

class Movie(models.Model):
    title = models.CharField(max_length=255, verbose_name="Название")
    slug = models.SlugField(max_length=255, unique=True, verbose_name="URL")
    description = models.TextField(blank=True, verbose_name="Описание")
    release_year = models.IntegerField(default=2000, verbose_name="Год выпуска")
    is_published = models.BooleanField(default=True, verbose_name="Опубликован")

    def __str__(self):
        return self.title

    def get_absolute_url(self):
        return reverse('movie', kwargs={'movie_slug': self.slug})
```

Теперь создаём миграции и применяем их:

```bash
python manage.py makemigrations
python manage.py migrate
```

После этого в админке у каждого фильма появится галочка “Опубликован”.

---

## Проблема: фильтрация в представлении

Допустим, у нас есть главная страница со списком фильмов (`views.py`):

```python
def index(request):
    movies = Movie.objects.all()
    return render(request, 'movies/index.html', {'movies': movies})
```

Проблема в том, что здесь показываются **все** фильмы — даже те, которые ещё не опубликованы.

Можно, конечно, добавить фильтр вручную:

```python
movies = Movie.objects.filter(is_published=True)
```

Но представь, что таких мест в коде десятки — постоянно дублировать одну и ту же фильтрацию неудобно и небезопасно.

Поэтому правильнее — вынести эту логику в **кастомный менеджер**.

---

## Создание пользовательского менеджера

Откроем `models.py` и создадим класс менеджера:

```python
class PublishedManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_published=True)
```

Здесь мы переопределили стандартный метод `get_queryset()`, который возвращает набор всех записей.

Теперь этот менеджер будет возвращать только опубликованные фильмы.

---

## Подключаем менеджер к модели

Добавим его в класс `Movie`:

```python
class Movie(models.Model):
    ...
    objects = models.Manager()      # стандартный менеджер
    published = PublishedManager()  # наш новый менеджер
```

> ⚠️ Важно!
> Когда вы добавляете пользовательский менеджер, Django **заменяет стандартный `objects`**.
> Поэтому, если вы хотите сохранить возможность работать с полным набором записей, обязательно объявляйте `objects = models.Manager()` отдельно.

---

## Проверяем работу менеджера

Теперь можно протестировать его в Django Shell:

```bash
python manage.py shell
```

```python
from movies.models import Movie

Movie.objects.all()        # Вернёт все фильмы (опубликованные и нет)
Movie.published.all()      # Вернёт только опубликованные фильмы
```

Если всё сделано правильно, вы увидите, что второй запрос возвращает только фильмы, где `is_published=True`.

---

## Используем менеджер в представлении

Теперь изменим функцию `index()` в `views.py`:

```python
def index(request):
    movies = Movie.published.all()
    return render(request, 'movies/index.html', {'movies': movies})
```

Теперь при загрузке страницы Django будет отображать **только опубликованные** фильмы — без лишних фильтров в коде.

---

## Проверяем в браузере

1. Зайдите в админку и снимите галочку “Опубликован” у одного из фильмов.
2. Откройте главную страницу `/movies/`.
3. Фильм с `is_published=False` больше не отображается.
4. Верните галочку — и фильм снова появится на сайте.

Таким образом, менеджер работает как встроенный фильтр, автоматически убирая “черновики”.

---

## Добавляем перечисляемое поле (Enum)

Чтобы сделать код более читаемым, вместо `is_published=True/False` можно использовать **перечисление состояний (Enum)**.

```python
class Movie(models.Model):
    class Status(models.IntegerChoices):
        DRAFT = 0, 'Черновик'
        PUBLISHED = 1, 'Опубликовано'

    title = models.CharField(max_length=255, verbose_name="Название")
    slug = models.SlugField(max_length=255, unique=True, verbose_name="URL")
    description = models.TextField(blank=True, verbose_name="Описание")
    release_year = models.IntegerField(default=2000, verbose_name="Год выпуска")
    status = models.IntegerField(choices=Status.choices, default=Status.DRAFT)

    objects = models.Manager()
    published = models.Manager()

    def __str__(self):
        return self.title
```

Теперь мы можем обновить наш менеджер:

```python
class PublishedManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(status=Movie.Status.PUBLISHED)
```

И всё продолжит работать точно так же, только теперь значения статуса более понятны и читаемы.

---

## Частые ошибки

1. **Ошибка: `'Manager' object has no attribute 'filter'`**
   — Обычно возникает, если вы случайно вызвали `Movie.published.filter` до объявления `PublishedManager`, или если не создали объект менеджера внутри модели.

2. **Ошибка: `'PublishedManager' object has no attribute 'get_queryset'`**
   — Проверьте, что ваш класс менеджера наследуется от `models.Manager`, а не от `models.Model`.

3. **Фильтрация не работает**
   — Возможно, вы забыли применить миграции или опечатались в названии поля (`is_published` / `status`).

---

## Почему менеджеры — это важно

**Менеджеры** — это мощный инструмент Django, который позволяет выносить бизнес-логику из представлений в модели.

Таким образом, код становится:

- **чистым** — нет дублирования фильтров;
- **удобным** — можно использовать один и тот же менеджер в разных частях проекта;
- **расширяемым** — вы можете создавать разные менеджеры для разных ситуаций (например, “премьеры”, “по жанрам”, “по году” и т.д.).

---

## Практические задания

1. Создайте кастомный менеджер `DraftManager`, который возвращает только черновики фильмов (`status = DRAFT`).
2. Добавьте на сайт страницу `/drafts/`, где будут отображаться только черновики фильмов.
3. Реализуйте в модели `Genre` менеджер `with_movies()`, который возвращает только те жанры, в которых есть хотя бы один опубликованный фильм.
4. Добавьте метод в модель `Movie`, который будет возвращать True/False в зависимости от статуса публикации (`is_published()`).
5. Проверьте через Django Shell, что ваш менеджер действительно возвращает только нужные записи.

---

## Вопросы для самопроверки

1. Что такое менеджер модели в Django и зачем он нужен?
2. Какой менеджер создаётся Django по умолчанию?
3. Как создать пользовательский менеджер и подключить его к модели?
4. Что делает метод `get_queryset()` внутри менеджера?
5. Почему при создании пользовательского менеджера важно явно указать `objects = models.Manager()`?
6. Как проверить работу менеджера в Django Shell?
7. Какое преимущество у перечисляемых типов (`IntegerChoices`) по сравнению с булевыми полями?
8. Можно ли использовать несколько менеджеров в одной модели?
9. Что произойдёт, если не вернуть `super().get_queryset()` в методе `get_queryset()`?
10. Почему использование менеджеров повышает читаемость и надёжность кода?

---

[Предыдущий урок](lesson19.md) | [Следующий урок](lesson21.md)
