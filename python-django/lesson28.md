# Модуль 5. Урок 28. Методы выбора записей в Django ORM: first(), last(), exists(), count()

При работе с Django ORM мы уже научились выбирать записи из базы данных с помощью `filter()`, `exclude()`, `get()`, `Q`, сортировок и различных lookup-выражений. Теперь пора познакомиться с методами, которые помогают удобно работать с _результатом_ выборки: находить первый и последний элементы, проверять существование записей, получать их количество.

Эти методы используются постоянно — как в небольших сайтах, так и в крупных проектах уровня сервиса подбора фильмов **cinemahub**.

---

## 1. Методы first() и last()

Иногда нам важно получить **одну конкретную запись** из набора: первую или последнюю.

Например:

- показать самый старый фильм;
- получить последний добавленный отзыв;
- найти первое совпадение в отсортированной выборке.

Django предоставляет удобные методы:

### `first()`

возвращает _первый объект из QuerySet_ или `None`, если записей нет.

### `last()`

возвращает _последний объект_, также может вернуть `None`.

---

### 1.1 Как работает first()

```python
Movie.objects.first()
```

Что сделает Django:

1. выполнит запрос `LIMIT 1`
2. вернёт объект `Movie`
3. если записей нет — вернёт `None` (не ошибку)

Это очень удобно, в отличие от `get()`, который вызывает исключение, если объект не найден.

---

### 1.2 first() зависит от сортировки

Если сортировка не указана, Django сортирует по `pk`:

```python
Movie.objects.order_by("pk").first()
Movie.objects.order_by("-pk").first()
```

> Важно: порядок сортировки — ключевой фактор.

Например, если отсортировать по рейтингу:

```python
Movie.objects.order_by("-rating").first()
```

Мы получим фильм с самым высоким рейтингом.

---

### 1.3 Пример с фильтрацией

```python
Movie.objects.filter(is_published=True).first()
```

Вернёт **первый опубликованный фильм**.

---

### 1.4 Проверка результата в браузере

Создадим временное представление:

```python
def test_first(request):
    movie = Movie.objects.order_by("-rating").first()
    return HttpResponse(movie.title if movie else "Фильмов нет")
```

Маршрут:

```python
path("test-first/", test_first)
```

Проверяем в браузере:

```
http://localhost:8000/test-first/
```

---

## 2. Метод last()

Метод `last()` работает аналогично, но возвращает последнюю запись.

```python
Movie.objects.order_by("pk").last()
```

Пример:

```python
Movie.objects.filter(rating__gte=7).last()
```

---

### 2.1 Особенность last()

Если сортировка не указана, Django выполнит:

```sql
ORDER BY id DESC LIMIT 1
```

Но если сортировка есть, например:

```python
Movie.objects.order_by("title").last()
```

То результат будет:

> фильм, который идёт последним в алфавитном порядке.

---

## 3. Методы latest() и earliest()

Эти методы работают только по полям даты или даты-времени.

Например, в `Movie` есть поле:

```python
created_at = models.DateTimeField(auto_now_add=True)
```

Теперь можем:

### **Получить фильм с самой поздней датой создания**:

```python
Movie.objects.latest("created_at")
```

### **Самую раннюю запись**:

```python
Movie.objects.earliest("created_at")
```

---

### 3.1 Отличие latest() и last()

- `last()` работает по сортировке QuerySet
- `latest()` работает _по полю даты_

Это разные задачи:

| Метод                  | Что делает                  |
| ---------------------- | --------------------------- |
| `last()`               | последняя запись в QuerySet |
| `latest("created_at")` | запись с максимальной датой |

---

## 4. get*next_by* и get*previous_by*

Django автоматически генерирует методы в формате:

```
get_next_by_<имя_поля>()
get_previous_by_<имя_поля>()
```

Только для полей `DateField` / `DateTimeField`.

Например:

```python
movie = Movie.objects.get(pk=10)
movie.get_next_by_created_at()
movie.get_previous_by_created_at()
```

Django ищет ближайшую запись по дате.

---

### 4.1 Фильтры внутри метода

```python
movie.get_previous_by_created_at(rating__gte=7)
```

— вернёт предыдущий фильм среди тех, у кого рейтинг ≥ 7.

---

### 4.2 Возможные ошибки

#### Ошибка 1: поля даты нет

Если написать:

```python
movie.get_next_by_rating()
```

Получим:

```
FieldError: Movie has no field named 'rating'
```

#### Ошибка 2: нет предыдущей / следующей записи

Django выбросит исключение `DoesNotExist`.

Поэтому безопаснее оборачивать в try/except.

---

## 5. Метод exists()

Этот метод проверяет, есть ли записи в QuerySet.

Пример:

```python
Movie.objects.filter(rating__gte=9).exists()
```

Вернёт:

- `True`, если есть хотя бы одна запись
- `False`, если записей нет

---

### 5.1 Пример с жанрами (RelatedManager)

Допустим, есть жанр:

```python
genre = Genre.objects.get(pk=3)
genre.movies.exists()
```

Если у жанра нет фильмов — вернёт `False`.

---

### 5.2 Почему exists() лучше, чем len()

Плохой вариант:

```python
if len(Movie.objects.filter(rating__gte=9)) > 0:
```

Причина:

> Django загрузит **все записи** в память.

✔ Правильный вариант:

```python
if Movie.objects.filter(rating__gte=9).exists():
```

Django выполнит оптимизированный SQL:

```sql
SELECT (1) AS a FROM movie WHERE rating >= 9 LIMIT 1;
```

---

## 6. Метод count()

Возвращает количество записей в QuerySet.

Пример:

```python
Movie.objects.count()
```

С фильтрацией:

```python
Movie.objects.filter(is_published=True).count()
```

С related_name:

```python
genre.movies.count()
```

Это быстрый способ посчитать записи — он не загружает объекты.

---

### 6.1 Потенциальная ошибка: путать count() и len()

```python
len(Movie.objects.filter(rating__gte=8))
```

— загружает _все объекты_.

```python
Movie.objects.filter(rating__gte=8).count()
```

— делает быстрый SQL-запрос.

---

## 7. Практическая проверка в браузере

Создадим вьюху, которая покажет количество опубликованных фильмов:

```python
def test_count(request):
    cnt = Movie.objects.filter(is_published=True).count()
    return HttpResponse(f"Опубликованных фильмов: {cnt}")
```

Маршрут:

```python
path("test-count/", test_count)
```

Открываем:

```
http://localhost:8000/test-count/
```

---

## 8. Практические задания

Все задания выполняются на моделях cinemahub: `Movie`, `Genre`, `Review`, `Director`, и т.п.

### Задание 1

Вывести **название первого фильма**, отсортированного по рейтингу по убыванию.

---

### Задание 2

Получить **последний опубликованный фильм**, сортируя по id.

---

### Задание 3

Проверить, существуют ли фильмы с рейтингом выше 9.

---

### Задание 4

Вывести количество фильмов жанра «комедия» (genre.slug="comedy").

---

### Задание 5

Для фильма с id=10 получить:

- следующую запись по дате создания
- предыдущую запись по дате создания

(предварительно обработать исключения)

---

### Задание 6

Вывести количество фильмов, которые ещё не опубликованы.

---

### Задание 7

Получить самый ранний созданный фильм (earliest), но сначала отсортировать по названию.

---

## Вопросы

1. В чём ключевое отличие first() от get()?
2. Что вернёт first(), если записей нет?
3. Когда лучше использовать last(), а когда latest()?
4. Какие поля нужны для методов latest() и earliest()?
5. Что делает метод exists()?
6. Почему len(queryset) — плохая практика?
7. Чем отличается `genre.movies.count()` от `Movie.objects.filter(genre=genre).count()`?
8. Какие ошибки могут возникнуть при вызове get*next_by*<field>?
9. Можно ли использовать first() без сортировки?
10. Возвращает ли count() объекты модели?

---

[Предыдущий урок](lesson27.md) | [Следующий урок](lesson29.md)
