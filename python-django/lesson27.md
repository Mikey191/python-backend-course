# Модуль 5. Урок 27. ORM-команды с классом Q в Django

Работа с базой данных редко ограничивается простыми запросами. В реальных проектах — включая наш **cinemahub**, где есть фильмы, жанры, режиссёры, актеры — разработчику нужно формировать гибкие запросы: выбирать фильмы по нескольким условиям, комбинировать фильтры, исключать часть записей, добавлять альтернативные условия.

До этого момента мы использовали в ORM Django только стандартный синтаксис:

```python
Movie.objects.filter(is_published=True, rating__gte=7)
```

Но важно понимать: такой вызов всегда формирует **логическое И (`AND`)**.

Если написать:

```python
Movie.objects.filter(rating__gte=7, genre_id=3)
```

Это означает:

> Найти фильмы, у которых рейтинг ≥ 7 **и одновременно** жанр = 3.

Однако иногда нам нужно:

- выбрать записи по логическому **ИЛИ (`OR`)**
- исключить часть результатов с помощью **НЕ (`NOT`)**
- комбинировать сложные условия
- группировать фильтры внутри скобок
- строить гибкие построения, похожие на полноценный SQL

И вот здесь в игру вступает **класс `Q`**.

---

## 1. Что такое Q-объекты

Класс `Q` (из `django.db.models`) позволяет работать с логическими операторами:

| Оператор | Логика | Описание             |                  |
| -------- | ------ | -------------------- | ---------------- |
| `&`      | AND    | логическое «и»       |                  |
| `        | `      | OR                   | логическое «или» |
| `~`      | NOT    | логическое отрицание |                  |

Особенность `Q`:

- позволяет использовать скобки
- позволяет строить альтернативные ветки поиска (OR)
- может объединяться между собой

Импорт:

```python
from django.db.models import Q
```

---

## 2. Простое сравнение: filter() vs Q()

До:

```python
Movie.objects.filter(rating__gte=7, genre_id=3)
```

Это всегда **AND**, альтернативы нет.

Но если нам нужно выбрать:

> фильмы с рейтингом ≥ 8 **ИЛИ** фильмы жанра «комедия»

Невозможно написать так:

```python
Movie.objects.filter(rating__gte=8 | genre_id=2)   # ОШИБКА
```

С Django так работать нельзя.

Правильный способ:

```python
Movie.objects.filter(Q(rating__gte=8) | Q(genre_id=2))
```

---

## 3. Практика: Пишем первый запрос с Q

Предположим, в проекте cinemahub есть модель `Movie`:

```python
class Movie(models.Model):
    title = models.CharField(max_length=200)
    rating = models.FloatField(default=0)
    genre = models.ForeignKey(Genre, on_delete=models.CASCADE)
    is_published = models.BooleanField(default=True)
```

Выполним запрос:

```python
from django.db.models import Q
Movie.objects.filter(Q(rating__gte=8) | Q(is_published=False))
```

Смысл:

> Получить фильмы с рейтингом ≥ 8 **или** фильмы, которые ещё не опубликованы.

Проверка в браузере (пока простая):

1. В `views.py` создаём временное представление:

```python
from django.http import HttpResponse
from django.db.models import Q
from .models import Movie

def test_q(request):
    movies = Movie.objects.filter(Q(rating__gte=8) | Q(is_published=False))
    return HttpResponse(', '.join([m.title for m in movies]))
```

2. В `urls.py` добавляем маршрут:

```python
path("test-q/", test_q)
```

3. Открываем в браузере:

```
http://localhost:8000/test-q/
```

Если всё настроено — увидим список фильмов через запятую.

---

## 4. Использование AND (`&`)

Сформируем запрос:

> Найти фильмы, у которых рейтинг ≥ 7 **и** жанр = 3.

```python
Movie.objects.filter(Q(rating__gte=7) & Q(genre_id=3))
```

Это аналог обычного `filter(rating__gte=7, genre_id=3)`
Но: `Q` позволяет добавить в эти условия «скобки» или вложенность.

---

## 5. Использование NOT (`~`)

Иногда нам нужно исключить часть результатов.

Например:

> выбрать все фильмы, кроме тех, у которых рейтинг ниже 6

```python
Movie.objects.filter(~Q(rating__lt=6))
```

То же самое, что:

```python
Movie.objects.exclude(rating__lt=6)
```

---

## 6. Комбинирование условий

Допустим, мы хотим выбрать:

> фильмы жанра 1 **ИЛИ** фильмы жанра 3
> но только те, чей рейтинг ≥ 7

Нужно соблюсти порядок:

- сначала OR,
- затем AND

```python
Movie.objects.filter(
    (Q(genre_id=1) | Q(genre_id=3)) & Q(rating__gte=7)
)
```

Без скобок логика будет другой.

---

## 7. Важный момент: порядок аргументов

Некорректный код:

```python
Movie.objects.filter(title__icontains="man", Q(rating__gte=8) | Q(genre_id=2))
```

Django выдаст ошибку:

> TypeError: Cannot filter a query once a slice has been taken

Причина: `Q`-объекты всегда должны быть **перед обычными аргументами**.

Правильно:

```python
Movie.objects.filter(
    Q(rating__gte=8) | Q(genre_id=2),
    title__icontains="man"
)
```

---

## 8. Смешивание Q и обычных фильтров

Допустим, у нас задача:

> фильмы со словами «star» в названии
> и (жанр = 1 ИЛИ рейтинг ≥ 9)

Правильный вариант:

```python
Movie.objects.filter(
    Q(genre_id=1) | Q(rating__gte=9),
    title__icontains="star"
)
```

---

## 9. Построение сложных логических группировок

Пример:

> фильмы, у которых (рейтинг < 5 ИЛИ жанр = 4)
> и при этом фильм опубликован

```python
Movie.objects.filter(
    (Q(rating__lt=5) | Q(genre_id=4)) & Q(is_published=True)
)
```

---

## 10. SQL-аналогия

Запрос:

```python
Movie.objects.filter(Q(rating__lt=5) | Q(genre_id=4), is_published=True)
```

Преобразуется в SQL:

```sql
WHERE (rating < 5 OR genre_id = 4) AND is_published = TRUE
```

---

## 11. Частые ошибки студентов

### **Ошибка 1. Использование Q после обычных аргументов**

```python
Movie.objects.filter(title__icontains="man", Q(rating__gte=8))
```

**Исправление:**

```python
Movie.objects.filter(Q(rating__gte=8), title__icontains="man")
```

---

### **Ошибка 2. Лишние скобки меняют логику**

```python
(Q(a) | Q(b)) & Q(c)
```

и

```python
Q(a) | (Q(b) & Q(c))
```

— это разные выражения.

---

### **Ошибка 3. Попытка передать OR без Q**

```python
Movie.objects.filter(rating__gte=8 | genre_id=2)
```

**Исправление только через Q:**

```python
Movie.objects.filter(Q(rating__gte=8) | Q(genre_id=2))
```

---

### **Ошибка 4. Нельзя применять оператор `|` к строкам или полям**

```python
Q(title="Star") | "Wrong"
```

Работают только Q-объекты.

---

## 12. Практические задания

### Задание 1

Выбрать все фильмы, у которых рейтинг выше 7 **или** жанр имеет id = 5.
Вывести названия в браузере.

---

### Задание 2

Выбрать фильмы жанров 2 и 3 **или** фильмы со словом «love» в названии.

---

### Задание 3

Выбрать все фильмы, кроме тех, которые ещё не опубликованы.

Используйте оператор `~`.

---

### Задание 4

Выбрать фильмы со словом «star» в названии, но только те, у которых:

- рейтинг ≥ 8
- жанр = 1 **или** жанр = 4

---

### Задание 5

Составить запрос:

> фильмы, у которых рейтинг ниже 4
> **или** фильмы, жанр которых 2,
> но при этом фильм опубликован и содержит слово «man».

---

## Вопросы

1. Для чего используется класс `Q` в Django ORM?
2. Какая разница между `filter(a=1, b=2)` и `filter(Q(a=1) & Q(b=2))`?
3. Какие операторы можно использовать с Q-объектами?
4. Почему этот код неверный?

   ```python
   Movie.objects.filter(title__icontains="star", Q(rating__gte=8))
   ```

5. Как записать логическое отрицание с использованием Q-объекта?
6. Что означает этот запрос?

   ```python
   Movie.objects.filter(Q(genre_id=1) | Q(genre_id=3), rating__gte=7)
   ```

7. Как в ORM Django написать условие «жанр = 2 ИЛИ рейтинг >= 8»?
8. Может ли Q-объект комбинироваться с обычными аргументами filter? Если да — в каком порядке?
9. Что произойдёт, если забыть скобки в сложном выражении Q?
10. Можно ли использовать Q-объекты вместе с `.exclude()`?

---

[Предыдущий урок](lesson26.md) | [Следующий урок](lesson28.md)
