# Обобщающая практика — проект **Cinemahub (movies app)**

**Ожидаемый результат:** рабочий проект `cinemahub` с одним приложением `movies`. В конце у вас будут следующие возможности (не исчерпывающий список): главная страница, список фильмов, страница фильма (динамический URL), страница жанров (slug), архив по году (пользовательский конвертер), поиск через GET, добавление фильма через POST (проверка в Postman) и редиректы с использованием `reverse`. Будет реализован пользовательский обработчик 404.

Время выполнения: разбейте на 6–8 занятий по 30–60 минут.

---

## Шаг 0 — подготовка (проверка окружения)

Задача: подготовить рабочую папку и инструменты.

* Установить Python 3.10+ и создать папку `cinemahub_project`.
* Создать и активировать виртуальное окружение (`venv`).
* Установить Django: `pip install django`.
* Подготовить VS Code (или другой редактор) и открыть проект в нём.
* Запустить `django-admin startproject cinemahub` и перейти в папку проекта.
* Запустить `python manage.py runserver` и убедиться, что стартовая страница Django работает.

**Контроль:** в браузере открывается `http://127.0.0.1:8000/` — видите приветственную страницу Django.

**Подсказка:** делать всё в виртуальном окружении; если `runserver` жалуется на порт — либо укажите другой порт `runserver 8001`, либо завершите процесс, занимающий порт.

---

## Шаг 1 — создать приложение `movies` и зарегистрировать его

Задача: создать приложение и зарегистрировать в `INSTALLED_APPS`.

* Выполните: `python manage.py startapp movies`.
* Откройте `cinemahub/settings.py` и добавьте `'movies.apps.MoviesConfig'` в `INSTALLED_APPS`.
* Откройте структуру проекта и изучите файлы приложения (`views.py`, `urls.py` пока нет, `models.py`, `admin.py`).

**Контроль:** сервер работает; ошибок нет; приложение зарегистрировано (ошибок при запуске нет).

**Подсказка:** если забудете зарегистрировать — при попытке импортировать приложение маршруты/модули могут не подхватиться.

---

## Шаг 2 — структура проекта и главный `urls.py`

Задача: вынести маршруты приложения в отдельный файл.

* В `cinemahub/urls.py` подключите `include` и добавьте маршрут `path('movies/', include('movies.urls'))`.
* Создайте файл `movies/urls.py` и подготовьте его (пока только пустой список `urlpatterns = []`).

**Контроль:** при загрузке `http://127.0.0.1:8000/movies/` страница 404 (потому что маршруты не настроены) — это нормально пока. Главное — приложение подключено без ошибок.

**Подсказка:** порядок маршрутов в `cinemahub/urls.py` важен: `admin/` ставим выше, затем подключение приложений.

---

## Шаг 3 — первые представления: index и список фильмов

Задача: реализовать базовые представления и проверить их в браузере.

* В `movies/views.py` создайте представление `index` — возвращает приветственную строку `Добро пожаловать в Cinemahub!`.
* Добавьте в `movies/urls.py` маршрут `path('', views.index, name='home')`.
* Создайте представление `movies_list`, которое пока возвращает текст `Список фильмов (пока заглушка)`, и подключите его к `path('list/', views.movies_list, name='movies_list')`.

**Контроль:**

* `http://127.0.0.1:8000/movies/` — должна показываться главная строка;
* `http://127.0.0.1:8000/movies/list/` — заглушка списка фильмов.

**Подсказка:** используйте `name` для маршрутов — это пригодится для `reverse` и `redirect`.

---

## Шаг 4 — динамические URL: страница фильма по id и по slug

Задача: создать динамический маршрут для страницы фильма (id) и для «человеческих» URL (slug).

* В `movies/urls.py` добавьте:

  * `path('<int:film_id>/', views.movie_detail_by_id, name='movie_detail_by_id')`
  * `path('<slug:film_slug>/', views.movie_detail_by_slug, name='movie_detail_by_slug')`
* Реализуйте в `views.py` соответствующие функции, которые принимают `film_id` или `film_slug` и возвращают `HttpResponse` с отображением переданного параметра.

**Контроль:**

* Откройте `http://127.0.0.1:8000/movies/42/` → видите `ID фильма: 42`.
* Откройте `http://127.0.0.1:8000/movies/the-dark-knight/` → видите `Slug фильма: the-dark-knight`.

**Подсказка:** обратите внимание на порядок: если у вас числовой маршрут и затем slug, порядок решает, кто сработает раньше. Поставьте более специфичный путь выше, если нужно.

---

## Шаг 5 — пользовательский конвертер: архив по году

Задача: реализовать конвертер для 4-значного года и маршрут `/movies/archive/<year>/`.

* В корневой папке проекта (или в `movies/`) создайте `converters.py` с классом `FourDigitYearConverter` (regex для 4 цифр, `to_python` → `int`, `to_url` → форматирование).
* Зарегистрируйте его через `register_converter` в соответствующем файле `urls.py`.
* Добавьте маршрут `path('archive/<year4:year>/', views.archive, name='archive')`.
* В `views.archive` возвращайте ответ, показывающий число и выполняйте `print()` в консоли для проверки (мы не используем дебаггер).

**Контроль:**

* Откройте `http://127.0.0.1:8000/movies/archive/2021/` — увидите страницу `Архив фильмов за 2021 год`.
* В консоли сервера должно печататься `Архив за 2021` (проверка преобразования `to_python`).

**Подсказка:** используйте `print()` для быстрой проверки значений, т.к. отладка через IDE ещё не была затронута.

---

## Шаг 6 — GET-запрос: поиск фильмов

Задача: сделать обработчик GET-параметров (поиск).

* Реализуйте `views.search` и маршрут `path('search/', views.search, name='search')`.
* В `search`:

  * Прочитайте параметры через `request.GET`.
  * Используйте `get('q', '')` или `getlist('genre')`.
  * Верните `HttpResponse`, показывающий запрошенные значения.
* Проверка в браузере: `http://127.0.0.1:8000/movies/search/?q=matrix&genre=sci-fi&genre=action`.

**Контроль:** в консоли и на странице видите `q=matrix` и список жанров.

**Подсказка:** продемонстрируйте `request.GET.getlist('genre')` — это важно для множественных значений.

---

## Шаг 7 — POST-запрос: добавление фильма (проверка через Postman)

Задача: реализовать обработчик POST-запросов и протестировать через Postman.

* Создайте `views.add_movie` и маршрут `path('add/', views.add_movie, name='add_movie')`.
* В `add_movie`:

  * Если `request.method == 'POST'`: прочитайте `request.POST` и сделайте `print()` для вывода полей (например `title`, `year`).
  * Верните `HttpResponse("Фильм добавлен")` и выполните `redirect()` на страницу списка фильмов (используйте `reverse()` для вычисления URL).
  * Если метод НЕ POST — вернуть сообщение `Ожидается POST-запрос`.
* В Postman создайте POST-запрос к `http://127.0.0.1:8000/movies/add/` с `form-data` полями `title`, `year`. Отправьте — смотрите вывод в консоли и ответ.

**Контроль:**

* Postman показывает ответ `Фильм добавлен`.
* Серверная консоль печатает `QueryDict` с полями.
* После успешного добавления происходит перенаправление на `movies_list` (проверьте это в Postman: в Network или в браузере).

**Подсказка:** используйте `redirect('movies_list')` или `redirect(reverse('movies_list'))` — покажите оба варианта.

---

## Шаг 8 — ручная генерация и обработка 404

Задача: настроить пользовательскую страницу 404 и продемонстрировать `raise Http404`.

* В `cinemahub/views.py` (или `movies/views.py`) реализуйте `page_not_found(request, exception)` — возвращает `HttpResponseNotFound("<h1>Страница не найдена — Cinemahub</h1>")`.
* В `cinemahub/urls.py` объявите `handler404 = 'movies.views.page_not_found'` (или путь к месту реализации).
* Сделайте простую вьюшку `views.get_film_or_404(request, film_id)` которая:

  * Проверяет `if film_id > 1000: raise Http404('Фильм не найден')` — демонстрация.
  * Иначе возвращает `HttpResponse(...)`.
* Проверьте в браузере `http://127.0.0.1:8000/movies/9999/` — должна сработать страница 404 с вашим сообщением.

**Контроль:** 404-страница отображается корректно; при `DEBUG = True` поведение немного другое (стандартная отладочная страница) — объясните студентам различие.

**Подсказка:** для локальной тренировки оставьте `DEBUG=True`, но покажите, как настроить `ALLOWED_HOSTS` и значение `DEBUG=False` для понимания боевых условий.

---

## Шаг 9 — использование `reverse()` и редиректов в логике

Задача: практическое применение `reverse()`.

* В `views.add_movie`, вместо редиректа по строке, используйте:

  * `from django.urls import reverse`
  * `url = reverse('movies_list')`
  * `return redirect(url)`
* Также сделайте представление `redirect_to_random`:

  * выбирает (временно: из списка ID) случайный film id и делает `redirect('movie_detail_by_id', film_id)`, используя `reverse()` с `args` или `kwargs`.
* Проверьте работу в браузере: `/movies/random/` → перенаправление на `/movies/<id>/`.

**Контроль:** проверка в браузере — редирект сработал и адрес соответствует имени маршрута.

**Подсказка:** покажите `reverse('movie_detail_by_slug', kwargs={'film_slug': 'inception'})`.

---

## Шаг 10 — итоговая проверка и README

Задача: оформить краткий README и проверить весь набор фич шаг за шагом.

* В корне проекта создайте `README.md` (кратко: как запускать, какие роуты реализованы и как их тестировать).
* Пройдите чеклист ниже и отметьте пункты.

**Итоговый чеклист (студент отмечает Done):**

* [ ] Проект `cinemahub` создан и запускается (`runserver`).
* [ ] Приложение `movies` создано и зарегистрировано.
* [ ] Главная страница приложения `/movies/` отображается.
* [ ] Маршрут `/movies/list/` — список фильмов (заглушка).
* [ ] Динамические маршруты `/movies/<int:id>/` и `/movies/<slug:slug>/` работают.
* [ ] Конвертер года `/movies/archive/<4-digit-year>/` работает и печатает значение в консоли.
* [ ] GET-параметры: `/movies/search/?q=...&genre=...` корректно обрабатываются.
* [ ] POST через Postman к `/movies/add/` отправляет поля и происходит редирект.
* [ ] Кастомная страница 404 отображается при несуществующем ресурсе.
* [ ] Редиректы реализованы с использованием `redirect()` и `reverse()`.

---

## Дополнительные (необязательные) задания — расширения

(на выбор, для закрепления)

1. **Сделать простую модель `Movie`** (поля: `title`, `year`, `slug`, `description`, `rating`) и подключить SQLite миграциями — затем заменить заглушки на реальные запросы ORM (это выходит за границы модуля, но хорошее развлечение).
2. **Отображение списка фильмов через HTML-шаблон** (`Template`) — вместо `HttpResponse` вернуть `render(request, 'movies/list.html', context)`.
3. **Форма добавления фильма в браузере** (POST из HTML-формы), с CSRF токеном.
4. **Добавить фильтрацию GET по нескольким полям** (genre + year) и показать результаты.
5. **Локальное хранилище постеров** — подключить `STATIC` и `MEDIA` (введение в статику/медиа будет позже).

---

## Оценочные критерии (для преподавателя)

* Студент успешно создал и запустил проект и приложение.
* Реализованы базовые маршруты и представления.
* Динамические URL и пользовательский конвертер работают корректно.
* GET и POST обработка продемонстрирована (GET в браузере, POST через Postman).
* Применены `redirect()` и `reverse()` в логике.
* Наличие README и пройденный чеклист.

---

## Подсказки для преподавателя / типичные ошибки и как их объяснить

* **Ошибка ImportError при подключении include** — проверьте правильность импорта `from django.urls import path, include`.
* **Маршрут “не найден”** — порядок в `urlpatterns` или забытый `name`/`include`.
* **POST возвращает GET-заглушку** — проверьте метод запроса в Postman (`POST`) и headers/Content-Type.
* **Редирект не работает, URL неправильный** — проверьте `reverse()` args/kwargs и имя маршрута.
* **404 не показывает кастомную страницу при DEBUG=True** — объяснить разницу поведения между DEBUG True/False.

---

Если хочешь, я могу:

* Сформировать **шаблон README** с краткой инструкцией запуска и описанием роутов (готовый текст), или
* Подготовить **вариант задания в формате checklist с местом для ответов студента** (например, что вставить в поле “Что сделано”),
* Или дать **вариант тестовых данных** (10 фильмов/сериалов) в виде JSON для последующего импорта в модель `Movie`.

Какой из этих допов добавить сейчас?
