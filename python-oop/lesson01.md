# Модуль 1. Урок 1. Концепция объектно-ориентированного программирования (ООП) простыми словами

## Зачем вообще нужен ООП

К моменту начала этого курса ты уже умеешь писать программы на Python.
Ты знаешь, что такое переменные, условия, циклы, функции, умеешь работать со строками, списками, словарями, файлами. Более того — с помощью этих инструментов **можно написать программу практически любой сложности**.

И здесь закономерно возникает вопрос:

> Если и так можно писать сложные программы, зачем нужен объектно-ориентированный подход?

Исторически — **ООП не появилось из-за недостатка возможностей процедурного программирования**. Оно появилось из-за сложности поддержки и развития больших программ.

До 1960–1970-х годов программы были относительно небольшими.
Но со временем программные системы начали расти:

* тысячи и десятки тысяч строк кода;
* множество взаимосвязанных сущностей;
* команды из нескольких разработчиков;
* долгосрочная поддержка и развитие проекта.

И в какой-то момент стало очевидно:
**код нужно уметь не только писать, но и удобно читать, расширять и сопровождать**.

ООП — это не «обязательный стиль», а **способ мышления о программе**, который помогает:

* структурировать код;
* объединять данные и логику;
* уменьшать количество ошибок;
* писать расширяемые и поддерживаемые системы.

---

## Программа как набор объектов

Почти в любой реальной задаче мы работаем не просто с абстрактными числами и строками, а с **объектами предметной области**.

Примеры:

* интернет-магазин → товар, корзина, заказ, пользователь;
* CRM → клиент, компания, сделка, статус;
* игра → персонаж, оружие, уровень, враг;
* учет животных → кот, собака, ветеринарная карта.

Возьмём простой пример: **программа для учёта котов**.

Каждый кот в реальной жизни обладает:

* именем;
* породой;
* возрастом;
* поведением (может «мяукать», «есть», «спать»).

В процедурном стиле мы могли бы хранить эти данные так:

```python
cat_name = "Барсик"
cat_breed = "Британец"
cat_age = 3
```

А если котов станет десять? Сто? Тысяча?
Появятся списки, словари, индексы, связанные между собой структуры.

ООП предлагает более естественную модель:

* **описать кота как целостную сущность**;
* работать с ним как с единым объектом.

---

## Класс и объект: ключевая идея ООП

### Класс — это шаблон

**Класс** — это описание того, *каким должен быть объект*.

Проще всего представить класс как:

* чертёж;
* форму;
* инструкцию по созданию объектов.

Например, класс `Cat` может описывать, какие данные и действия есть у кота.

Схематично это можно представить так:

```
Класс Cat
 ├─ name
 ├─ breed
 └─ age
```

### Объект — это конкретный экземпляр

**Объект** — это конкретная реализация класса.

```
Объекты класса Cat
 ├─ Cat(name="Барсик", breed="Британец", age=3)
 ├─ Cat(name="Мурка", breed="Сиамская", age=5)
 └─ Cat(name="Рыжик", breed="Дворовый", age=2)
```

Все объекты:

* созданы по одному шаблону;
* имеют одинаковую структуру;
* но содержат разные данные.

---

## Данные и поведение в одном месте

Важнейшая особенность ООП:
**класс объединяет данные и поведение**.

### Атрибуты — это данные

Атрибуты описывают состояние объекта:

* имя;
* возраст;
* координаты;
* статус;
* баланс.

### Методы — это поведение

Методы — это функции, которые:

* принадлежат классу;
* работают с его объектами;
* имеют доступ к их данным.

Пример концептуально:

```python
class Cat:
    name
    breed
    age

    def meow():
        ...
```

То есть:

* объект **знает свои данные**;
* объект **сам умеет с ними работать**.

Это принципиально отличает ООП от набора разрозненных функций.

---

## Почему это удобно на практике

Рассмотрим реальный пример.

Представим программу, которая отображает **несколько независимых графиков функций** в одном окне.

Без ООП:

* куча глобальных данных;
* сложные структуры;
* дублирование логики;
* высокая вероятность ошибок.

С ООП:

* создаётся класс `Graph`;
* каждый график — это объект этого класса;
* логика масштабирования, перемещения и отрисовки хранится внутри.

```
Graph
 ├─ data
 ├─ scale
 ├─ position
 ├─ draw()
 ├─ move()
 └─ zoom()
```

Каждый график работает независимо, но по единой логике.
Один класс — множество объектов.

---

## Инкапсуляция: скрываем внутреннюю реализацию

### Аналогия с реальным миром

Когда ты садишься за руль автомобиля, тебе не нужно знать:

* как работает двигатель;
* как передаётся крутящий момент;
* как устроена тормозная система на уровне механики.

Тебе доступны:

* руль;
* педали;
* коробка передач.

Всё остальное **скрыто внутри**.

### То же самое в ООП

**Инкапсуляция** — это принцип, согласно которому:

* внутренние детали класса скрыты;
* наружу выставляется только нужный интерфейс.

Схематично:

```
[ Внешний код ]
       ↓
[ Публичные методы ]
       ↓
[ Внутренняя логика и данные ]
```

Зачем это нужно:

* защита от некорректного использования;
* снижение количества ошибок;
* упрощение работы с классом;
* возможность менять реализацию без изменения внешнего кода.

В Python инкапсуляция реализуется мягко (об этом подробно будет во 2 модуле), но сама идея — фундаментальна.

---

## Наследование: переиспользование и расширение

Теперь рассмотрим следующую важную концепцию.

Представим графический редактор:

* линия;
* прямоугольник;
* эллипс.

Каждая фигура имеет:

* координаты;
* толщину линии;
* цвет.

Если писать каждый класс отдельно — появится дублирование.

Решение — **базовый класс**:

```
Figure
 ├─ coords
 ├─ width
 └─ color
```

И дочерние классы:

```
Line     → Figure
Rect     → Figure
Ellipse  → Figure
```

**Наследование** позволяет:

* вынести общее в базовый класс;
* расширять функциональность в дочерних классах;
* соблюдать принцип DRY (Don't Repeat Yourself).

---

## Полиморфизм: единый интерфейс для разных объектов

Самая мощная идея ООП — **полиморфизм**.

Допустим, у каждой фигуры есть метод `draw()`:

* `Line.draw()`
* `Rect.draw()`
* `Ellipse.draw()`

Все они рисуют по-разному, но называются одинаково.

Благодаря полиморфизму мы можем:

```python
figures = [line, rect, ellipse]

for figure in figures:
    figure.draw()
```

И Python сам вызовет нужную реализацию метода.

Что это даёт:

* единый интерфейс;
* отсутствие проверок типов;
* лёгкое расширение системы;
* архитектурную гибкость.

---

## Три кита объектно-ориентированного программирования

Итак, концепция ООП опирается на три фундаментальных принципа:

1. **Инкапсуляция**: Скрытие внутренней реализации и работа через интерфейс.

2. **Наследование**: Переиспользование и расширение существующих классов.

3. **Полиморфизм**: Возможность работать с разными объектами единообразно.

Именно на этих принципах:

* **строятся архитектуры приложений**;
* **основаны паттерны проектирования**;
* **создаются масштабируемые системы**.

---

## Что дальше?

В этом курсе мы:

* научимся реализовывать все эти идеи **на Python**;
* подробно разберём классы, методы и атрибуты;
* изучим магические методы;
* научимся писать чистый и расширяемый ООП-код.

---

## Вопросы для самопроверки

1. Почему процедурного программирования недостаточно для больших проектов?
2. Что такое класс и чем он отличается от объекта?
3. Почему в ООП важно объединять данные и поведение?
4. В чём суть инкапсуляции?
5. Какие задачи решает наследование?
6. Что такое полиморфизм простыми словами?
7. Почему метод `draw()` — хороший пример полиморфизма?
8. Какие преимущества даёт единый интерфейс?
9. Можно ли использовать ООП частично, а не полностью?
10. Почему ООП — это скорее способ мышления, а не набор синтаксических правил?

---

[Следующий урок](lesson02.md)