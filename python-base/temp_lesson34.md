# Урок 34: Глобальные и локальные переменные. Импорт и работа с модулями в Python

# Модуль 1: Области видимости и управление именами

## Пространство имён (Namespace)

Прежде чем говорить о глобальных и локальных переменных, нужно разобраться с более базовым понятием — **именами** и тем, где они существуют в программе.

### Что такое имя в Python

В Python мы постоянно работаем с именами, даже если не задумываемся об этом:

```python
x = 10
print(x)
```

Здесь `x` — это **имя**, которое связано с определённым объектом (числом `10`).
Точно так же именами являются:

* имена переменных
* имена функций
* имена модулей
* имена классов (к ним мы вернёмся позже)

Важно понимать:

> **Имя — это не значение и не объект. Это способ обратиться к объекту.**

Python всегда работает не напрямую с объектами, а через имена, которые на них ссылаются.

---

### Что такое пространство имён

Когда программа становится больше, возникает естественный вопрос:

> А где Python хранит все эти имена и как он понимает, к какому именно объекту относится каждое из них?

Для этого существует **пространство имён (namespace)**.

**Пространство имён** — это область программы, в которой хранятся имена и соответствующие им объекты.

Проще говоря:

> Namespace — это «контекст», внутри которого Python ищет имя.

Можно представить это как словарь, где:

* ключ — имя
* значение — объект, на который оно указывает

Но важно не столько внутреннее устройство, сколько поведение:

* одно и то же имя **может существовать в разных пространствах имён**
* при обращении к имени Python ищет его **не везде сразу**, а по определённым правилам

---

### Глобальное пространство имён

Когда программа только запускается, Python создаёт **глобальное пространство имён**.

В него попадают:

* переменные, объявленные вне функций
* функции, которые мы определяем
* импортированные модули

Пример:

```python
x = 10

def show():
    print(x)
```

Здесь имя `x` находится в глобальном пространстве имён.
Функция `show` тоже является глобальным именем.

---

### У функции — своё пространство имён

Как только мы объявляем функцию и начинаем её выполнять, появляется **новое пространство имён**, связанное именно с этой функцией.

```python
def example():
    y = 5
    print(y)
```

Имя `y`:

* существует **только внутри функции**
* недоступно за её пределами
* исчезает после завершения выполнения функции

Это принципиально важно:

> **Каждый вызов функции создаёт собственное пространство имён.**

Именно поэтому переменные внутри функций не «мешают» друг другу и не конфликтуют с переменными вне функции.

---

## Глобальная область видимости и оператор `global`

### Глобальная область видимости

Глобальной областью видимости называется пространство имён, которое создаётся при запуске программы.

В него попадают:

* все имена, объявленные **вне функций**
* имена функций
* имена импортированных модулей

---

### Чтение и запись глобальных имён — это не одно и то же

Когда Python выполняет код внутри функции, он видит глобальные имена. Но это ещё не означает, что он может с ними делать всё, что угодно.

Одна из самых частых ошибок начинающих связана с этим различием.

Рассмотрим пример:

```python
total = 10

def add():
    print(total)
```

Функция спокойно читает значение `total`.
Это нормально и безопасно — **чтение глобального имени разрешено по умолчанию**.

Теперь попробуем изменить его:

```python
total = 10

def add():
    total = total + 5
    print(total)

add()
```

Этот код приведёт к ошибке:

```
UnboundLocalError: local variable 'total' referenced before assignment
```

На первый взгляд это выглядит странно: переменная `total` вроде бы существует.
Но причина ошибки связана именно с пространствами имён.

---

### Почему возникает ошибка

Когда Python видит внутри функции присваивание:

```python
total = total + 5
```

он делает вывод:

> имя `total` является **локальным** для этой функции

Но:

* локальное имя `total` ещё не создано
* попытка прочитать его происходит **раньше присваивания**

Отсюда и ошибка.

Важно понять ключевую мысль:

> **Наличие присваивания делает имя локальным для функции.**

И Python принимает это решение **до выполнения кода**, на этапе анализа функции.

---

### Зачем нужен оператор `global`

Иногда нам действительно нужно изменить значение, находящееся в глобальной области видимости.
Для таких случаев и существует оператор `global`.

```python
total = 10

def add():
    global total
    total = total + 5
    print(total)

add()
```

Здесь мы явно говорим Python:

> «В этой функции имя `total` не локальное.
> Используй глобальное пространство имён.»

После этого:

* Python не создаёт локальное имя
* изменение происходит именно в глобальной области

---

### Что на самом деле делает `global`

Очень важно правильно понять назначение этого оператора.

`global`:

* **не связывает функции между собой**
* **не передаёт значения**
* **не делает код “удобнее”**

Он делает только одно:

> даёт функции **разрешение на изменение глобального имени**

Без этого разрешения:

* читать глобальные имена можно
* изменять — нельзя

---

### Почему `global` нужно использовать осторожно

Когда функция напрямую изменяет глобальное состояние:

* её поведение становится менее предсказуемым
* код сложнее тестировать
* возрастает риск ошибок при расширении программы

Поэтому:

* `global` существует не для повседневного использования
* а как осознанный инструмент в редких случаях

В следующих блоках мы увидим:

* как функции создают собственные области видимости
* почему вложенные функции требуют другого механизма (`nonlocal`)
* и как константы помогают избегать проблем с глобальным состоянием

На этом этапе важно запомнить главное:

> Глобальная область видимости доступна для чтения,
> но для изменения требуется явное разрешение.

---

Продолжаем последовательно. Ниже — **Блок 3**, написанный как логическое развитие предыдущих рассуждений, без повторов уже введённых понятий и с акцентом на понимание поведения Python.

---

## Локальная область видимости. Функции как отдельный мир

Мы уже увидели, что глобальная область видимости — это лишь внешний уровень программы. На практике же большая часть логики живёт **внутри функций**, и именно там начинают действовать другие правила.

---

### Локальные имена

Каждый вызов функции создаёт **собственную локальную область видимости**.

Все имена, которые:

* создаются внутри функции
* являются параметрами функции

относятся к **локальным именам** этой функции.

```python
def calculate(a, b):
    result = a + b
    return result
```

Здесь локальными являются:

* `a`
* `b`
* `result`

Они существуют только:

* во время выполнения функции
* внутри её тела

После завершения функции локальная область видимости исчезает вместе со всеми своими именами.

---

### Функция как изолированная область

Удобно представлять функцию как **отдельный мир**, который временно создаётся во время вызова.

```
Глобальная область
 ├── calculate (имя функции)
 │
 └── Вызов calculate()
     ├── a
     ├── b
     └── result
```

Каждый новый вызов функции создаёт **новый экземпляр** локальной области видимости, даже если функция вызывается несколько раз подряд.

Это ключевое свойство, которое делает функции:

* безопасными
* независимыми
* удобными для повторного использования

---

### Приоритет поиска имён

Когда Python встречает имя внутри функции, он ищет его **не хаотично**, а в строго определённом порядке.

Упрощённо:

1. Локальная область функции
2. Глобальная область программы

Схематично это выглядит так:

```
Поиск имени внутри функции:

[ Локальная область ]
        ↓
[ Глобальная область ]
```

Если имя найдено на первом уровне — поиск останавливается.

---

### Конфликт локального и глобального имён

Из этого правила вытекает важное следствие:
**локальные имена имеют приоритет над глобальными**.

Рассмотрим пример:

```python
x = 100

def show():
    x = 10
    print(x)
```

Несмотря на то что глобально `x` равно `100`, внутри функции будет выведено `10`.

Почему?

* Python сначала находит локальное имя `x`
* до глобального он просто не доходит

С точки зрения Python это два **разных имени**, существующих в разных пространствах.

---

### Почему это не ошибка, а механизм

Такое поведение — не ограничение, а основа надёжной работы функций.

Благодаря приоритету локальных имён:

* функции не зависят от внешнего состояния
* одинаковые имена не конфликтуют
* код становится предсказуемым

```
Глобальная область
 ├── x = 100
 └── function()
      └── x = 10   ← другое имя, другой контекст
```

Если бы локальные имена не имели приоритета, любая функция могла бы случайно сломать глобальное состояние программы.

---

Как только внутри функции появляется присваивание:

* Python считает имя локальным
* и глобальное имя больше не участвует в поиске

Это не частный случай, а прямое следствие правил работы локальной области видимости.

---

Отлично, тогда сразу даю **готовый учебный блок** в том же стиле, что и предыдущие: спокойный, связанный, без лишней терминологии и с чётким фокусом на понимание.

---

## Как данные попадают в функцию и почему они ведут себя по-разному (изменяемые и неизменяемые)

После разбора глобальной и локальной области видимости у многих возникает закономерный вопрос:

> Почему иногда функция изменяет данные «снаружи», а иногда — нет,
> хотя код выглядит очень похоже?

Чтобы двигаться дальше без путаницы, важно коротко прояснить этот момент.

---

### Функция работает с именами, а не с переменными

Когда мы вызываем функцию и передаём в неё аргументы, в теле функции **создаются новые имена**.

```python
def show(value):
    print(value)
```

При вызове:

```python
x = 10
show(x)
```

Внутри функции:

* имя `value` **не является тем же самым именем**, что `x`
* оно просто указывает на то же значение

Схематично это можно представить так:

```
Глобальная область:
x ──→ 10

Локальная область функции:
value ──→ 10
```

Это принципиальный момент для всего дальнейшего понимания.

---

### Неизменяемые данные: создаётся новое значение

Рассмотрим пример с числом:

```python
def change(number):
    number = number + 1

x = 5
change(x)
print(x)
```

Результат:

```
5
```

Что происходит:

* внутри функции создаётся новое значение `6`
* имя `number` начинает указывать на него
* имя `x` в глобальной области **остаётся без изменений**

С точки зрения областей видимости:

* мы не меняем глобальное имя
* мы работаем только с локальным

```
x ──→ 5

change():
number ──→ 6
```

---

### Изменяемые данные: объект меняется «на месте»

Теперь похожий пример, но со списком:

```python
def add_item(items):
    items.append("new")

data = []
add_item(data)
print(data)
```

Результат:

```
['new']
```

На первый взгляд кажется, что функция «изменила внешнюю переменную».
Но на самом деле:

* имя `items` — локальное
* имя `data` — глобальное
* **оба имени указывают на один и тот же объект**

Схема:

```
data ──┐
       ├──→ []
items ─┘
```

Когда мы меняем сам объект, изменение видно через оба имени.

```
data ──┐
       ├──→ ['new']
items ─┘
```

---

### Почему это не противоречит областям видимости

Важно подчеркнуть:

* функция **не изменяет глобальное имя**
* она изменяет объект, на который это имя указывает

Области видимости при этом не нарушаются:

* имена остаются локальными и глобальными
* просто объект общий

Это объясняет, почему:

* с числами и строками поведение одно
* со списками и словарями — другое

---

## Вложенные функции и оператор `nonlocal`

До этого момента мы рассматривали ситуации, где есть только два уровня областей видимости: глобальная и локальная. Но Python позволяет создавать функции **внутри других функций**, и в таких случаях структура областей видимости становится многоуровневой.

---

### Внешняя и внутренняя функция

Рассмотрим пример:

```python
def outer():
    x = 10

    def inner():
        print(x)

    inner()
```

Здесь:

* `outer` — внешняя функция
* `inner` — внутренняя функция
* переменная `x` объявлена во внешней функции

Когда вызывается `inner`, Python спокойно находит имя `x`, хотя оно не является локальным для `inner`.

Почему это работает?

---

### Многоуровневая область видимости

В такой конструкции у Python появляется **несколько вложенных областей видимости**.

Схематично это можно представить так:

```
Глобальная область
 └── outer()
      ├── x
      └── inner()
           └── (локальная область inner)
```

Когда Python ищет имя внутри `inner`, он идёт по цепочке:

1. локальная область `inner`
2. область внешней функции `outer`
3. глобальная область

И останавливается на первом совпадении.

---

### Попытка изменить переменную внешней функции

Теперь попробуем не просто прочитать `x`, а изменить его:

```python
def outer():
    x = 10

    def inner():
        x = x + 1

    inner()
    print(x)
```

Этот код приведёт к ошибке:

```
UnboundLocalError: local variable 'x' referenced before assignment
```

Причина знакома по предыдущим блокам:

* присваивание делает имя `x` локальным для `inner`
* но локальное имя ещё не создано на момент чтения

Важно заметить:

> `global` здесь не подходит, потому что `x` не находится в глобальной области.

---

### Зачем нужен `nonlocal`

В таких ситуациях Python предоставляет другой инструмент — оператор `nonlocal`.

```python
def outer():
    x = 10

    def inner():
        nonlocal x
        x = x + 1

    inner()
    print(x)
```

Теперь результат будет:

```
11
```

Оператор `nonlocal` сообщает Python:

> «Имя `x` не локальное для этой функции.
> Оно находится во внешней, но не глобальной области.»

После этого:

* Python не создаёт локальное имя `x` внутри `inner`
* изменение происходит в области видимости функции `outer`

---

### Что на самом деле делает `nonlocal`

Важно правильно понять назначение `nonlocal`.

`nonlocal`:

* **не ищет имя где угодно**
* **не создаёт новую переменную**
* **не заменяет `global`**

Он работает строго:

* с именами из внешней функции
* в рамках вложенных функций

```
Глобальная область
 └── outer()
      ├── x   ← nonlocal работает здесь
      └── inner()
```

---

### Практический пример: простой счётчик

Рассмотрим реальный кейс — счётчик.

```python
def create_counter():
    count = 0

    def increment():
        nonlocal count
        count += 1
        return count

    return increment
```

Использование:

```python
counter = create_counter()

print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

Здесь:

* `count` живёт во внешней функции
* внутренняя функция изменяет его состояние
* глобальная область остаётся чистой

Схема работы:

```
create_counter()
 └── count = 0
     └── increment()
          └── nonlocal count
```

### Что делает `create_counter()`?

Когда вызывается функция:

```python
counter = create_counter()
```

происходит следующее:

1. Python **создаёт новую область видимости** для `create_counter`.
2. В этой области создаётся переменная:

   ```python
   count = 0
   ```
3. Создаётся функция `increment`, которая:

   * **запоминает ссылку** на переменную `count`,
   * но **не выполняется**.
4. Функция `increment` **возвращается наружу**.

Важно:

> После завершения `create_counter()` её область видимости **не уничтожается**, потому что на неё всё ещё ссылается возвращённая функция.

Это называется **замыкание (closure)**.

---

### Что хранится в переменной `counter`

После выполнения строки:

```python
counter = create_counter()
```

переменная `counter` содержит **функцию `increment` вместе с её состоянием**:

```
counter ──▶ increment()
              │
              └── count = 0
```

Теперь каждый вызов:

```python
counter()
```

работает с **одной и той же переменной `count`**, увеличивая её значение.

Поэтому результат будет:

```python
print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

---

### Зачем нужна переменная `counter`

Переменная нужна **не для хранения числа**, а для хранения **функции с состоянием**.

Код `counter = create_counter()`: «Создай счётчик и сохрани его состояние».

Код `counter()`: «Увеличь значение именно этого счётчика»

Если бы переменной не было, состояние просто **негде было бы сохранить**.

---

### Если вызывать `create_counter()` без переменной

Если написать так:

```python
print(create_counter()())
print(create_counter()())
print(create_counter()())
```

то результат будет:

```
1
1
1
```

Почему?

Потому что **каждый вызов `create_counter()` создаёт новую область видимости**:

```
create_counter() → count = 0 → increment → return
create_counter() → count = 0 → increment → return
create_counter() → count = 0 → increment → return
```

Каждый раз:

* `count` создаётся заново,
* значение начинается с нуля,
* функция `increment` работает с **новой переменной**, а не с предыдущей.

---

### А что такое состояние?

**Состояние** — это данные, которые:

* не передаются в функцию каждый раз явно,
* но **сохраняются между вызовами**,
* и влияют на результат работы функции.

В примере со счётчиком таким состоянием была переменная `count`.
Она не создавалась заново при каждом вызове `increment`, а продолжала жить и изменяться.

Проще говоря: `Состояние — это «память» функции о прошлых действиях`.

### А что такое замыкание?

**Замыкание** — это ситуация, когда:

* внутренняя функция использует переменные из внешней функции,
* и **эти переменные сохраняются**, даже после завершения внешней функции.

В нашем примере:

* функция `increment` продолжает работать с `count`,
* несмотря на то, что `create_counter` уже закончила выполнение.

Это возможно потому, что Python **не уничтожает внешнюю область видимости**, пока на неё существует ссылка.

### Важно запомнить:

> Если функция «помнит прошлое» — значит, у неё есть `состояние`,

> а если это состояние пришло из внешней области — это `замыкание`.

Углубляться в тему замыканий имеет смысл при изучении:

* декораторов,
* функционального программирования,
* асинхронного кода,
* и некоторых паттернов проектирования.

---

### Почему `nonlocal` используется редко

`nonlocal` — полезный, но узкоспециализированный инструмент.

Он применяется, когда:

* есть вложенные функции
* нужно сохранить состояние
* не хочется выносить данные в глобальную область

Во многих случаях ту же задачу можно решить другими способами, но понимание `nonlocal` важно:

* для чтения чужого кода
* для осознанной работы с областями видимости
* для перехода к более сложным конструкциям языка

---

## Константы в Python

> Как писать код так, чтобы глобальные имена не превращались в источник хаоса?

Один из основных инструментов для этого — **константы**.

---

### Что такое константы

В Python **нет настоящих констант на уровне языка**.
Любое имя можно изменить в любой момент.

Тем не менее, в Python существует устоявшаяся договорённость:

> Константа — это имя, значение которого **не предполагается изменять** в процессе работы программы.

Речь идёт не о техническом ограничении, а о **соглашении между разработчиками**.

---

### Соглашение об именовании

Чтобы сразу было понятно, что перед нами константа, используется простое правило:

```python
MAX_USERS = 100
TIMEOUT = 30
API_URL = "https://example.com"
```

Все буквы — заглавные, слова разделены подчёркиванием.

Это не случайный стиль оформления.
Такой код читается иначе:

* сразу видно, что значение «настроечное»
* понятно, что его не стоит менять внутри логики программы
* проще искать и поддерживать

---

### Зачем нужны константы

На первый взгляд может показаться, что константы — это просто вопрос стиля.
На практике они решают несколько важных задач.

**1. Централизация настроек**

Вместо:

```python
delay = 5
...
time.sleep(5)
...
if retries > 5:
```

Мы имеем:

```python
DELAY = 5
MAX_RETRIES = 5
```

Изменения вносятся в одном месте.

---

**2. Защита от случайных ошибок**

Если значение используется напрямую, его легко:

* изменить по ошибке
* переопределить
* неправильно интерпретировать

Константа же сразу сигнализирует:

> это значение важно и фиксировано по смыслу

---

**3. Читаемость и поддержка кода**

Сравните:

```python
if status == 3:
    ...
```

и

```python
if status == STATUS_ACTIVE:
    ...
```

Во втором случае код:

* сам себя объясняет
* не требует комментариев
* проще для поддержки

---

### Константы и области видимости

С точки зрения областей видимости, константы обычно живут:

* в глобальной области файла
* вне функций

Схематично:

```
Глобальная область
 ├── CONSTANT_A
 ├── CONSTANT_B
 └── функции
      └── локальные имена
```

Функции:

* используют константы
* но не изменяют их

Это простое правило дисциплинирует код и избавляет от необходимости применять `global`.

---

### Где хранить константы

В небольших скриптах константы можно хранить прямо в файле с кодом, ближе к началу.

В более крупных программах обычно:

* выносят константы в отдельный файл
* используют его как источник настроек

Пока важно запомнить сам принцип:

> константы должны быть собраны в одном месте и легко доступны для чтения.

К вопросу о том, **как именно это делать**, мы вернёмся во втором модуле, когда начнём делить программу на файлы.

---

## Практика Модуль 1

**Задача 1**.

Объявите в программе глобальную переменную `call_count` равную нулю. Напишите функцию, которая увеличивает значение `call_count` на 1 и выводит текущее количество вызовов в формате "Функция вызвана N раз". Функцию необходимо вызвать **5 раз подряд**.

---

**Задача 2**

Объявите в программе пустой кортеж `logs`. Напишите функцию, которая принимает строку — текст сообщения и добавляет это сообщение в кортеж `logs`. Добавьте в `logs` сообщения `"Start"`, `"Processing"`, `"Finish"`. Выведите содержимое `logs`, выводя **каждое сообщение с новой строки**.

---

**Задача 3**

Создайте в программе константу, которая будет хранить `минимальное значение`, например `10` и список чисел `numbers = [3, 12, 7, 25, 9, 18, 2]`. Напишите функцию, которая принимает список чисел и возвращает список, содержащий только те числа, которые **строго больше константы**. Выведите на экран результат работы функции и изначальный список. Список `numbers` не должен измениться.

---

**Задача 4**

Напишите функцию, внутри которой создаётся начальное значение суммы, равное `0` и определяется вложенная функция. Вложенная функция принимает число и добавляет его к общей сумме. Вызовите вложенную функцию с числами `5`, `10` и `3`, после чего верните итоговую сумму. Выведите сумму на экран.

---

**Задача 5**

Напишите функцию, каждый вызов которой увеличивает счетчик внутри нее на единицу. Используйте вложенную функцию для изменения счетчика. Вызовите возвращённую функцию **4 раза подряд**.

---

# Модуль 2: Импорт и работа с модулями в Python

## Блок 6. Что такое модуль и зачем он нужен

До этого момента мы работали с программой как с **единым файлом**.
Все переменные, функции и логика находились в одном месте. Это нормально, пока программа маленькая. Но по мере роста кода возникает естественная проблема: **слишком много всего в одном файле**.

В Python эту проблему решают модули.

---

### Файл как модуль

В Python **любой файл с расширением `.py` — это модуль**.

Если у вас есть файл:

```text
settings.py
```

то для Python это уже:

* отдельная единица программы,
* со своим именем,
* со своим кодом,
* и со своей областью видимости.

Никаких дополнительных действий не требуется.
Файл становится модулем **по факту своего существования**.

---

### У каждого модуля — своё пространство имён

Когда Python загружает модуль, он:

1. создаёт **отдельное пространство имён**;
2. выполняет код файла сверху вниз;
3. сохраняет все созданные имена внутри этого модуля.

Схематично это можно представить так:

```
main.py
│
├── своё пространство имён
│   ├── переменные
│   └── функции
│
└── settings.py
    ├── своё пространство имён
    ├── переменные
    └── функции
```

Важно понимать:

> Переменные одного модуля **не попадают автоматически** в другой.

Чтобы получить доступ к данным другого файла, его нужно **явно подключить**.

---

### Импорт модуля: что происходит на самом деле

Рассмотрим простой пример.

Файл `config.py`:

```python
DEBUG = True
VERSION = "1.0"
```

Файл `main.py`:

```python
import config

print(config.DEBUG)
print(config.VERSION)
```

Когда Python выполняет строку:

```python
import config
```

он делает следующее:

1. находит файл `config.py`;
2. **выполняет весь код внутри него**;
3. создаёт объект модуля `config`;
4. добавляет этот объект в пространство имён текущего файла.

После этого доступ к данным модуля осуществляется **через его имя**:

```
config.DEBUG
config.VERSION
```

Это подчёркивает важную мысль:

> Модуль — это не просто «набор переменных»,
> а отдельный объект со своим пространством имён.

---

### Выполнение кода при импорте

> **При импорте выполняется весь код модуля.**

Если в `config.py` написать:

```python
print("Модуль config загружен")

DEBUG = True
```

то при импорте:

```python
import config
```

на экран будет выведено сообщение:

```
Модуль config загружен
```

Это означает, что:

* импорт — это не «подключение текста»,
* это **выполнение файла как программы**.

Именно поэтому так важно понимать, **что можно писать в модуле, а что — нет**.
К этому мы вернёмся позже, когда будем разбирать конструкцию `if __name__ == "__main__"`.

---

## Блок 7. Способы импорта: `import`, `from`, `as`

### **Оператор `import`**. Импорт всего модуля с помощью `import module`

Самая базовая и безопасная форма импорта выглядит так:

```python
import math

result = math.sqrt(25)
```

В этом случае:

* в текущее пространство имён добавляется **одно имя** — `math`;
* все объекты модуля доступны **через это имя**.

Схематично:

```
main.py
│
├── math  ──▶ модуль
│           ├── sqrt
│           ├── pi
│           └── ...
```

Такой способ импорта:

* явно показывает, **откуда берётся каждая функция или переменная**;
* практически исключает конфликты имён;
* делает код немного более многословным, но читаемым.

---

### **Оператор `from`**. Импорт отдельных объектов с помощью `from module import name`

Теперь рассмотрим другой подход:

```python
from math import sqrt, pi

result = sqrt(25)
area = pi * 10 ** 2
```

Здесь:

* в текущее пространство имён добавляются **конкретные имена** (`sqrt`, `pi`);
* имя модуля `math` при этом **не используется**.

Схематично:

```
main.py
│
├── sqrt
├── pi
```

Этот способ:

* делает код короче;
* удобен, когда используется **небольшое количество объектов**;
* но скрывает источник происхождения имени.

По коду `sqrt(25)` уже нельзя сразу понять, из какого модуля взята функция.

---

### Влияние на пространство имён

Выбор способа импорта напрямую влияет на то, **насколько "загруженным" становится пространство имён файла**.

Сравним два варианта.

```python
import statistics

average = statistics.mean([10, 20, 30])
```

и

```python
from statistics import mean

average = mean([10, 20, 30])
```

Во втором случае имя `mean`:

* становится частью текущего пространства имён;
* может конфликтовать с другой функцией или переменной с таким же именем.

Поэтому здесь важно соблюдать баланс между краткостью и ясностью.

---

### Оператор `as`. Управление именами с помощью `as`

Оператор `as` позволяет **переименовать импортируемый объект** в текущем файле.

Рассмотрим ситуацию, где без него не обойтись.

Есть два модуля:

`app_config.py`:

```python
settings = {
    "debug": True,
    "version": "1.0"
}
```

`user_config.py`:

```python
settings = {
    "theme": "dark",
    "language": "ru"
}
```

Если в основном файле написать:

```python
from app_config import settings
from user_config import settings
```

вторая строка **перезапишет первую**, и данные будут потеряны.

Решение — явное переименование:

```python
from app_config import settings as app_settings
from user_config import settings as user_settings

print(app_settings["version"])
print(user_settings["theme"])
```

Теперь:

* имена не конфликтуют;
* код остаётся читаемым;
* смысл каждого объекта ясен.

---

### `as` как инструмент читаемости

`as` используется не только для разрешения конфликтов, но и для повышения удобства работы.

```python
import datetime as dt

now = dt.datetime.now()
```

Здесь сокращение:

* не скрывает смысл;
* уменьшает визуальный шум;
* делает код компактнее без потери читаемости.

Важно помнить:

> `as` — это не хаотичное сокращение, а осознанное управление именами в текущем файле.

---

### Оператор `*`. Почему не стоит использовать `from module import *`

Иногда можно встретить такой вариант:

```python
from math import *
```

Формально он работает, но:

* непонятно, какие именно имена появились в пространстве имён;
* возможны конфликты;
* код становится труднее читать и сопровождать.

В учебных и реальных проектах такой импорт **лучше не использовать**.

---

