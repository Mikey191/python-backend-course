# Урок 34: Глобальные и локальные переменные. Импорт и работа с модулями в Python

## **Содержание урока**:
- [Модуль 1: Области видимости и управление именами](#модуль-1-области-видимости-и-управление-именами)
    - [Блок 1. Пространство имён (Namespace)](#блок-1-пространство-имён-namespace)
    - [Блок 2. Глобальная область видимости и оператор `global`](#блок-2-глобальная-область-видимости-и-оператор-global)
    - [Блок 3. Локальная область видимости. Функции как отдельный мир](#блок-3-локальная-область-видимости-функции-как-отдельный-мир)
    - [Блок 4. Как данные попадают в функцию и почему они ведут себя по-разному (изменяемые и неизменяемые)](#блок-4-как-данные-попадают-в-функцию-и-почему-они-ведут-себя-по-разному-изменяемые-и-неизменяемые)
    - [Блок 5. Вложенные функции и оператор `nonlocal`](#блок-5-вложенные-функции-и-оператор-nonlocal)
    - [Блок 6. Константы в Python](#блок-6-константы-в-python)
    - [Практика Модуль 1](#практика-модуль-1)

- [Модуль 2: Импорт и работа с модулями в Python](#модуль-2-импорт-и-работа-с-модулями-в-python)
    - [Блок 7. Что такое модуль и зачем он нужен](#блок-7-что-такое-модуль-и-зачем-он-нужен)
    - [Блок 8. Способы импорта: `import`, `from`, `as`](#блок-8-способы-импорта-import-from-as)
    - [Блок 9. Логическое разделение программы на модули](#блок-9-логическое-разделение-программы-на-модули)
    - [Блок 10. `if __name__ == "__main__"`](#блок-10-if-__name__--__main__)
    - [Практика Модуль 2](#практика-модуль-2)

- [Модуль 3. Стандартные библиотеки Python `random`, `datetime`, `string`, `os`, `sys`](#модуль-3-стандартные-библиотеки-python)
    - [Блок 11. Модуль `random` — работа со случайными данными](#блок-11-модуль-random--работа-со-случайными-данными)
    - [Блок 12. Модуль `datetime` — работа с датами и временем](#блок-12-модуль-datetime--работа-с-датами-и-временем)
    - [Блок 13. Модуль `string` — наборы символов и работа со строками](#блок-13-модуль-string--наборы-символов-и-работа-со-строками)
    - [Блок 14. Модуль `os` — работа с файловой системой](#блок-14-модуль-os--работа-с-файловой-системой)
    - [Блок 15. Модуль `sys` — взаимодействие с интерпретатором](#блок-15-модуль-sys--взаимодействие-с-интерпретатором)
    - [Практика Модуль 3](#практика-модуль-3)


# Модуль 1: Области видимости и управление именами

## Блок 1. Пространство имён (Namespace)

Прежде чем говорить о глобальных и локальных переменных, нужно разобраться с более базовым понятием — **именами** и тем, где они существуют в программе.

### Что такое имя в Python

В Python мы постоянно работаем с именами, даже если не задумываемся об этом:

```python
x = 10
print(x)
```

Здесь `x` — это **имя**, которое связано с определённым объектом (числом `10`).
Точно так же именами являются:

- имена переменных
- имена функций
- имена модулей
- имена классов (к ним мы вернёмся позже)

Важно понимать:

> **Имя — это не значение и не объект. Это способ обратиться к объекту.**

Python всегда работает не напрямую с объектами, а через имена, которые на них ссылаются.

---

### Что такое пространство имён

Когда программа становится больше, возникает естественный вопрос:

> А где Python хранит все эти имена и как он понимает, к какому именно объекту относится каждое из них?

Для этого существует **пространство имён (namespace)**.

**Пространство имён** — это область программы, в которой хранятся имена и соответствующие им объекты.

Проще говоря:

> Namespace — это «контекст», внутри которого Python ищет имя.

Можно представить это как словарь, где:

- ключ — имя
- значение — объект, на который оно указывает

Но важно не столько внутреннее устройство, сколько поведение:

- одно и то же имя **может существовать в разных пространствах имён**
- при обращении к имени Python ищет его **не везде сразу**, а по определённым правилам

---

### Глобальное пространство имён

Когда программа только запускается, Python создаёт **глобальное пространство имён**.

В него попадают:

- переменные, объявленные вне функций
- функции, которые мы определяем
- импортированные модули

Пример:

```python
x = 10

def show():
    print(x)
```

Здесь имя `x` находится в глобальном пространстве имён.
Функция `show` тоже является глобальным именем.

---

### У функции — своё пространство имён

Как только мы объявляем функцию и начинаем её выполнять, появляется **новое пространство имён**, связанное именно с этой функцией.

```python
def example():
    y = 5
    print(y)
```

Имя `y`:

- существует **только внутри функции**
- недоступно за её пределами
- исчезает после завершения выполнения функции

Это принципиально важно:

> **Каждый вызов функции создаёт собственное пространство имён.**

Именно поэтому переменные внутри функций не «мешают» друг другу и не конфликтуют с переменными вне функции.

---

## Блок 2. Глобальная область видимости и оператор `global`

### Глобальная область видимости

Глобальной областью видимости называется пространство имён, которое создаётся при запуске программы.

В него попадают:

- все имена, объявленные **вне функций**
- имена функций
- имена импортированных модулей

---

### Чтение и запись глобальных имён — это не одно и то же

Когда Python выполняет код внутри функции, он видит глобальные имена. Но это ещё не означает, что он может с ними делать всё, что угодно.

Одна из самых частых ошибок начинающих связана с этим различием.

Рассмотрим пример:

```python
total = 10

def add():
    print(total)
```

Функция спокойно читает значение `total`.
Это нормально и безопасно — **чтение глобального имени разрешено по умолчанию**.

Теперь попробуем изменить его:

```python
total = 10

def add():
    total = total + 5
    print(total)

add()
```

Этот код приведёт к ошибке:

```
UnboundLocalError: local variable 'total' referenced before assignment
```

На первый взгляд это выглядит странно: переменная `total` вроде бы существует.
Но причина ошибки связана именно с пространствами имён.

---

### Почему возникает ошибка

Когда Python видит внутри функции присваивание:

```python
total = total + 5
```

он делает вывод:

> имя `total` является **локальным** для этой функции

Но:

- локальное имя `total` ещё не создано
- попытка прочитать его происходит **раньше присваивания**

Отсюда и ошибка.

Важно понять ключевую мысль:

> **Наличие присваивания делает имя локальным для функции.**

И Python принимает это решение **до выполнения кода**, на этапе анализа функции.

---

### Зачем нужен оператор `global`

Иногда нам действительно нужно изменить значение, находящееся в глобальной области видимости.
Для таких случаев и существует оператор `global`.

```python
total = 10

def add():
    global total
    total = total + 5
    print(total)

add()
```

Здесь мы явно говорим Python:

> «В этой функции имя `total` не локальное. Используй глобальное пространство имён.»

После этого:

- Python не создаёт локальное имя
- изменение происходит именно в глобальной области

---

### Что на самом деле делает `global`

Очень важно правильно понять назначение этого оператора.

`global`:

- **не связывает функции между собой**
- **не передаёт значения**
- **не делает код “удобнее”**

Он делает только одно:

> даёт функции **разрешение на изменение глобального имени**

Без этого разрешения:

- читать глобальные имена можно
- изменять — нельзя

---

### Почему `global` нужно использовать осторожно

Когда функция напрямую изменяет глобальное состояние:

- её поведение становится менее предсказуемым
- код сложнее тестировать
- возрастает риск ошибок при расширении программы

Поэтому:

- `global` существует не для повседневного использования
- а как осознанный инструмент в редких случаях

В следующих блоках мы увидим:

- как функции создают собственные области видимости
- почему вложенные функции требуют другого механизма (`nonlocal`)
- и как константы помогают избегать проблем с глобальным состоянием

На этом этапе важно запомнить главное:

> Глобальная область видимости доступна для чтения, но для изменения требуется явное разрешение.

---

## Блок 3. Локальная область видимости. Функции как отдельный мир

Мы уже увидели, что глобальная область видимости — это лишь внешний уровень программы. На практике же большая часть логики живёт **внутри функций**, и именно там начинают действовать другие правила.

---

### Локальные имена

Каждый вызов функции создаёт **собственную локальную область видимости**.

Все имена, которые:

- создаются внутри функции
- являются параметрами функции

относятся к **локальным именам** этой функции.

```python
def calculate(a, b):
    result = a + b
    return result
```

Здесь локальными являются:

- `a`
- `b`
- `result`

Они существуют только:

- во время выполнения функции
- внутри её тела

После завершения функции локальная область видимости исчезает вместе со всеми своими именами.

---

### Функция как изолированная область

Удобно представлять функцию как **отдельный мир**, который временно создаётся во время вызова.

```
Глобальная область
 ├── calculate (имя функции)
 │
 └── Вызов calculate()
     ├── a
     ├── b
     └── result
```

Каждый новый вызов функции создаёт **новый экземпляр** локальной области видимости, даже если функция вызывается несколько раз подряд.

Это ключевое свойство, которое делает функции:

- безопасными
- независимыми
- удобными для повторного использования

---

### Приоритет поиска имён

Когда Python встречает имя внутри функции, он ищет его **не хаотично**, а в строго определённом порядке.

Упрощённо:

1. Локальная область функции
2. Глобальная область программы

Схематично это выглядит так:

```
Поиск имени внутри функции:

[ Локальная область ]
        ↓
[ Глобальная область ]
```

Если имя найдено на первом уровне — поиск останавливается.

---

### Конфликт локального и глобального имён

Из этого правила вытекает важное следствие:
**локальные имена имеют приоритет над глобальными**.

Рассмотрим пример:

```python
x = 100

def show():
    x = 10
    print(x)
```

Несмотря на то что глобально `x` равно `100`, внутри функции будет выведено `10`.

Почему?

- Python сначала находит локальное имя `x`
- до глобального он просто не доходит

С точки зрения Python это два **разных имени**, существующих в разных пространствах.

---

### Почему это не ошибка, а механизм

Такое поведение — не ограничение, а основа надёжной работы функций.

Благодаря приоритету локальных имён:

- функции не зависят от внешнего состояния
- одинаковые имена не конфликтуют
- код становится предсказуемым

```
Глобальная область
 ├── x = 100
 └── function()
      └── x = 10   ← другое имя, другой контекст
```

Если бы локальные имена не имели приоритета, любая функция могла бы случайно сломать глобальное состояние программы.

---

Как только внутри функции появляется присваивание:

- Python считает имя локальным
- и глобальное имя больше не участвует в поиске

Это не частный случай, а прямое следствие правил работы локальной области видимости.

---

## Блок 4. Как данные попадают в функцию и почему они ведут себя по-разному (изменяемые и неизменяемые)

После разбора глобальной и локальной области видимости у многих возникает закономерный вопрос:

> Почему иногда функция изменяет данные «снаружи», а иногда — нет,
> хотя код выглядит очень похоже?

Чтобы двигаться дальше без путаницы, важно коротко прояснить этот момент.

---

### Функция работает с именами, а не с переменными

Когда мы вызываем функцию и передаём в неё аргументы, в теле функции **создаются новые имена**.

```python
def show(value):
    print(value)
```

При вызове:

```python
x = 10
show(x)
```

Внутри функции:

- имя `value` **не является тем же самым именем**, что `x`
- оно просто указывает на то же значение

Схематично это можно представить так:

```
Глобальная область:
x ──→ 10

Локальная область функции:
value ──→ 10
```

Это принципиальный момент для всего дальнейшего понимания.

---

### Неизменяемые данные: создаётся новое значение

Рассмотрим пример с числом:

```python
def change(number):
    number = number + 1

x = 5
change(x)
print(x)
```

Результат:

```
5
```

Что происходит:

- внутри функции создаётся новое значение `6`
- имя `number` начинает указывать на него
- имя `x` в глобальной области **остаётся без изменений**

С точки зрения областей видимости:

- мы не меняем глобальное имя
- мы работаем только с локальным

```
x ──→ 5

change():
number ──→ 6
```

---

### Изменяемые данные: объект меняется «на месте»

Теперь похожий пример, но со списком:

```python
def add_item(items):
    items.append("new")

data = []
add_item(data)
print(data)
```

Результат:

```
['new']
```

На первый взгляд кажется, что функция «изменила внешнюю переменную».
Но на самом деле:

- имя `items` — локальное
- имя `data` — глобальное
- **оба имени указывают на один и тот же объект**

Схема:

```
data ──┐
       ├──→ []
items ─┘
```

Когда мы меняем сам объект, изменение видно через оба имени.

```
data ──┐
       ├──→ ['new']
items ─┘
```

---

### Почему это не противоречит областям видимости

Важно подчеркнуть:

- функция **не изменяет глобальное имя**
- она изменяет объект, на который это имя указывает

Области видимости при этом не нарушаются:

- имена остаются локальными и глобальными
- просто объект общий

Это объясняет, почему:

- с числами и строками поведение одно
- со списками и словарями — другое

---

## Блок 5. Вложенные функции и оператор `nonlocal`

До этого момента мы рассматривали ситуации, где есть только два уровня областей видимости: глобальная и локальная. Но Python позволяет создавать функции **внутри других функций**, и в таких случаях структура областей видимости становится многоуровневой.

---

### Внешняя и внутренняя функция

Рассмотрим пример:

```python
def outer():
    x = 10

    def inner():
        print(x)

    inner()
```

Здесь:

- `outer` — внешняя функция
- `inner` — внутренняя функция
- переменная `x` объявлена во внешней функции

Когда вызывается `inner`, Python спокойно находит имя `x`, хотя оно не является локальным для `inner`.

Почему это работает?

---

### Многоуровневая область видимости

В такой конструкции у Python появляется **несколько вложенных областей видимости**.

Схематично это можно представить так:

```
Глобальная область
 └── outer()
      ├── x
      └── inner()
           └── (локальная область inner)
```

Когда Python ищет имя внутри `inner`, он идёт по цепочке:

1. локальная область `inner`
2. область внешней функции `outer`
3. глобальная область

И останавливается на первом совпадении.

---

### Попытка изменить переменную внешней функции

Теперь попробуем не просто прочитать `x`, а изменить его:

```python
def outer():
    x = 10

    def inner():
        x = x + 1

    inner()
    print(x)
```

Этот код приведёт к ошибке:

```
UnboundLocalError: local variable 'x' referenced before assignment
```

Причина знакома по предыдущим блокам:

- присваивание делает имя `x` локальным для `inner`
- но локальное имя ещё не создано на момент чтения

Важно заметить:

> `global` здесь не подходит, потому что `x` не находится в глобальной области.

---

### Зачем нужен `nonlocal`

В таких ситуациях Python предоставляет другой инструмент — оператор `nonlocal`.

```python
def outer():
    x = 10

    def inner():
        nonlocal x
        x = x + 1

    inner()
    print(x)
```

Теперь результат будет:

```
11
```

Оператор `nonlocal` сообщает Python:

> «Имя `x` не локальное для этой функции.
> Оно находится во внешней, но не глобальной области.»

После этого:

- Python не создаёт локальное имя `x` внутри `inner`
- изменение происходит в области видимости функции `outer`

---

### Что на самом деле делает `nonlocal`

Важно правильно понять назначение `nonlocal`.

`nonlocal`:

- **не ищет имя где угодно**
- **не создаёт новую переменную**
- **не заменяет `global`**

Он работает строго:

- с именами из внешней функции
- в рамках вложенных функций

```
Глобальная область
 └── outer()
      ├── x   ← nonlocal работает здесь
      └── inner()
```

---

### Практический пример: простой счётчик

Рассмотрим реальный кейс — счётчик.

```python
def create_counter():
    count = 0

    def increment():
        nonlocal count
        count += 1
        return count

    return increment
```

Использование:

```python
counter = create_counter()

print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

Здесь:

- `count` живёт во внешней функции
- внутренняя функция изменяет его состояние
- глобальная область остаётся чистой

Схема работы:

```
create_counter()
 └── count = 0
     └── increment()
          └── nonlocal count
```

### Что делает `create_counter()`?

Когда вызывается функция:

```python
counter = create_counter()
```

происходит следующее:

1. Python **создаёт новую область видимости** для `create_counter`.
2. В этой области создаётся переменная:

   ```python
   count = 0
   ```

3. Создаётся функция `increment`, которая:
   - **запоминает ссылку** на переменную `count`,
   - но **не выполняется**.

4. Функция `increment` **возвращается наружу**.

Важно:

> После завершения `create_counter()` её область видимости **не уничтожается**, потому что на неё всё ещё ссылается возвращённая функция.

Это называется **замыкание (closure)**.

---

### Что хранится в переменной `counter`

После выполнения строки:

```python
counter = create_counter()
```

переменная `counter` содержит **функцию `increment` вместе с её состоянием**:

```
counter ──▶ increment()
              │
              └── count = 0
```

Теперь каждый вызов:

```python
counter()
```

работает с **одной и той же переменной `count`**, увеличивая её значение.

Поэтому результат будет:

```python
print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

---

### Зачем нужна переменная `counter`

Переменная нужна **не для хранения числа**, а для хранения **функции с состоянием**.

Код `counter = create_counter()`: «Создай счётчик и сохрани его состояние».

Код `counter()`: «Увеличь значение именно этого счётчика»

Если бы переменной не было, состояние просто **негде было бы сохранить**.

---

### Если вызывать `create_counter()` без переменной

Если написать так:

```python
print(create_counter()())
print(create_counter()())
print(create_counter()())
```

то результат будет:

```
1
1
1
```

Почему?

Потому что **каждый вызов `create_counter()` создаёт новую область видимости**:

```
create_counter() → count = 0 → increment → return
create_counter() → count = 0 → increment → return
create_counter() → count = 0 → increment → return
```

Каждый раз:

- `count` создаётся заново,
- значение начинается с нуля,
- функция `increment` работает с **новой переменной**, а не с предыдущей.

---

### А что такое состояние?

**Состояние** — это данные, которые:

- не передаются в функцию каждый раз явно,
- но **сохраняются между вызовами**,
- и влияют на результат работы функции.

В примере со счётчиком таким состоянием была переменная `count`.
Она не создавалась заново при каждом вызове `increment`, а продолжала жить и изменяться.

Проще говоря: `Состояние — это «память» функции о прошлых действиях`.

### А что такое замыкание?

**Замыкание** — это ситуация, когда:

- внутренняя функция использует переменные из внешней функции,
- и **эти переменные сохраняются**, даже после завершения внешней функции.

В нашем примере:

- функция `increment` продолжает работать с `count`,
- несмотря на то, что `create_counter` уже закончила выполнение.

Это возможно потому, что Python **не уничтожает внешнюю область видимости**, пока на неё существует ссылка.

### Важно запомнить:

> Если функция «помнит прошлое» — значит, у неё есть `состояние`,

> а если это состояние пришло из внешней области — это `замыкание`.

Углубляться в тему замыканий имеет смысл при изучении:

- декораторов,
- функционального программирования,
- асинхронного кода,
- и некоторых паттернов проектирования.

---

### Почему `nonlocal` используется редко

`nonlocal` — полезный, но узкоспециализированный инструмент.

Он применяется, когда:

- есть вложенные функции
- нужно сохранить состояние
- не хочется выносить данные в глобальную область

Во многих случаях ту же задачу можно решить другими способами, но понимание `nonlocal` важно:

- для чтения чужого кода
- для осознанной работы с областями видимости
- для перехода к более сложным конструкциям языка

---

## Блок 6. Константы в Python

> Как писать код так, чтобы глобальные имена не превращались в источник хаоса?

Один из основных инструментов для этого — **константы**.

---

### Что такое константы

В Python **нет настоящих констант на уровне языка**.
Любое имя можно изменить в любой момент.

Тем не менее, в Python существует устоявшаяся договорённость:

> Константа — это имя, значение которого **не предполагается изменять** в процессе работы программы.

Речь идёт не о техническом ограничении, а о **соглашении между разработчиками**.

---

### Соглашение об именовании

Чтобы сразу было понятно, что перед нами константа, используется простое правило:

```python
MAX_USERS = 100
TIMEOUT = 30
API_URL = "https://example.com"
```

Все буквы — заглавные, слова разделены подчёркиванием.

Это не случайный стиль оформления.
Такой код читается иначе:

- сразу видно, что значение «настроечное»
- понятно, что его не стоит менять внутри логики программы
- проще искать и поддерживать

---

### Зачем нужны константы

На первый взгляд может показаться, что константы — это просто вопрос стиля.
На практике они решают несколько важных задач.

**1. Централизация настроек**

Вместо:

```python
delay = 5
...
time.sleep(5)
...
if retries > 5:
```

Мы имеем:

```python
DELAY = 5
MAX_RETRIES = 5
```

Изменения вносятся в одном месте.

---

**2. Защита от случайных ошибок**

Если значение используется напрямую, его легко:

- изменить по ошибке
- переопределить
- неправильно интерпретировать

Константа же сразу сигнализирует:

> это значение важно и фиксировано по смыслу

---

**3. Читаемость и поддержка кода**

Сравните:

```python
if status == 3:
    ...
```

и

```python
if status == STATUS_ACTIVE:
    ...
```

Во втором случае код:

- сам себя объясняет
- не требует комментариев
- проще для поддержки

---

### Константы и области видимости

С точки зрения областей видимости, константы обычно живут:

- в глобальной области файла
- вне функций

Схематично:

```
Глобальная область
 ├── CONSTANT_A
 ├── CONSTANT_B
 └── функции
      └── локальные имена
```

Функции:

- используют константы
- но не изменяют их

Это простое правило дисциплинирует код и избавляет от необходимости применять `global`.

---

### Где хранить константы

В небольших скриптах константы можно хранить прямо в файле с кодом, ближе к началу.

В более крупных программах обычно:

- выносят константы в отдельный файл
- используют его как источник настроек

Пока важно запомнить сам принцип:

> константы должны быть собраны в одном месте и легко доступны для чтения.

К вопросу о том, **как именно это делать**, мы вернёмся во втором модуле, когда начнём делить программу на файлы.

---

## Практика Модуль 1

**Задача 1**.

Объявите в программе глобальную переменную `call_count` равную нулю. Напишите функцию, которая увеличивает значение `call_count` на 1 и выводит текущее количество вызовов в формате "Функция вызвана N раз". Функцию необходимо вызвать **5 раз подряд**.

---

**Задача 2**

Объявите в программе пустой кортеж `logs`. Напишите функцию, которая принимает строку — текст сообщения и добавляет это сообщение в кортеж `logs`. Добавьте в `logs` сообщения `"Start"`, `"Processing"`, `"Finish"`. Выведите содержимое `logs`, выводя **каждое сообщение с новой строки**.

---

**Задача 3**

Создайте в программе константу, которая будет хранить `минимальное значение`, например `10` и список чисел `numbers = [3, 12, 7, 25, 9, 18, 2]`. Напишите функцию, которая принимает список чисел и возвращает список, содержащий только те числа, которые **строго больше константы**. Выведите на экран результат работы функции и изначальный список. Список `numbers` не должен измениться.

---

**Задача 4**

Напишите функцию, внутри которой создаётся начальное значение суммы, равное `0` и определяется вложенная функция. Вложенная функция принимает число и добавляет его к общей сумме. Вызовите вложенную функцию с числами `5`, `10` и `3`, после чего верните итоговую сумму. Выведите сумму на экран.

---

**Задача 5**

Напишите функцию, каждый вызов которой увеличивает счетчик внутри нее на единицу. Используйте вложенную функцию для изменения счетчика. Вызовите возвращённую функцию **4 раза подряд**.

---

# Модуль 2: Импорт и работа с модулями в Python

## Блок 7. Что такое модуль и зачем он нужен

До этого момента мы работали с программой как с **единым файлом**.
Все переменные, функции и логика находились в одном месте. Это нормально, пока программа маленькая. Но по мере роста кода возникает естественная проблема: **слишком много всего в одном файле**.

В Python эту проблему решают модули.

---

### Файл как модуль

В Python **любой файл с расширением `.py` — это модуль**.

Если у вас есть файл:

```text
settings.py
```

то для Python это уже:

- отдельная единица программы,
- со своим именем,
- со своим кодом,
- и со своей областью видимости.

Никаких дополнительных действий не требуется.
Файл становится модулем **по факту своего существования**.

---

### У каждого модуля — своё пространство имён

Когда Python загружает модуль, он:

1. создаёт **отдельное пространство имён**;
2. выполняет код файла сверху вниз;
3. сохраняет все созданные имена внутри этого модуля.

Схематично это можно представить так:

```
main.py
│
├── своё пространство имён
│   ├── переменные
│   └── функции
│
└── settings.py
    ├── своё пространство имён
    ├── переменные
    └── функции
```

Важно понимать:

> Переменные одного модуля **не попадают автоматически** в другой.

Чтобы получить доступ к данным другого файла, его нужно **явно подключить**.

---

### Импорт модуля: что происходит на самом деле

Рассмотрим простой пример.

Файл `config.py`:

```python
DEBUG = True
VERSION = "1.0"
```

Файл `main.py`:

```python
import config

print(config.DEBUG)
print(config.VERSION)
```

Когда Python выполняет строку:

```python
import config
```

он делает следующее:

1. находит файл `config.py`;
2. **выполняет весь код внутри него**;
3. создаёт объект модуля `config`;
4. добавляет этот объект в пространство имён текущего файла.

После этого доступ к данным модуля осуществляется **через его имя**:

```
config.DEBUG
config.VERSION
```

Это подчёркивает важную мысль:

> Модуль — это не просто «набор переменных»,
> а отдельный объект со своим пространством имён.

---

### Выполнение кода при импорте

> **При импорте выполняется весь код модуля.**

Если в `config.py` написать:

```python
print("Модуль config загружен")

DEBUG = True
```

то при импорте:

```python
import config
```

на экран будет выведено сообщение:

```
Модуль config загружен
```

Это означает, что:

- импорт — это не «подключение текста»,
- это **выполнение файла как программы**.

Именно поэтому так важно понимать, **что можно писать в модуле, а что — нет**.
К этому мы вернёмся позже, когда будем разбирать конструкцию `if __name__ == "__main__"`.

---

## Блок 8. Способы импорта: `import`, `from`, `as`

### **Оператор `import`**. Импорт всего модуля с помощью `import module`

Самая базовая и безопасная форма импорта выглядит так:

```python
import math

result = math.sqrt(25)
```

В этом случае:

- в текущее пространство имён добавляется **одно имя** — `math`;
- все объекты модуля доступны **через это имя**.

Схематично:

```
main.py
│
├── math  ──▶ модуль
│           ├── sqrt
│           ├── pi
│           └── ...
```

Такой способ импорта:

- явно показывает, **откуда берётся каждая функция или переменная**;
- практически исключает конфликты имён;
- делает код немного более многословным, но читаемым.

---

### **Оператор `from`**. Импорт отдельных объектов с помощью `from module import name`

Теперь рассмотрим другой подход:

```python
from math import sqrt, pi

result = sqrt(25)
area = pi * 10 ** 2
```

Здесь:

- в текущее пространство имён добавляются **конкретные имена** (`sqrt`, `pi`);
- имя модуля `math` при этом **не используется**.

Схематично:

```
main.py
│
├── sqrt
├── pi
```

Этот способ:

- делает код короче;
- удобен, когда используется **небольшое количество объектов**;
- но скрывает источник происхождения имени.

По коду `sqrt(25)` уже нельзя сразу понять, из какого модуля взята функция.

---

### Влияние на пространство имён

Выбор способа импорта напрямую влияет на то, **насколько "загруженным" становится пространство имён файла**.

Сравним два варианта.

```python
import statistics

average = statistics.mean([10, 20, 30]) # вычисляет среднее арифметическое списка чисел
```

и

```python
from statistics import mean

average = mean([10, 20, 30])
```

Во втором случае имя `mean`:

- становится частью текущего пространства имён;
- может конфликтовать с другой функцией или переменной с таким же именем.

Поэтому здесь важно соблюдать баланс между краткостью и ясностью.

---

### Оператор `as`. Управление именами с помощью `as`

Оператор `as` позволяет **переименовать импортируемый объект** в текущем файле.

Рассмотрим ситуацию, где без него не обойтись.

Есть два модуля:

`app_config.py`:

```python
settings = {
    "debug": True,
    "version": "1.0"
}
```

`user_config.py`:

```python
settings = {
    "theme": "dark",
    "language": "ru"
}
```

Если в основном файле написать:

```python
from app_config import settings
from user_config import settings
```

вторая строка **перезапишет первую**, и данные будут потеряны.

Решение — явное переименование:

```python
from app_config import settings as app_settings
from user_config import settings as user_settings

print(app_settings["version"])
print(user_settings["theme"])
```

Теперь:

- имена не конфликтуют;
- код остаётся читаемым;
- смысл каждого объекта ясен.

---

### `as` как инструмент читаемости

`as` используется не только для разрешения конфликтов, но и для повышения удобства работы.

```python
import datetime as dt

now = dt.datetime.now()
```

Здесь сокращение:

- не скрывает смысл;
- уменьшает визуальный шум;
- делает код компактнее без потери читаемости.

Важно помнить:

> `as` — это не хаотичное сокращение, а осознанное управление именами в текущем файле.

---

### Оператор `*`. Почему не стоит использовать `from module import *`

Иногда можно встретить такой вариант:

```python
from math import *
```

Формально он работает, но:

- непонятно, какие именно имена появились в пространстве имён;
- возможны конфликты;
- код становится труднее читать и сопровождать.

В учебных и реальных проектах такой импорт **лучше не использовать**.

---

## Блок 9. Логическое разделение программы на модули

К этому моменту мы уже знаем, что:

- каждый файл — это отдельный модуль;
- у каждого модуля своё пространство имён;
- импорт — это способ связать модули между собой.

Теперь пришло время ответить на главный практический вопрос:

> **Как понять, на какие модули вообще стоит делить программу?**

---

### Программа как набор ролей, а не строк кода

Любая программа, даже самая простая, обычно выполняет несколько разных ролей:

- хранит настройки,
- обрабатывает данные,
- управляет запуском.

Если всё это находится в одном файле, код быстро становится:

- перегруженным,
- трудным для чтения,
- неудобным для изменений.

Поэтому разумный подход — **разделять программу по ответственности**, а не по количеству строк.

---

### Пример задачи

Представим небольшую консольную программу:

> Программа обрабатывает список чисел:
>
> - отфильтровывает значения ниже заданного порога,
> - масштабирует оставшиеся значения,
> - выводит результат в удобном виде.

У программы есть:

- настройки (порог, коэффициент, формат вывода),
- логика обработки данных,
- точка входа — место, откуда всё запускается.

Это уже естественным образом подсказывает разбиение на модули.

---

### Предлагаемая структура

```
project/
│
├── constants.py   # настройки и параметры
├── processing.py  # логика обработки данных
└── main.py        # запуск программы
```

Каждый файл выполняет **одну понятную роль**.

---

### Модуль с константами

Файл `constants.py` содержит значения, которые:

- не меняются в процессе работы программы,
- влияют на её поведение,
- могут понадобиться в нескольких местах.

```python
MIN_VALUE = 10
MULTIPLIER = 2
SEPARATOR = " | "
```

Здесь нет логики, циклов или условий.
Только данные, определяющие «правила игры».

Это делает код:

- предсказуемым,
- легко настраиваемым,
- удобным для чтения.

---

### Модуль с логикой

Файл `processing.py` отвечает за обработку данных.

```python
from constants import MIN_VALUE, MULTIPLIER

def filter_values(numbers):
    return [n for n in numbers if n >= MIN_VALUE]

def scale_values(numbers):
    return [n * MULTIPLIER for n in numbers]
```

Здесь:

- нет ввода и вывода,
- нет запуска программы,
- только функции, которые делают свою работу.

Такую логику легко:

- тестировать,
- переиспользовать,
- дорабатывать независимо от остальной программы.

---

### Модуль запуска

Файл `main.py` — это точка входа программы.

```python
from processing import filter_values, scale_values
from constants import SEPARATOR

def main():
    data = [3, 12, 7, 25, 9, 18]

    filtered = filter_values(data)
    scaled = scale_values(filtered)

    print(SEPARATOR.join(map(str, scaled)))

main()
```

Здесь:

- собираются все части программы,
- вызываются функции,
- выводится результат.

Этот файл отвечает на вопрос:
**«Что происходит при запуске программы?»**

---

### Как это выглядит целиком

Схематично структура выглядит так:

```
constants.py ──▶ значения
       ▲
       │
processing.py ──▶ логика
       ▲
       │
     main.py ──▶ запуск
```

Каждый модуль:

- знает ровно столько, сколько ему нужно,
- не берёт на себя чужую ответственность.

---

### О структуре в реальных программах

Важно понимать:
**универсальной структуры не существует**.

В реальных проектах:

- модулей может быть больше,
- роли могут быть разделены иначе,
- некоторые модули объединяют логику и данные.

Допустимо:

- иметь отдельный модуль для работы с файлами,
- выносить форматирование вывода,
- группировать связанные функции.

Но стоит избегать:

- «всё в одном файле»,
- модулей, которые делают «всё сразу»,
- циклических импортов без необходимости.

Главный ориентир здесь — **читаемость и ответственность**.

---

## Блок 10. `if __name__ == "__main__"`

К этому моменту мы уже умеем:

- делить программу на модули,
- импортировать их разными способами,
- выносить логику и настройки в отдельные файлы.

Но теперь возникает важный вопрос:

> **Как Python понимает, какой файл сейчас является “главным”,
> а какие — просто подключаемыми модулями?**

Ответ на этот вопрос напрямую связан с переменной `__name__`.

---

### Откуда берётся `__name__`

`__name__` — это **служебная переменная**, которую Python автоматически создаёт **для каждого модуля**.

Значение `__name__` зависит от **способа запуска файла**:

- если файл **запущен напрямую**,
  его `__name__` равно строке `"__main__"`;
- если файл **подключён через `import`**,
  его `__name__` равно **имени модуля** (имени файла без `.py`).

Это правило работает всегда и не зависит от содержимого файла.

---

### Когда файл становится `__main__`

Рассмотрим простой пример структуры:

```
project/
│
├── main.py
└── utils.py
```

#### Содержимое `utils.py`:

```python
print(f"{__name__} загружен")
```

#### Содержимое `main.py`:

```python
import utils
print(f"{__name__} запущен")
```

Если запустить программу командой:

```
python main.py
```

произойдёт следующее:

1. Python запускает `main.py`;
2. для `main.py`:

   ```python
   __name__ == "__main__"
   ```

3. выполняется `import utils`;
4. код `utils.py` выполняется, но:

   ```python
   __name__ == "utils"
   ```

Именно поэтому Python всегда знает:

- **какой файл — точка входа**,
- а какие — вспомогательные модули.

---

### Зачем вообще нужна эта проверка

Рассмотрим распространённую проблему.

Файл `processing.py`:

```python
def calculate(numbers):
    return sum(numbers)

print(calculate([1, 2, 3]))
```

Если импортировать этот файл:

```python
import processing
```

то результат будет выведен **сразу при импорте**, даже если мы этого не хотели.

Это неудобно, потому что:

- модуль с логикой начинает вести себя как программа,
- импорт приводит к побочным эффектам,
- код становится труднее контролировать.

---

### Решение: `if __name__ == "__main__"`

Чтобы отделить:

- **код для запуска**,
- от **кода для использования**,

в Python используют конструкцию:

```python
if __name__ == "__main__":
    ...
```

Перепишем пример:

```python
def calculate(numbers):
    return sum(numbers)

if __name__ == "__main__":
    print(calculate([1, 2, 3]))
```

Теперь:

- при запуске `processing.py` напрямую — код выполнится;
- при импорте `processing` — выполнится только определение функций.

---

### Что происходит при разных вариантах запуска

Разберём это пошагово.

#### Вариант 1. Прямой запуск файла

```
python processing.py
```

- Python присваивает:

  ```python
  __name__ = "__main__"
  ```

- условие выполняется;
- код внутри `if` запускается.

---

#### Вариант 2. Импорт файла

```python
import processing
```

- Python присваивает:

  ```python
  __name__ = "processing"
  ```

- условие не выполняется;
- код внутри `if` **пропускается**.

---

### Использование в главном модуле

Типичный шаблон для файла запуска:

```python
from processing import calculate

def main():
    data = [4, 8, 15]
    result = calculate(data)
    print(result)

if __name__ == "__main__":
    main()
```

Здесь:

- `main()` — логическая точка входа;
- проверка гарантирует, что запуск произойдёт **только при прямом запуске файла**.

Это особенно важно, если файл:

- будет импортироваться в других местах,
- или использоваться для тестирования.

---

### Использование в дополнительных модулях

Конструкция `if __name__ == "__main__"` полезна **не только в главном файле**.

В модуле с логикой можно писать:

```python
def filter_values(data):
    return [x for x in data if x > 10]

if __name__ == "__main__":
    test_data = [5, 12, 7, 20]
    print(filter_values(test_data))
```

Это позволяет:

- быстро проверить работу функций,
- не мешая основной программе,
- и не создавая отдельный тестовый файл.

Такой подход называют **локальным тестированием**.

---

### Визуальная схема

```
Запуск напрямую
│
├── __name__ = "__main__"
└── код внутри if выполняется

Импорт
│
├── __name__ = "module_name"
└── код внутри if пропускается
```

---

## Практика Модуль 2

**Задача 1**

Дан текстовый файл `cars.txt` с номерами машин, записанных каждая с новой строки. Напишите программу которая:

- считывает данные из файла;
- определяет общее количество записей в файле;
- определяет количество уникальных автомобильных номеров;
- выводит результат в консоль.

Программа должна содержать три различных модуля:

- модуль для чтения данных из файла;
- модуль для анализа данных;
- модуль запуска программы.

Содержимое файла `cars.txt`:

```txt
Е220СК
А123ВС
М456ОР
Е220СК
К777КК
А123ВС
Н890ТР
С345МН
Е220СК
Т111ТО
Р222РР
М456ОР
О999ОО
К777КК
В321ВВ
С345МН
Н890ТР
А123ВС
Т111ТО
Е220СК
```

---

**Задача 2**

Дан текстовый файл `data.txt` с текстовой информацией. Напишите программу, которая должна:

- Считать текст из файла;
- Посчитать количество символов с учётом пробелов;
- Посчитать количество символов без учёта пробелов;
- Вывести оба значения в консоль.

Программа должна содержать три различных модуля:

- модуль загрузки текстовых данных;
- модуль логики подсчёта символов;
- модуль запуска программы.

Содержимое файла `data.txt`:

```txt
Python — это язык программирования, который используется
для анализа данных, веб-разработки и автоматизации.
Он прост в изучении и широко применяется на практике.
```

---

**Задача 3**

Дан json-файл `people.json` со словарём вида _имя — возраст_. Напишите программу, которая должна:

- Считать данные из файла;
- Определить самого младшего человека;
- Определить самого старшего человека;
- Определить средний возраст;
- Вывести результат в консоль.

_\*Если возраст встречается несколько раз — вывести **первого найденного** человека._

Программа должна содержать три различных модуля:

- модуль загрузки данных;
- модуль анализа возрастов;
- модуль запуска программы.

Содержимое файла `people.json`:

```json
{
  "Иван": 25,
  "Кантемир": 30,
  "Анна": 30,
  "Фатима": 21,
  "Петр": 22,
  "Азрет": 25,
  "Мария": 27,
  "Олег": 34,
  "Светлана": 29,
  "Алина": 21,
  "Руслан": 34,
  "Елена": 26,
  "Дмитрий": 28,
  "Наталья": 31,
  "Артем": 22
}
```

_\*Усложнение. Если возраст повторяется, вывести **всех людей** с этим возрастом._

**Задача 4**

Дан текстовый файл `math.txt`, содержащий математические примеры. Напишите программу которая должна:

- Считать примеры из файла.
- Проверить корректность формата данных.
- Вычислить результат каждого примера.
- Записать решения в новый файл `results.txt` в формате: `10 + 5 = 15`

Программа должна содержать три различных модуля:

- модуль работы с файлами;
- модуль обработки и вычисления примеров;
- модуль запуска программы.

Осуществить проверки:

- в модуле загрузки должна быть проверка функции, которая формирует входные данные;
- в модуле логики — проверка корректности операций.

Содержимое файла `math.txt`:

```txt
10 + 5
20 - 7
3 + 14
50 - 25
8 + 12
100 - 40
6 + 9
30 - 18
7 + 3
45 - 20
```

# Модуль 3. Стандартные библиотеки Python

`random`, `datetime`, `string`, `os`, `sys`

## Блок 11. Модуль `random` — работа со случайными данными

До этого момента мы работали с **предсказуемыми данными**: числами, строками, файлами, структурами, которые заданы заранее.
Но на практике программы часто сталкиваются с другой задачей — **создавать данные**, а не только обрабатывать их.

Именно здесь появляется необходимость в случайности.

---

### Зачем в программах нужна случайность

Случайность используется не для создания «хаоса», а для моделирования реальных сценариев:

* **игры** — случайные события, бросок кубика, выпадение карты;
* **тестирование** — генерация данных без ручного ввода;
* **симуляции** — приближённое моделирование реальных процессов;
* **обучение и отладка** — проверка логики на разных входных данных.

Важно понимать ключевую мысль:

> Случайность в Python — это **управляемый инструмент**, а не набор непредсказуемых действий.

Модуль `random` позволяет:

* контролировать диапазон значений,
* выбирать элементы из заданных наборов,
* воспроизводить результаты при необходимости.

---

### Основные возможности модуля `random`

Модуль `random` предоставляет функции для работы со случайными значениями, но на практике чаще всего используются три направления.

#### 1. Генерация случайных чисел

Используется, когда нужно получить число в заданном диапазоне — например, возраст, количество попыток, уровень сложности.

```python
import random

# Случайный возраст от 18 до 65
age = random.randint(18, 65)

print("Случайный возраст:", age)
```

#### 2. Выбор случайного элемента

Позволяет выбрать один элемент из списка, кортежа или другой коллекции.
Часто применяется для имён, слов, вариантов действий.

```python
import random

names = ["Анна", "Игорь", "Мария", "Дмитрий", "Елена"]

chosen_name = random.choice(names)

print("Выбранное имя:", chosen_name)
```

#### 3. Работа со списками

Случайность часто применяется не к отдельным значениям, а к целым наборам данных — например, при генерации коллекций или их перемешивании.

```python
import random

numbers = [1, 2, 3, 4, 5, 6, 7]

random.shuffle(numbers)

print("Перемешанный список:", numbers)
```

---

### Практический пример

### Генерация тестовых пользователей

#### Условие задачи

Необходимо написать программу, которая формирует список тестовых пользователей.

Требования:

* программа должна сгенерировать несколько пользователей;
* каждый пользователь представлен словарём;
* структура словаря:

```python
{
    "name": <имя пользователя>,
    "age": <возраст пользователя>
}
```

Данные должны формироваться **случайным образом**, но на основе заранее заданных правил.

---

#### Подход к решению

1. Заранее определить список возможных имён.
2. Определить допустимый диапазон возраста.
3. Сгенерировать нужное количество пользователей.
4. Сформировать список словарей.

Такой подход имитирует реальные данные и часто используется при тестировании программ.

---

#### Пример реализации

```python
import random

NAMES = ["Анна", "Иван", "Петр", "Мария", "Ольга", "Дмитрий"]
MIN_AGE = 18
MAX_AGE = 60
USERS_COUNT = 5

users = []

for _ in range(USERS_COUNT):
    user = {
        "name": random.choice(NAMES),
        "age": random.randint(MIN_AGE, MAX_AGE)
    }
    users.append(user)

print(users)
```

Что происходит в этом коде:

* используется **готовый набор имён**;
* возраст генерируется в контролируемом диапазоне;
* результат — список структурированных данных, удобных для дальнейшей обработки.

Обрати внимание:
несмотря на использование случайности, программа остаётся **предсказуемой по структуре**.

---

### Дополнительная информация

#### Фиксация генератора случайных чисел

Иногда важно, чтобы программа при каждом запуске генерировала **одни и те же значения**.
Это полезно для тестирования и отладки.

В таких случаях используется фиксация генератора:

```python
random.seed(10)
```

После этого последовательность случайных значений будет воспроизводимой.

---

_*Подробнее про модуль `random` можно узнать из документации: [python module random](https://docs.python.org/3/library/random.html)_

---

## Блок 12. Модуль `datetime` — работа с датами и временем

В предыдущем блоке мы говорили о случайности и генерации данных.
Теперь переходим к другой фундаментальной вещи — **времени**.

Практически любая программа сталкивается с вопросами:

* когда произошло событие,
* сколько времени прошло,
* сколько осталось до нужного момента.

Для решения этих задач в Python используется модуль `datetime`.

---

### Почему дата — это не строка и не число

Дата может выглядеть как строка:

```text
"2026-12-31"
```

или как число:

```text
20261231
```

Но такие представления не подходят для вычислений.
С ними невозможно:

* корректно вычесть даты,
* учесть длину месяцев,
* работать со временем и интервалами.

В Python дата — это **отдельный тип данных**, который:

* хранит структуру (год, месяц, день, время),
* поддерживает арифметику,
* умеет сравниваться и форматироваться.

Именно поэтому для работы с датами используется специализированный модуль.

---

### Где время играет ключевую роль

Работа с датой и временем критична в задачах:

* **логи** — фиксация действий и ошибок;
* **события** — начало и окончание процессов;
* **сроки** — дедлайны, подписки, таймеры;
* **аналитика** — интервалы, периоды, статистика.

Ошибки во времени почти всегда приводят к логическим сбоям, поэтому ручные решения здесь недопустимы.

---

### Основные возможности модуля `datetime`

На практике чаще всего используются три базовые операции.

#### Получение текущей даты и времени

```python
from datetime import datetime

now = datetime.now()
```

Этот момент времени часто используется как точка отсчёта.

---

#### Разница между датами

```python
from datetime import datetime

start = datetime(2026, 1, 1)
end = datetime(2026, 1, 10)

delta = end - start
```

Результат — **временной интервал**, а не число или строка.

---

#### Представление даты в читаемом виде

Объект даты внутри программы — это не то, что удобно читать человеку.
Поэтому дату почти всегда преобразуют в строку.

---

### Практический пример

### Подсчёт времени до события и запись результата в файл

#### Условие задачи

Написать программу, которая:

1. Получает текущую дату и время.
2. Задаёт дату будущего события.
3. Вычисляет, сколько времени осталось до события.
4. Записывает информацию в файл в **разных форматах отображения даты**:

   * полная дата и время,
   * только год и месяц.

---

#### Пример реализации

```python
from datetime import datetime

now = datetime.now()
event_date = datetime(2026, 12, 31, 23, 59)

time_left = event_date - now

full_format = event_date.strftime("%Y-%m-%d %H:%M")
short_format = event_date.strftime("%Y-%m")

result = (
    f"Текущая дата и время: {now}\n"
    f"Дата события (полностью): {full_format}\n"
    f"Дата события (год и месяц): {short_format}\n"
    f"До события осталось: {time_left}\n"
)

with open("event_info.txt", "w", encoding="utf-8") as file:
    file.write(result)
```

Здесь важно:

* дата внутри программы остаётся объектом `datetime`,
* формат меняется **только при выводе**,
* один и тот же объект можно представить по-разному.

---

### Дополнительная информация

#### Форматирование даты

Дата может быть представлена в любом удобном виде:

```python
date = datetime.now()

print(date.strftime("%d.%m.%Y"))
print(date.strftime("%Y/%m/%d"))
print(date.strftime("%H:%M:%S"))
```

Это особенно полезно для логов и файлов.

---

#### Работа с отдельными частями даты

Можно получить конкретные элементы даты:

```python
date = datetime.now()

year = date.year
month = date.month
day = date.day
```

Это удобно для условий и анализа данных.

---

#### Представление времени в секундах

Разницу между датами можно представить в секундах:

```python
event_date = datetime(2026, 12, 31, 23, 59)
delta = event_date - now
seconds = delta.total_seconds()
```

Такое представление используется:

* в таймерах,
* в симуляциях,
* в измерении производительности.

---

#### Работа с датой в прошлом или будущем

Иногда требуется не узнать разницу между датами, а **получить конкретную дату в прошлом**:

* 10 дней назад,
* несколько недель назад,
* определённый период относительно текущего момента.

Для этого используется временной интервал.

```python
from datetime import datetime, timedelta

now = datetime.now()
past_date = now - timedelta(days=10)  # дата несколько дней назад
future_date = now + timedelta(days=7)  # дата через несколько дней

print(past_date)
print(future_date)
```

* `timedelta` описывает промежуток времени,
* из текущей даты вычитается нужное количество дней,
* результат — объекты даты, с которыми можно работать дальше.

Такая логика часто используется:

* в сроках выполнения задач,
* при расчёте дедлайнов,
* в планировании событий.

---

_*Подробнее про модуль `datetime` можно узнать из документации: [python module datetime](https://docs.python.org/3/library/datetime.html)_

---

## Блок 13. Модуль `string` — наборы символов и работа со строками

Когда программа начинает **создавать строки сама**, а не просто обрабатывать пользовательский ввод, быстро появляется повторяющаяся логика:
наборы букв, цифр, допустимые символы, ограничения на формат.

Модуль `string` решает именно эту задачу — он предоставляет **готовые, проверенные наборы символов**, которые можно использовать в реальных сценариях: генерация паролей, токенов, идентификаторов, тестовых данных.

---

### Для чего нужна библиотека `string`

`string` — это вспомогательный модуль для работы со строками, который избавляет от ручного описания символов.

Без него программист часто пишет так:

```python
letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
digits = "0123456789"
```

Проблемы этого подхода:

* легко допустить ошибку;
* код плохо читается;
* каждый пишет по-своему;
* сложнее менять и масштабировать логику.

`string` предлагает **единый стандарт** — наборы символов, которые:

* очевидны по названию;
* не содержат опечаток;
* используются одинаково во всех проектах.

---

### Основные возможности и наборы символов

Модуль `string` **не работает со строками напрямую** (как методы `split()` или `replace()`),
его задача — **предоставлять строительные блоки**.

#### Основные константы

```python
import string
```

##### Буквы

```python
string.ascii_lowercase   # abcdefghijklmnopqrstuvwxyz
string.ascii_uppercase   # ABCDEFGHIJKLMNOPQRSTUVWXYZ
string.ascii_letters     # все буквы сразу
```

Используются, когда:

* нужно ограничить ввод;
* требуется генерация текстовых данных;
* важно явно указать допустимый алфавит.

---

##### Цифры

```python
string.digits   # 0123456789
```

Полезно:

* при генерации кодов;
* при проверке строк;
* в паролях и идентификаторах.

---

##### Специальные символы

```python
string.punctuation
```

Содержит:

```
!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
```

Используется:

* в паролях;
* при очистке текста;
* при анализе строк.

---

##### Объединение наборов

```python
symbols = string.ascii_letters + string.digits
```

Это **ключевая идея** библиотеки:
готовые наборы легко комбинируются под задачу.

---

### Практический пример: генератор паролей

Рассмотрим задачу, которая **наглядно показывает пользу `string`**.

**Условие задачи**
Нужно создать программу, которая:

* позволяет выбрать, какие символы использовать;
* генерирует пароли заданной длины;
* создаёт несколько вариантов паролей.

---

#### Логика решения

1. Выбираем набор символов:

   * буквы;
   * цифры;
   * специальные символы.
2. Используем `random` для случайного выбора.
3. Собираем строку нужной длины.
4. Повторяем генерацию несколько раз.

---

#### Пример реализации

```python
import string
import random

def generate_password(length, use_letters=True, use_digits=True, use_symbols=True):
    characters = ""

    if use_letters:
        characters += string.ascii_letters
    if use_digits:
        characters += string.digits
    if use_symbols:
        characters += string.punctuation

    password = ""
    for _ in range(length):
        password += random.choice(characters)

    return password
```

---

#### Генерация нескольких вариантов

```python
for i in range(5):
    print(generate_password(12))
```

---

#### Почему здесь важен `string`

* наборы символов читаются **по смыслу**, а не по содержимому;
* легко менять требования к паролю;
* код остаётся компактным и расширяемым;
* логика генерации не зависит от конкретных символов.

Это типичный пример, где `string` **делает код чище и профессиональнее**, а не просто короче.

---

### Дополнительная информация и полезные возможности

#### Проверка принадлежности символов

```python
char = "A"

if char in string.ascii_uppercase:
    print("Заглавная буква")
```

Полезно при:

* валидации данных;
* анализе строк;
* фильтрации ввода.

---

#### Удаление специальных символов из строки

```python
text = "Hello, world!"
clean_text = ""

for char in text:
    if char not in string.punctuation:
        clean_text += char

print(clean_text)
```

---

#### Почему не стоит «писать всё руками»

* ручные строки хуже читаются;
* выше риск ошибок;
* сложнее поддерживать код;
* стандартная библиотека уже решает эту задачу.

Использование `string` — это **признак аккуратного и зрелого кода**, а не избыточности.

`string` редко используется в одиночку,
но **регулярно встречается в реальных проектах**, где требуется контроль над символами и форматами.

---

_*Подробнее про модуль `string` можно узнать из документации: [python module string](https://docs.python.org/3/library/string.html)_

---

## Блок 14. Модуль `os` — работа с файловой системой

До этого момента программы, которые мы писали, существовали в довольно «стерильной» среде:
переменные в памяти, ввод с клавиатуры, вывод в консоль или файл с заранее известным именем.

Но в реальных программах почти всегда возникает вопрос:

* где именно лежит файл;
* существует ли он;
* есть ли нужная папка;
* какие файлы уже есть в директории.

Модуль `os` — это **мост между Python и операционной системой**.
Он позволяет программе *узнавать* о файловой системе и *взаимодействовать* с ней осознанно, а не вслепую.

---

### Для чего нужна библиотека `os`

`os` отвечает за всё, что связано с окружением, в котором работает программа:

* файлы и папки;
* пути;
* структуру директорий;
* различия между операционными системами.

Без `os` программа:

* не знает, существует ли файл;
* не может корректно работать с папками;
* привязывается к конкретной ОС;
* легко ломается при переносе.

С `os` программа начинает **ориентироваться в пространстве файловой системы**, а не просто читать и писать данные.

---

### Почему программе важно «знать» о файлах и папках

Перед любой работой с файлами обычно нужно:

* проверить, существует ли файл;
* убедиться, что папка создана;
* корректно сформировать путь;
* понять, какие файлы уже есть.

Программа, которая **не делает проверок**, часто:

* падает с ошибками;
* перезаписывает данные;
* ведёт себя непредсказуемо.

`os` позволяет заранее задать корректный сценарий работы.

---

### Основные возможности и методы

```python
import os
```

---

#### Получение текущей рабочей директории

```python
os.getcwd()
```

Это папка, **относительно которой программа запускается**.
Важно понимать, что она может отличаться от папки, где лежит файл с кодом.

---

#### Работа с путями (`os.path`)

`os.path` — отдельный, крайне важный подмодуль.

##### Создание универсального пути

```python
path = os.path.join("data", "files", "report.txt")
```

Почему это важно:

* в Windows используются `\`
* в Linux и macOS — `/`

`os.path.join()` **сам подбирает нужный формат**, делая код переносимым.

---

##### Проверка существования файла или папки

```python
os.path.exists(path)
```

Один из самых часто используемых вызовов —
позволяет избежать ошибок до того, как они произошли.

---

##### Проверка типа пути

```python
os.path.isfile(path)
os.path.isdir(path)
```

Это особенно полезно при анализе содержимого папок.

---

### Работа с папками

#### Получение списка файлов и папок

```python
os.listdir(path)
```

Возвращает список имён — без информации о типе объекта.
Поэтому часто используется вместе с `os.path`.

---

#### Создание папки

```python
os.mkdir("data")
```

Если папка уже существует — будет ошибка,
поэтому на практике почти всегда добавляют проверку.

---

### Практический пример: анализ содержимого папки

Рассмотрим задачу, приближенную к реальным сценариям.

**Условие задачи**
Программа должна:

* сформировать путь до указанной папки;
* получить список файлов;
* найти файлы определённого формата (например `.txt`);
* вывести результат.

---

#### Логика решения

1. Создаём путь к папке.
2. Проверяем, существует ли она.
3. Получаем список элементов.
4. Отбираем только файлы нужного формата.

---

#### Пример реализации

```python
import os

folder_path = os.path.join("data", "documents")

if not os.path.exists(folder_path):
    print("Папка не найдена")
else:
    files = os.listdir(folder_path)

    txt_files = []
    for file in files:
        full_path = os.path.join(folder_path, file)
        if os.path.isfile(full_path) and file.endswith(".txt"):
            txt_files.append(file)

    print("Найденные txt-файлы:")
    for name in txt_files:
        print(name)
```

---

#### Что здесь важно понять

* программа не предполагает, что папка существует;
* путь формируется универсально;
* фильтрация идёт осознанно, а не «по названию»;
* логика легко расширяется под другие форматы.

---

### Проверки перед созданием файлов

Хорошая практика:

* **не создавать файл, не проверив папку**;
* **не перезаписывать данные без необходимости**.

Пример базовой проверки:

```python
file_path = os.path.join("data", "result.txt")

if not os.path.exists("data"):
    os.mkdir("data")

if not os.path.exists(file_path):
    with open(file_path, "w") as file:
        file.write("Файл создан")
```

---

### Дополнительная информация

#### Создание вложенных папок

```python
os.makedirs("data/reports/2025", exist_ok=True)
```

Позволяет создать сразу всю цепочку директорий.

---

#### Удаление файла

```python
os.remove("data/old_file.txt")
```

Перед этим **обязательно** стоит проверить существование.

---

#### Удаление папки

```python
os.rmdir("empty_folder")
```

Работает только с пустыми папками.

---

#### Переносимость между ОС

Главная идея:

* **не писать пути вручную**;
* **использовать `os.path`**;
* **не полагаться на конкретную файловую структуру**.

Код, написанный с использованием `os`,
будет одинаково работать в Windows, Linux и macOS без изменений.

---

`os` — это не «дополнительная библиотека»,
а **основа для всех программ, которые работают с файлами всерьёз**.

---

_*Подробнее про модуль `os` можно узнать из документации: [python module os](https://docs.python.org/3/library/os.html)_

_*Подробнее про модуль `os.path` можно узнать из документации: [python module os.path](https://docs.python.org/3/library/os.path.html)_

---

## Блок 15. Модуль `sys` — взаимодействие с интерпретатором

До этого момента мы работали с тем, **что окружает программу снаружи**:
файлы, папки, структура диска, данные.

Теперь сделаем шаг глубже и посмотрим на другой уровень —
**как программа взаимодействует с самим интерпретатором Python**.

Модуль `sys` — это не про файлы и не про строки.
Это про то:

* *как* была запущена программа,
* *с какими параметрами*,
* *в каком окружении* она выполняется,
* и *как она может управлять своим завершением*.

---

### Для чего нужна библиотека `sys`

Если упростить, `sys` отвечает на вопрос:

> «Что знает Python о самом себе в момент выполнения программы?»

Через `sys` программа может:

* получить аргументы командной строки;
* узнать информацию о среде выполнения;
* управлять выводом и завершением;
* реагировать на разные режимы запуска.

Важно понять:
**командная строка — это не магия**,
это просто набор строк, которые Python получает при старте программы.
И `sys` — это способ эти строки прочитать и обработать.

---

### Почему `sys` изучается уже в базовом курсе

Даже простые программы со временем начинают:

* запускаться с параметрами;
* работать в разных режимах;
* вести себя по-разному в зависимости от среды.

Без `sys`:

* программа всегда «одинаковая»;
* невозможно отличить обычный запуск от тестового;
* сложнее писать автоматизацию.

`sys` — первый шаг к пониманию:

* консольных утилит;
* скриптов;
* инструментов автоматизации.

---

### Основные возможности `sys`

```python
import sys
```

---

#### Аргументы запуска программы — `sys.argv`

Самая важная часть модуля.

```python
sys.argv
```

Это **список строк**, где:

* `sys.argv[0]` — имя файла программы
* остальные элементы — аргументы запуска

Пример запуска:

```bash
python app.py test debug
```

В программе:

```python
print(sys.argv)
```

Результат:

```python
['app.py', 'test', 'debug']
```

> Python **не интерпретирует** аргументы. Он просто передаёт их программе как строки.

---

#### Как программа узнаёт, в каком режиме её запустили

Программа сама анализирует `sys.argv` и принимает решения.

Пример простой проверки:

```python
if "test" in sys.argv:
    print("Тестовый режим")
```

---

#### Базовая информация о среде выполнения

```python
sys.version
```

Версия интерпретатора Python.

```python
sys.platform
```

Платформа выполнения (`win32`, `linux`, `darwin` и т.д.).

```python
sys.executable
```

Путь к интерпретатору Python, который запустил программу.

Эта информация часто используется:

* в установщиках;
* в скриптах настройки;
* при отладке.

---

### Практический пример: программа с режимами запуска

Рассмотрим задачу, которая часто встречается на практике.

**Условие задачи**
Создать программу, которая:

* работает в обычном режиме по умолчанию;
* может быть запущена в тестовом режиме;
* может быть запущена в режиме отладки.

Режим определяется аргументами командной строки.

---

#### Идея решения

1. Получить аргументы запуска.
2. Проверить наличие ключевых слов.
3. Изменить поведение программы в зависимости от режима.

---

#### Пример реализации

```python
import sys

def main():
    if "test" in sys.argv:
        print("Запуск в тестовом режиме")
        print("Проверка логики без реальных данных")

    elif "debug" in sys.argv:
        print("Запуск в режиме отладки")
        print("Аргументы запуска:", sys.argv)
        print("Версия Python:", sys.version)

    else:
        print("Обычный режим работы программы")

if __name__ == "__main__":
    main()
```

---

#### Как это работает на практике

Запуск без аргументов:

```bash
python app.py
```

Результат:

```
Обычный режим работы программы
```

Запуск в тестовом режиме:

```bash
python app.py test
```

Запуск в режиме отладки:

```bash
python app.py debug
```

Важно:
**Python ничего не знает про «test» или «debug»** —
это *ваша логика*, построенная на строках аргументов.

---

### Дополнительная информация

#### Завершение программы — `sys.exit()`

```python
sys.exit()
```

Используется для:

* принудительного завершения;
* остановки программы при ошибке;
* выхода с кодом состояния.

```python
sys.exit(1)
```

Код `1` обычно означает ошибку.

---

#### Управление выводом — `sys.stdout.write()`

Альтернатива `print()`:

```python
sys.stdout.write("Текст без переноса строки")
```

Используется:

* в логах;
* в консольных утилитах;
* когда нужен точный контроль вывода.

Аналогично:

```python
sys.stderr.write("Сообщение об ошибке")
```

---

#### Где `sys` используется в реальных проектах

* консольные утилиты (`pip`, `django-admin`, `pytest`);
* системы логирования;
* запуск программ с конфигурациями;
* тестовые и отладочные режимы;
* автоматизация и CI/CD.

`sys` редко используется «в одиночку»,
но почти всегда — **в связке с другими модулями**.

---

_*Подробнее про модуль `sys` можно узнать из документации: [python module sys](https://docs.python.org/3/library/sys.html)_

---

## Практика Модуль 3

**Задача 1**

Необходимо создать программу для регистрации пользователей. Программа должна работать следующим образом:
* Пользователь вводит свой ник.
* Программа автоматически генерирует для него пароль.
* Сгенерированный пароль выводится в терминал вместе с ником пользователя.

Требования к паролю:
* длина пароля — **от 8 до 10 символов**
* пароль должен содержать строчные буквы, заглавные буквы, цифры и специальные символы.

_*Усложнение: данные пользователя (ник и пароль) необходимо сохранить в файл формата `json`._

_*Усложнение: программа должна быть разделена на логические модули:_
```
user_generator/
│
├── password_generator.py  # Генерация пароля
├── storage.py  # Работа с JSON-файлом
├── main.py  # Запуск программы
```

**Задача 2**

Необходимо создать программу для работы со списком задач. Программа должна работать в **бесконечном цикле** и позволять пользователю:
* Вводить формулировку задачи.
* Вводить дату, к которой задача должна быть выполнена.
* У пользователя должна быть возможность вывести **все сохранённые задачи** на экран.

После ввода данных программа должна выводить в консоль сообщение следующего вида:

```
Задача: <формулировка задачи>
Должна быть выполнена через N дней
Дата окончания задачи: <дата>
```

Все введённые задачи должны сохраняться **в списке** во время работы программы.

_*Усложнение: после добавления каждой задачи программа должна записывать её в текстовый файл. Формат записи в файл должен быть таким же, как формат хранения в списке._

_*Усложнение: программа должна быть разделена на модули:_
```txt
task_manager/
│
├── date_utils.py  # Работа с датами
├── tasks.py  # Логика задач
├── storage.py  # Запись в файл
├── main.py  # Основной цикл
```

**Задача 3**

Необходимо написать программу для поиска файлов в заданной папке. Путь до папки должен быть задан в программе **как константа**. Пользователь вводит название файла для поиска. Программа проверяет наличие файла в указанной папке. Программа должна работать следующим образом:
* если файл найден — вывести информацию о файле;
* если файл не найден — вывести сообщение об отсутствии файла и предложить ввести имя файла снова;
* если пользователь вводит **пустую строку**, программа должна завершить работу.

_*Усложнение: Режим работы программы должен определяться при запуске._

Программа должна поддерживать **два режима запуска**: Обычный режим () и Расширенный режим ().
* **В обычном режиме**: выполняется только поиск файла по имени.
* **В расширенном режиме**: если файл имеет формат `.txt`, пользователю предлагается ввести слово для поиска в файле и программа должна выдавать номера строк, в которых встречается это слово.

_*Усложнение: программа должна быть разделена на модули:_
```txt
file_search/
│
├── config.py  # Константы
├── search.py  # Поиск файлов
├── text_search.py  # Поиск слов в txt-файле
├── main.py  # Режимы запуска
```

---

[Предыдущий урок](lesson33.md) | [Следующий урок](lesson35.md)